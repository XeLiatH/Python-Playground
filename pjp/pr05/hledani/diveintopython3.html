
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Dive Into Python 3</title>
<meta name="author" content="Mark Pilgrim">
<meta name="subject" content="Python 3 from novice to pro">
<meta name="keywords" content="python, python3, py3k, free, book">
<meta name="date" content="2012-03-27">
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 -2}
h1:before{counter-increment:h1}
</style>
<style>
#chapter-index h1:before, #chapter-index h2:before{content:''}
#chapter-index #a, #chapter-index #b, #chapter-index #c, #chapter-index #d, #chapter-index #e{list-style:none;margin:0 0 0 -1.7em}
#chapter-index #a:before{content:'A. \00a0 \00a0'}
#chapter-index #b:before{content:'B. \00a0 \00a0'}
#chapter-index #c:before{content:'C. \00a0 \00a0'}
#chapter-index #d:before{content:'D. \00a0 \00a0'}
#chapter-index #e:before{content:'E. \00a0 \00a0'}
#chapter-table-of-contents h1:before{content:''}
#chapter-table-of-contents ol, #chapter-table-of-contents ul{font-weight:bold}
#chapter-table-of-contents li ol{font-weight:normal}
#chapter-table-of-contents #porting-code-to-python-3-with-2to3, #chapter-table-of-contents #special-method-names, #chapter-table-of-contents #where-to-go-from-here, #chapter-table-of-contents #troubleshooting, #chapter-table-of-contents #changelog{list-style:none;margin:0 0 0 -2em}
#chapter-table-of-contents #porting-code-to-python-3-with-2to3 > ol, #chapter-table-of-contents #special-method-names > ol, #chapter-table-of-contents #where-to-go-from-here > #troubleshooting > #changelog > ol{margin:0;padding:0 0 0 4.5em}
#chapter-table-of-contents #porting-code-to-python-3-with-2to3:before{content:'A. \00a0 \00a0'}
#chapter-table-of-contents #special-method-names:before{content:'B. \00a0 \00a0'}
#chapter-table-of-contents #where-to-go-from-here:before{content:'C. \00a0 \00a0'}
#chapter-table-of-contents #troubleshooting:before{content:'D. \00a0 \00a0'}
#chapter-table-of-contents #changelog:before{content:'E. \00a0 \00a0'}
#chapter-whats-new h3:before{content:''}
#chapter-installing-python .i{list-style:none;margin:0;padding:0}
#chapter-installing-python #which{padding-top:1.75em}
#chapter-installing-python h2, #chapter-installing-python .i>li{clear:both}
#chapter-installing-python #divingin, #chapter-installing-python #which{clear:none}
#chapter-your-first-python-program table{border:1px solid #bbb;border-collapse:collapse;margin:auto}
#chapter-your-first-python-program td, #chapter-your-first-python-program th{border:1px solid #bbb;padding:0 1.75em}
#chapter-your-first-python-program th{text-align:left}
#chapter-your-first-python-program mark{display:inline}
#chapter-advanced-iterators mark{display:inline}
#chapter-files mark{display:inline}
#chapter-xml mark{display:inline}
#chapter-http-web-services mark{display:inline}
#chapter-case-study-porting-chardet-to-python-3 ins, #chapter-case-study-porting-chardet-to-python-3 del{line-height:2.154;text-decoration:none;font-style:normal;display:inline-block;width:100%}
#chapter-case-study-porting-chardet-to-python-3 ins{background:#9f9}
#chapter-case-study-porting-chardet-to-python-3 del{background:#f87}
#chapter-packaging mark{display:inline}
#chapter-about h1:before{content:''}
#chapter-about #belong{margin:0 auto;width:558px;height:738px;background:#fff url(i/openclipart.org_media_files_Selanit_8331.png) no-repeat;border:1px solid white}
#chapter-about #belong div{margin:375px 30px 0 40px}
#chapter-about div p{font-size:small}
#chapter-about abbr{font-variant:none;text-transform:none;letter-spacing:0}
#chapter-colophon h1:before, #chapter-colophon h2:before{content:''}
#chapter-colophon .ss{float:right;margin:0 0 1.75em 1.75em}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
</head>
<body>
<div id=chapter-index>
<h1>Ponořme se do Pythonu 3</h1>

<p><cite>Ponořme se do Pythonu 3</cite> pokrývá vlastnosti jazyka Python 3 a popisuje rozdíly proti jazyku Python 2. Ve srovnání s <cite><a href="http://www.diveintopython.net/">Dive Into Python</a></cite> zde naleznete asi 20&nbsp;% revidovaného textu a asi 80&nbsp;% nového materiálu. Knihu považuji za dokončenou, ale <a href=#chapter-about>zpětná vazba je vždy vítána</a>.

<h2>Obsah (<a href=#chapter-table-of-contents>rozbalit</a>)</h2>

<p style="float:right;width:245px;text-align:center;margin:0 0 0 1.75em"><a href="http://knihy.nic.cz/"><em>K dispozici též v tištěné podobě!</em><br><img src="i/cover.png" alt="Ponořme se do Pythonu 3" /></a>

<!-- toc -->
<ol start=-1>
<li><a href=#chapter-whats-new>Co najdete v „Ponořme se do Pythonu 3“ nového</a>
<li><a href=#chapter-installing-python>Instalujeme Python</a>
<li><a href=#chapter-your-first-python-program>Váš první pythonovský program</a>
<li><a href=#chapter-native-datatypes>Přirozené datové typy</a>
<li><a href=#chapter-comprehensions>Generátorová notace</a>
<li><a href=#chapter-strings>Řetězce</a>
<li><a href=#chapter-regular-expressions>Regulární výrazy</a>
<li><a href=#chapter-generators>Uzávěry a generátory</a>
<li><a href=#chapter-iterators>Třídy a iterátory</a>
<li><a href=#chapter-advanced-iterators>Iterátory pro pokročilé</a>
<li><a href=#chapter-unit-testing>Unit Testing</a>
<li><a href=#chapter-refactoring>Refaktorizace</a>
<li><a href=#chapter-files>Soubory</a>
<li><a href=#chapter-xml>XML</a>
<li><a href=#chapter-serializing>Serializace pythonovských objektů</a>
<li><a href=#chapter-http-web-services>Webové služby nad HTTP</a>
<li><a href=#chapter-case-study-porting-chardet-to-python-3>Případová studie: Přepis <code>chardet</code> pro Python 3</a>
<li><a href=#chapter-packaging>Balení pythonovských knihoven</a>
<li id=index-a><a href=#chapter-porting-code-to-python-3-with-2to3>Přepis kódu do Python 3 s využitím <code>2to3</code></a>
<li id=index-b><a href=#chapter-special-method-names>Jména speciálních metod</a>
<li id=index-c><a href=#chapter-where-to-go-from-here>Čím pokračovat</a>
<li id=index-d><a href=#chapter-troubleshooting>Odstraňování problémů</a>
<li id=index-e><a href=#chapter-changelog>Seznam oprav a úprav</a>
</ol>
<!-- /toc -->

<p>Kniha je volně dostupná pod licencí <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution Share-Alike</a>.</p>

<p>Český překlad iniciovalo a financovalo sdružení <a href="http://knihy.nic.cz/page/351/o-sdruzeni/">CZ.NIC, z. s. p. o.</a>, které zajistilo rovněž sazbu a vydání v Edici CZ.NIC (<a href="http://knihy.nic.cz/">http://knihy.nic.cz/</a>). Kromě tištěné podoby zveřejnilo i odpovídající <a href="http://knihy.nic.cz/files/nic/edice/mark_pilgrim_dip3_ver3.pdf">PDF</a> (vzhled přebalu viz obrázek vpravo nahoře).

<p>Zprostředkování kontaktu s CZ.NIC, technickou podporu (překladatelský nástroj memoQ) a jazykovou korekturu zajistily <a href="http://www.ceskepreklady.cz/">České překlady s.r.o.</a>. První překlad realizoval Petr Přikryl. Znamenitou věcnou korekturu (vyplývající ze znalosti problematiky) provedl Jiří Znamenáček.

<p>HTML podobu, která kopíruje vzhled originálu, najdete na adrese <a href="http://diveintopython3.py.cz/">http://diveintopython3.py.cz/</a>. Pokud potřebujete v textu něco dohledat, může se vám hodit vygenerovaný <a href="http://diveintopython3.py.cz/PonormeSeDoPythonu3single.html">jediný (velký) HTML soubor se stejným obsahem</a>.  Z něj je vygenerována <a href="http://diveintopython3.py.cz/PonormeSeDoPythonu3.pdf">alternativní PDF podoba</a> (tj. alternativní k výše uvedené vysázené knize z produkce CZ.NIC), která byla vytvořena konvertorem HTML do PDF <a href="http://www.princexml.com/">Prince</a> (pro nekomerční použití zdarma). Pro lokální prohlížení si můžete stáhnout <a href="http://diveintopython3.py.cz/PonormeSeDoPythonu3-html.zip">aktuální verzi celé HTML podoby</a> (cca 1&nbsp;MB). Seznam posledních zásahů najdete v příloze <a href=#chapter-changelog>Seznam oprav a úprav</a>. Počítačoví maniaci si mohou naklonovat gitové úložiště:

<pre><samp class=p>you@localhost:~$ </samp><kbd>git clone <a href="https://github.com/pepr/diveintopython3cz">git://github.com/pepr/diveintopython3cz.git</a></kbd></pre>

<p>Poznámka: Mark Pilgrim, autor originálu, <em>spáchal informační sebevraždu</em>. To znamená, že způsobil nefunkčnost všech svých původních webových stránek a mailových adres (viz například <a href="https://en.wikipedia.org/wiki/Mark_Pilgrim_(software_developer)#.22Disappearance.22_from_the_Internet">informace na wikipedii</a>). Jeho dílo je ale dostupné na jiných místech. Odkazy v této knížce byly příslušným způsobem upraveny. Nedlouho před svým odstřižením založil gitové úložiště i pro originál této knihy. Můžete si je naklonovat:

<pre><samp class=p>you@localhost:~$ </samp><kbd>git clone <a href=https://github.com/diveintomark/diveintopython3>git://github.com/diveintomark/diveintopython3.git</a></kbd></pre>

</div>
<div id=chapter-table-of-contents>
<h1>Obsah</h1>
<!-- toc -->
<ol start=-1>
<li id=table-of-contents-whats-new><a href=#chapter-whats-new>Co najdete v „Ponořme se do Pythonu 3“ nového</a>
<ol>
<li><a href=#whats-new-divingin><i>aneb</i> „záporná úroveň”</a>
</ol>
<li id=table-of-contents-installing-python><a href=#chapter-installing-python>Instalujeme Python</a>
<ol>
<li><a href=#installing-python-divingin>Ponořme se</a>
<li><a href=#installing-python-which>Který Python je pro vás ten správný?</a>
<li><a href=#installing-python-windows>Instalace pod Microsoft Windows</a>
<li><a href=#installing-python-macosx>Instalace pod Mac OS X</a>
<li><a href=#installing-python-ubuntu>Instalace pod Ubuntu Linux</a>
<li><a href=#installing-python-other>Instalace na jiných platformách</a>
<li><a href=#installing-python-idle>Použití Python Shell</a>
<li><a href=#installing-python-editors>Editory a vývojová prostředí pro Python</a>
</ol>
<li id=table-of-contents-your-first-python-program><a href=#chapter-your-first-python-program>Váš první pythonovský program</a>
<ol>
<li><a href=#your-first-python-program-divingin>Ponořme se</a>
<li><a href=#your-first-python-program-declaringfunctions>Deklarace funkcí</a>
<ol>
<li><a href=#your-first-python-program-optional-arguments>Nepovinné a pojmenované argumenty</a>
</ol>
<li><a href=#your-first-python-program-readability>Psaní čitelného kódu</a>
<ol>
<li><a href=#your-first-python-program-docstrings>Dokumentační řetězce</a>
</ol>
<li><a href=#your-first-python-program-importsearchpath>Vyhledávací cesta pro <code>import</code></a>
<li><a href=#your-first-python-program-everythingisanobject>Všechno je objekt</a>
<ol>
<li><a href=#your-first-python-program-whatsanobject>Co to vlastně je objekt?</a>
</ol>
<li><a href=#your-first-python-program-indentingcode>Odsazování kódu</a>
<li><a href=#your-first-python-program-exceptions>Výjimky</a>
<ol>
<li><a href=#your-first-python-program-importerror>Obsluha chyb importu</a>
</ol>
<li><a href=#your-first-python-program-nameerror>Volné proměnné</a>
<li><a href=#your-first-python-program-case>Vše je citlivé na velikost písmen</a>
<li><a href=#your-first-python-program-runningscripts>Spouštění skriptů</a>
<li><a href=#your-first-python-program-furtherreading>Přečtěte si</a>
</ol>
<li id=table-of-contents-native-datatypes><a href=#chapter-native-datatypes>Přirozené datové typy</a>
<ol>
<li><a href=#native-datatypes-divingin>Ponořme se</a>
<li><a href=#native-datatypes-booleans>Booleovský typ</a>
<li><a href=#native-datatypes-numbers>Čísla</a>
<ol>
<li><a href=#native-datatypes-number-coercion>Vynucení převodu celých čísel na reálná a naopak</a>
<li><a href=#native-datatypes-common-numerical-operations>Běžné operace s čísly</a>
<li><a href=#native-datatypes-fractions>Zlomky</a>
<li><a href=#native-datatypes-trig>Trigonometrie</a>
<li><a href=#native-datatypes-numbers-in-a-boolean-context>Čísla v booleovském kontextu</a>
</ol>
<li><a href=#native-datatypes-lists>Seznamy</a>
<ol>
<li><a href=#native-datatypes-creatinglists>Vytvoření seznamu</a>
<li><a href=#native-datatypes-slicinglists>Vytváření podseznamů</a>
<li><a href=#native-datatypes-extendinglists>Přidávání položek do seznamu</a>
<li><a href=#native-datatypes-searchinglists>Vyhledávání hodnoty v seznamu</a>
<li><a href=#native-datatypes-removingfromlists>Odstraňování položek ze seznamu</a>
<li><a href=#native-datatypes-popgoestheweasel>Odstraňování položek ze seznamu: Bonusové kolo</a>
<li><a href=#native-datatypes-lists-in-a-boolean-context>Seznamy v booleovském kontextu</a>
</ol>
<li><a href=#native-datatypes-tuples>N-tice</a>
<ol>
<li><a href=#native-datatypes-tuples-in-a-boolean-context>N-tice v booleovském kontextu</a>
<li><a href=#native-datatypes-multivar>Přiřazení více hodnot najednou</a>
</ol>
<li><a href=#native-datatypes-sets>Množiny</a>
<ol>
<li><a href=#native-datatypes-creating-a-set>Vytvoření množiny</a>
<li><a href=#native-datatypes-modifying-sets>Úprava množiny</a>
<li><a href=#native-datatypes-removing-from-sets>Odstraňování položek z množiny</a>
<li><a href=#native-datatypes-common-set-operations>Běžné množinové operace</a>
<li><a href=#native-datatypes-sets-in-a-boolean-context>Množiny v booleovském kontextu</a>
</ol>
<li><a href=#native-datatypes-dictionaries>Slovníky</a>
<ol>
<li><a href=#native-datatypes-creating-dictionaries>Vytvoření slovníku</a>
<li><a href=#native-datatypes-modifying-dictionaries>Úprava slovníku</a>
<li><a href=#native-datatypes-mixed-value-dictionaries>Slovníky se smíšeným obsahem</a>
<li><a href=#native-datatypes-dictionaries-in-a-boolean-context>Slovníky v booleovském kontextu</a>
</ol>
<li><a href=#native-datatypes-none><code>None</code></a>
<ol>
<li><a href=#native-datatypes-none-in-a-boolean-context><code>None</code> v booleovském kontextu</a>
</ol>
<li><a href=#native-datatypes-furtherreading>Přečtěte si</a>
</ol>
<li id=table-of-contents-comprehensions><a href=#chapter-comprehensions>Generátorová notace</a>
<ol>
<li><a href=#comprehensions-divingin>Ponořme se</a>
<li><a href=#comprehensions-os>Práce se soubory a s adresáři</a>
<ol>
<li><a href=#comprehensions-getcwd>Aktuální pracovní adresář</a>
<li><a href=#comprehensions-ospath>Práce se jmény souborů a adresářů</a>
<li><a href=#comprehensions-glob>Výpis adresářů</a>
<li><a href=#comprehensions-osstat>Získání dalších informací o souboru</a>
<li><a href=#comprehensions-abspath>Jak vytvořit absolutní cesty</a>
</ol>
<li><a href=#comprehensions-listcomprehension>Generátorová notace seznamu</a>
<li><a href=#comprehensions-dictionarycomprehension>Generátorová notace slovníku</a>
<ol>
<li><a href=#comprehensions-stupiddicttricks>Další legrácky s generátorovou notací slovníků</a>
</ol>
<li><a href=#comprehensions-setcomprehension>Generátorová notace množin</a>
<li><a href=#comprehensions-furtherreading>Přečtěte si</a>
</ol>
<li id=table-of-contents-strings><a href=#chapter-strings>Řetězce</a>
<ol>
<li><a href=#strings-boring-stuff>Pár nudných věcí, kterým musíme rozumět dříve, než se budeme moci ponořit</a>
<li><a href=#strings-one-ring-to-rule-them-all>Unicode</a>
<li><a href=#strings-divingin>Ponořme se</a>
<li><a href=#strings-formatting-strings>Formátovací řetězce</a>
<ol>
<li><a href=#strings-compound-field-names>Složená jména oblastí</a>
<li><a href=#strings-format-specifiers>Specifikátory formátu</a>
</ol>
<li><a href=#strings-common-string-methods>Další běžné metody řetězců</a>
<ol>
<li><a href=#strings-slicingstrings>Vykrajování podřetězců</a>
</ol>
<li><a href=#strings-byte-arrays>Řetězce vs. bajty</a>
<li><a href=#strings-py-encoding>Závěrečná poznámka: Kódování znaků v pythonovském zdrojovém textu</a>
<li><a href=#strings-furtherreading>Přečtěte si</a>
</ol>
<li id=table-of-contents-regular-expressions><a href=#chapter-regular-expressions>Regulární výrazy</a>
<ol>
<li><a href=#regular-expressions-divingin>Ponořme se</a>
<li><a href=#regular-expressions-streetaddresses>Případová studie: Adresa ulice</a>
<li><a href=#regular-expressions-romannumerals>Případová studie: Římská čísla</a>
<ol>
<li><a href=#regular-expressions-thousands>Kontrola tisícovek</a>
<li><a href=#regular-expressions-hundreds>Kontrola stovek</a>
</ol>
<li><a href=#regular-expressions-nmsyntax>Využití syntaxe <code>{n,m}</code></a>
<ol>
<li><a href=#regular-expressions-tensandones>Kontrola desítek a jednotek</a>
</ol>
<li><a href=#regular-expressions-verbosere>Víceslovné regulární výrazy</a>
<li><a href=#regular-expressions-phonenumbers>Případová studie: Analýza telefonních čísel</a>
<li><a href=#regular-expressions-summary>Shrnutí</a>
</ol>
<li id=table-of-contents-generators><a href=#chapter-generators>Uzávěry a generátory</a>
<ol>
<li><a href=#generators-divingin>Ponořme se</a>
<li><a href=#generators-i-know>Já vím jak na to! Použijeme regulární výrazy!</a>
<li><a href=#generators-a-list-of-functions>Seznam funkcí</a>
<li><a href=#generators-a-list-of-patterns>Seznam vzorků</a>
<li><a href=#generators-a-file-of-patterns>Soubor vzorků</a>
<li><a href=#generators-generators>Generátory</a>
<ol>
<li><a href=#generators-a-fibonacci-generator>Generátor Fibonacciho posloupnosti</a>
<li><a href=#generators-a-plural-rule-generator>Generátor pravidel pro množné číslo</a>
</ol>
<li><a href=#generators-furtherreading>Přečtěte si</a>
</ol>
<li id=table-of-contents-iterators><a href=#chapter-iterators>Třídy a iterátory</a>
<ol>
<li><a href=#iterators-divingin>Ponořme se</a>
<li><a href=#iterators-defining-classes>Definice tříd</a>
<ol>
<li><a href=#iterators-init-method>Metoda <code>__init__()</code></a>
</ol>
<li><a href=#iterators-instantiating-classes>Vytváření instancí tříd</a>
<li><a href=#iterators-instance-variables>Členské proměnné</a>
<li><a href=#iterators-a-fibonacci-iterator>Fibonacciho iterátor</a>
<li><a href=#iterators-a-plural-rule-iterator>Iterátor pro pravidla množného čísla</a>
<li><a href=#iterators-furtherreading>Přečtěte si</a>
</ol>
<li id=table-of-contents-advanced-iterators><a href=#chapter-advanced-iterators>Iterátory pro pokročilé</a>
<ol>
<li><a href=#advanced-iterators-divingin>Ponořme se</a>
<li><a href=#advanced-iterators-re-findall>Nalezení všech výskytů vzorku</a>
<li><a href=#advanced-iterators-unique-items>Nalezení jedinečných prvků posloupnosti</a>
<li><a href=#advanced-iterators-assert>Činíme předpoklady</a>
<li><a href=#advanced-iterators-generator-expressions>Generátorové výrazy</a>
<li><a href=#advanced-iterators-permutations>Výpočet permutací (pro lenochy)</a>
<li><a href=#advanced-iterators-more-itertools>Další legrácky v modulu <code>itertools</code></a>
<li><a href=#advanced-iterators-string-translate>Nový způsob úpravy řetězce</a>
<li><a href=#advanced-iterators-eval>Vyhodnocování libovolných řetězců zachycujících pythonovské výrazy</a>
<li><a href=#advanced-iterators-alphametics-finale>Spojme to všechno dohromady</a>
<li><a href=#advanced-iterators-furtherreading>Přečtěte si</a>
</ol>
<li id=table-of-contents-unit-testing><a href=#chapter-unit-testing>Unit Testing</a>
<ol>
<li><a href=#unit-testing-divingin>(Ne)ponořme se</a>
<li><a href=#unit-testing-romantest1>Jediná otázka</a>
<li><a href=#unit-testing-romantest2>„Zastav a začni hořet“</a>
<li><a href=#unit-testing-romantest3>Více zastávek, více ohně</a>
<li><a href=#unit-testing-romantest4>A ještě jedna věc...</a>
<li><a href=#unit-testing-romantest5>Symetrie, která potěší</a>
<li><a href=#unit-testing-romantest6>Více špatných vstupů</a>
</ol>
<li id=table-of-contents-refactoring><a href=#chapter-refactoring>Refaktorizace</a>
<ol>
<li><a href=#refactoring-divingin>Ponořme se</a>
<li><a href=#refactoring-changing-requirements>Zvládání měnících se požadavků</a>
<li><a href=#refactoring-refactoring>Refaktorizace</a>
<li><a href=#refactoring-summary>Shrnutí</a>
</ol>
<li id=table-of-contents-files><a href=#chapter-files>Soubory</a>
<ol>
<li><a href=#files-divingin>Ponořme se</a>
<li><a href=#files-reading>Čtení z textových souborů</a>
<ol>
<li><a href=#files-encoding>Kódování znaků vystrkuje svou ošklivou hlavu</a>
<li><a href=#files-file-objects>Objekty typu stream</a>
<li><a href=#files-read>Čtení dat z textového souboru</a>
<li><a href=#files-close>Zavírání souborů</a>
<li><a href=#files-with>Automatické zavírání souborů</a>
<li><a href=#files-for>Čtení dat po řádcích</a>
</ol>
<li><a href=#files-writing>Zápis do textových souborů</a>
<ol>
<li><a href=#files-encoding-again>A znovu kódování znaků</a>
</ol>
<li><a href=#files-binary>Binární soubory</a>
<li><a href=#files-file-like-objects>Objekty typu stream z nesouborových zdrojů</a>
<ol>
<li><a href=#files-gzip>Práce s komprimovanými soubory</a>
</ol>
<li><a href=#files-stdio>Standardní vstup, výstup a chybový výstup</a>
<ol>
<li><a href=#files-redirect>Přesměrování standardního výstupu</a>
</ol>
<li><a href=#files-furtherreading>Přečtěte si</a>
</ol>
<li id=table-of-contents-xml><a href=#chapter-xml>XML</a>
<ol>
<li><a href=#xml-divingin>Ponořme se</a>
<li><a href=#xml-xml-intro>Pětiminutový rychlokurz XML</a>
<li><a href=#xml-xml-structure>Struktura Atom Feed</a>
<li><a href=#xml-xml-parse>Analýza XML</a>
<ol>
<li><a href=#xml-xml-elements>Elementy jsou reprezentovány seznamy</a>
<li><a href=#xml-xml-attributes>Atributy jsou reprezentovány slovníky</a>
</ol>
<li><a href=#xml-xml-find>Vyhledávání uzlů v XML dokumentu</a>
<li><a href=#xml-xml-lxml>lxml jde ještě dál</a>
<li><a href=#xml-xml-generate>Generování XML</a>
<li><a href=#xml-xml-custom-parser>Analýza porušeného XML</a>
<li><a href=#xml-furtherreading>Přečtěte si</a>
</ol>
<li id=table-of-contents-serializing><a href=#chapter-serializing>Serializace pythonovských objektů</a>
<ol>
<li><a href=#serializing-divingin>Ponořme se</a>
<ol>
<li><a href=#serializing-administrivia>Stručná poznámka k příkladům v této kapitole</a>
</ol>
<li><a href=#serializing-dump>Uložení dat do „pickle souboru“</a>
<li><a href=#serializing-load>Načítání dat z „pickle souboru“</a>
<li><a href=#serializing-dumps>„Piklení“ bez souboru</a>
<li><a href=#serializing-protocol-versions>Bajty a řetězce znovu zvedají své ošklivé hlavy</a>
<li><a href=#serializing-debugging>Ladění „pickle souborů“</a>
<li><a href=#serializing-json>Serializace pythonovských objektů pro čtení z jiných jazyků</a>
<li><a href=#serializing-json-dump>Uložení dat do <abbr>JSON</abbr> souboru</a>
<li><a href=#serializing-json-types>Zobrazení pythonovských datových typů do <abbr>JSON</abbr></a>
<li><a href=#serializing-json-unknown-types>Serializace datových typů, které <abbr>JSON</abbr> nepodporuje</a>
<li><a href=#serializing-json-load>Načítání dat z <abbr>JSON</abbr> souboru</a>
<li><a href=#serializing-furtherreading>Přečtěte si</a>
</ol>
<li id=table-of-contents-http-web-services><a href=#chapter-http-web-services>Webové služby nad HTTP</a>
<ol>
<li><a href=#http-web-services-divingin>Ponořme se</a>
<li><a href=#http-web-services-http-features>Vlastnosti HTTP</a>
<ol>
<li><a href=#http-web-services-caching>Používání mezipaměti</a>
<li><a href=#http-web-services-last-modified>Kontrola <code>Last-Modified</code></a>
<li><a href=#http-web-services-etags>Kontrola <code>ETag</code></a>
<li><a href=#http-web-services-compression>Komprese</a>
<li><a href=#http-web-services-redirects>Přesměrování</a>
</ol>
<li><a href=#http-web-services-dont-try-this-at-home>Jak se nedostat k datům přes HTTP</a>
<li><a href=#http-web-services-whats-on-the-wire>Co že to máme na drátě?</a>
<li><a href=#http-web-services-introducing-httplib2>Představujeme <code>httplib2</code></a>
<ol>
<li><a href=#http-web-services-why-bytes>Krátká odbočka vysvětlující, proč <code>httplib2</code> vrací bajty místo řetězců</a>
<li><a href=#http-web-services-httplib2-caching>Jak <code>httplib2</code> zachází s mezipamětí</a>
<li><a href=#http-web-services-httplib2-etags>Jak <code>httplib2</code> zachází s hlavičkami <code>Last-Modified</code> a <code>ETag</code></a>
<li><a href=#http-web-services-httplib2-compression>Jak <code>http2lib</code> pracuje s kompresí</a>
<li><a href=#http-web-services-httplib2-redirects>Jak <code>httplib2</code> řeší přesměrování</a>
</ol>
<li><a href=#http-web-services-beyond-get>Za hranicemi HTTP GET</a>
<li><a href=#http-web-services-beyond-post>Za hranicemi HTTP POST</a>
<li><a href=#http-web-services-furtherreading>Přečtěte si</a>
</ol>
<li id=table-of-contents-case-study-porting-chardet-to-python-3><a href=#chapter-case-study-porting-chardet-to-python-3>Případová studie: Přepis <code>chardet</code> pro Python 3</a>
<ol>
<li><a href=#case-study-porting-chardet-to-python-3-divingin>Ponořme se</a>
<li><a href=#case-study-porting-chardet-to-python-3-faq.what>Co se rozumí autodetekcí znakového kódování?</a>
<ol>
<li><a href=#case-study-porting-chardet-to-python-3-faq.impossible>Není to náhodou neproveditelné?</a>
<li><a href=#case-study-porting-chardet-to-python-3-faq.who>Existuje takový algoritmus?</a>
</ol>
<li><a href=#case-study-porting-chardet-to-python-3-divingin2>Úvod do modulu <code>chardet</code></a>
<ol>
<li><a href=#case-study-porting-chardet-to-python-3-how.bom><abbr>UTF-n</abbr> s <abbr>BOM</abbr></a>
<li><a href=#case-study-porting-chardet-to-python-3-how.esc>Kódování escape sekvencemi</a>
<li><a href=#case-study-porting-chardet-to-python-3-how.mb>Vícebajtová kódování</a>
<li><a href=#case-study-porting-chardet-to-python-3-how.sb>Jednobajtová kódování</a>
<li><a href=#case-study-porting-chardet-to-python-3-how.windows1252><code>windows-1252</code></a>
</ol>
<li><a href=#case-study-porting-chardet-to-python-3-running2to3>Spouštíme <code>2to3</code></a>
<li><a href=#case-study-porting-chardet-to-python-3-multifile-modules>Krátká odbočka k vícesouborovým modulům</a>
<li><a href=#case-study-porting-chardet-to-python-3-manual>Opravme, co <code>2to3</code> neumí</a>
<ol>
<li><a href=#case-study-porting-chardet-to-python-3-falseisinvalidsyntax><code>False</code> je syntaktická chyba</a>
<li><a href=#case-study-porting-chardet-to-python-3-nomodulenamedconstants>Nenalezen modul <code>constants</code></a>
<li><a href=#case-study-porting-chardet-to-python-3-namefileisnotdefined>Jméno <var>'file'</var> není definováno</a>
<li><a href=#case-study-porting-chardet-to-python-3-cantuseastringpattern>Řetězcový vzorek nelze použít pro bajtové objekty</a>
<li><a href=#case-study-porting-chardet-to-python-3-cantconvertbytesobject>Objekt typu <code>'bytes'</code> nelze implicitně převést na <code>str</code></a>
<li><a href=#case-study-porting-chardet-to-python-3-unsupportedoperandtypeforplus>Nepodporované typy operandů pro +: <code>'int'</code> a <code>'bytes'</code></a>
<li><a href=#case-study-porting-chardet-to-python-3-ordexpectedstring>funkce <code>ord()</code> očekávala řetězec o délce 1, ale byl nalezen <code>int</code></a>
<li><a href=#case-study-porting-chardet-to-python-3-unorderabletypes>Neuspořádatelné datové typy: <code>int()</code> &gt;= <code>str()</code></a>
<li><a href=#case-study-porting-chardet-to-python-3-reduceisnotdefined>Globální jméno <code>'reduce'</code> není definováno</a>
</ol>
<li><a href=#case-study-porting-chardet-to-python-3-summary>Shrnutí</a>
</ol>
<li id=table-of-contents-packaging><a href=#chapter-packaging>Balení pythonovských knihoven</a>
<ol>
<li><a href=#packaging-divingin>Ponořme se</a>
<li><a href=#packaging-cantdo>Věci, které za nás Distutils neudělají</a>
<li><a href=#packaging-structure>Struktura adresáře</a>
<li><a href=#packaging-setuppy>Píšeme svůj instalační skript</a>
<li><a href=#packaging-trove>Přidáváme klasifikaci našeho balíčku</a>
<ol>
<li><a href=#packaging-trove-examples>Příklady dobrých klasifikátorů balíčků</a>
</ol>
<li><a href=#packaging-manifest>Určení dalších souborů prostřednictvím manifestu</a>
<li><a href=#packaging-check>Kontrola chyb v našem instalačním skriptu</a>
<li><a href=#packaging-sdist>Vytvoření distribuce obsahující zdrojové texty</a>
<li><a href=#packaging-bdist>Vytvoření grafického instalačního programu</a>
<ol>
<li><a href=#packaging-linux>Tvorba instalačních balíčků pro jiné operační systémy</a>
</ol>
<li><a href=#packaging-pypi>Přidání našeho softwaru do Python Package Index</a>
<li><a href=#packaging-future>Více možných budoucností balení pythonovských produktů</a>
<li><a href=#packaging-furtherreading>Přečtěte si</a>
</ol>
<li id=table-of-contents-porting-code-to-python-3-with-2to3><a href=#chapter-porting-code-to-python-3-with-2to3>Přepis kódu do Pythonu 3 s využitím <code>2to3</code></a>
<ol>
<li><a href=#porting-code-to-python-3-with-2to3-divingin>Ponořme se</a>
<li><a href=#porting-code-to-python-3-with-2to3-print>Příkaz <code>print</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-unicodeliteral>Literály Unicode řetězců</a>
<li><a href=#porting-code-to-python-3-with-2to3-unicode>Globální funkce <code>unicode()</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-long>Datový typ <code>long</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-ne>Porovnání &lt;&gt;</a>
<li><a href=#porting-code-to-python-3-with-2to3-has_key>Slovníková metoda <code>has_key()</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-dict>Slovníkové metody, které vracejí seznamy</a>
<li><a href=#porting-code-to-python-3-with-2to3-imports>Moduly, které byly přejmenovány nebo reorganizovány</a>
<ol>
<li><a href=#porting-code-to-python-3-with-2to3-http><code>http</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-urllib><code>urllib</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-dbm><code>dbm</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-xmlrpc><code>xmlrpc</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-othermodules>Ostatní moduly</a>
</ol>
<li><a href=#porting-code-to-python-3-with-2to3-import>Relativní importy uvnitř balíčku</a>
<li><a href=#porting-code-to-python-3-with-2to3-next>Metoda iterátoru <code>next()</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-filter>Globální funkce <code>filter()</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-map>Globální funkce <code>map()</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-reduce>Globální funkce <code>reduce()</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-apply>Globální funkce <code>apply()</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-intern>Globální funkce <code>intern()</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-exec>Příkaz <code>exec</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-execfile>Příkaz <code>execfile</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-repr><code>repr</code> literály (zpětné apostrofy)</a>
<li><a href=#porting-code-to-python-3-with-2to3-except>Příkaz <code>try...except</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-raise>Příkaz <code>raise</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-throw>Metoda generátorů <code>throw</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-xrange>Globální funkce <code>xrange()</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-raw_input>Globální funkce <code>raw_input()</code> a <code>input()</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-funcattrs>Atributy funkcí <code>func_*</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-xreadlines>Metoda <code>xreadlines()</code> V/V objektů</a>
<li><a href=#porting-code-to-python-3-with-2to3-tuple_params><code>lambda</code> funkce, které akceptují n-tici místo více parametrů</a>
<li><a href=#porting-code-to-python-3-with-2to3-methodattrs>Atributy speciálních metod</a>
<li><a href=#porting-code-to-python-3-with-2to3-nonzero>Speciální metoda <code>__nonzero__</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-numliterals>Oktalové literály</a>
<li><a href=#porting-code-to-python-3-with-2to3-renames><code>sys.maxint</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-callable>Globální funkce <code>callable()</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-zip>Globální funkce <code>zip()</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-standarderror>Výjimka <code>StandardError</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-types>Konstanty modulu <code>types</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-isinstance>Globální funkce <code>isinstance()</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-basestring>Datový typ <code>basestring</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-itertools>Modul <code>itertools</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-sys_exc><code>sys.exc_type</code>, <code>sys.exc_value</code>, <code>sys.exc_traceback</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-paren>Generátory seznamů nad n-ticemi</a>
<li><a href=#porting-code-to-python-3-with-2to3-getcwdu>Funkce <code>os.getcwdu()</code></a>
<li><a href=#porting-code-to-python-3-with-2to3-metaclass>Metatřídy</a>
<li><a href=#porting-code-to-python-3-with-2to3-nitpick>Věci týkající se stylu</a>
<ol>
<li><a href=#porting-code-to-python-3-with-2to3-set_literal>Množinové literály (<code>set()</code>; explicitně)</a>
<li><a href=#porting-code-to-python-3-with-2to3-buffer>Globální funkce <code>buffer()</code> (explicitně)</a>
<li><a href=#porting-code-to-python-3-with-2to3-wscomma>Bílé znaky kolem čárek (explicitně)</a>
<li><a href=#porting-code-to-python-3-with-2to3-idioms>Běžné obraty (explicitně)</a>
</ol>
</ol>
<li id=table-of-contents-special-method-names><a href=#chapter-special-method-names>Jména speciálních metod</a>
<ol>
<li><a href=#special-method-names-divingin>Ponořme se</a>
<li><a href=#special-method-names-basics>Základy</a>
<li><a href=#special-method-names-acts-like-iterator>Třídy, které se chovají jako iterátory</a>
<li><a href=#special-method-names-computed-attributes>Vypočítávané atributy</a>
<li><a href=#special-method-names-acts-like-function>Třídy, které se chovají jako funkce</a>
<li><a href=#special-method-names-acts-like-set>Třídy, které se chovají jako množiny</a>
<li><a href=#special-method-names-acts-like-dict>Třídy, které se chovají jako slovníky</a>
<li><a href=#special-method-names-acts-like-number>Třídy, které se chovají jako čísla</a>
<li><a href=#special-method-names-rich-comparisons>Třídy, které se dají porovnávat</a>
<li><a href=#special-method-names-pickle>Třídy, které podporují serializaci</a>
<li><a href=#special-method-names-context-managers>Třídy, které mohou být použity v bloku <code>with</code></a>
<li><a href=#special-method-names-esoterica>Opravdu esoterické věci</a>
<li><a href=#special-method-names-furtherreading>Přečtěte si</a>
</ol>
<li id=table-of-contents-where-to-go-from-here><a href=#chapter-where-to-go-from-here>Čím pokračovat</a>
<ol>
<li><a href=#where-to-go-from-here-things-to-read>Doporučuji k přečtení</a>
<li><a href=#where-to-go-from-here-code>Kde hledat kód kompatibilní s Pythonem 3</a>
</ol>
<li id=table-of-contents-troubleshooting><a href=#chapter-troubleshooting>Odstraňování problémů</a>
<ol>
<li><a href=#troubleshooting-divingin>Ponořme se</a>
<li><a href=#troubleshooting-getting-to-the-command-line>Jak se dostat k příkazovému řádku</a>
<li><a href=#troubleshooting-running-python-on-the-command-line>Spuštění Pythonu z příkazového řádku</a>
</ol>
<li id=table-of-contents-changelog><a href=#chapter-changelog>Seznam oprav a úprav</a>
</ol>
<!-- /toc -->
</div>
<div id=chapter-whats-new>
<h1>Co najdete v „Ponořme se do Pythonu 3“ nového</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> Isn’t this where we came in? <span class="u">&#x275E;</span><br>&mdash; Pink Floyd, The Wall
</blockquote>
<p>&nbsp;
<h2 id=whats-new-divingin><i>aneb</i> „záporná úroveň“</h2>

<p class=f>Už jste v jazyce Python programovali? Četli jste původní publikaci „<a href="http://www.diveintopython.net/" title="Původní odkaz http://diveintopython.org/ opraven.">Dive Into Python</a>“? Koupili jste si ji v knižní podobě? (Pokud ano, díky!) Jste připraveni ponořit se do jazyka Python 3?... Pokud tomu tak je, čtěte dál. (Pokud nic z toho neplatí, měli byste raději <a href=#chapter-installing-python>začít od začátku</a>.)

<p>Python 3 se dodává se skriptem nazvaným <code>2to3</code>. Naučte se jej. Milujte jej. Používejte jej. <a href=#chapter-porting-code-to-python-3-with-2to3>Přepis kódu do Pythonu 3 s využitím <code>2to3</code></a> je referenční příručkou ke všem věcem, které skript <code>2to3</code> umí opravit automaticky. A protože řada těchto věcí souvisí se změnami syntaxe, je tato příručka dobrým výchozím bodem ke studiu syntaktických změn, které Python 3 přináší. (Z příkazu <code>print</code> se stala funkce, obrat <code>`x`</code> přestal fungovat atd.)

<p><a href=#chapter-case-study-porting-chardet-to-python-3>Případová studie: Přepis <code>chardet</code> pro Python 3</a> popisuje mé (nakonec úspěšné) úsilí o přepis netriviální knihovny z Pythonu 2 do Pythonu 3. Možná vám tato studie pomůže, možná ne. Učící křivka je zde poměrně strmá, protože nejdříve musíte porozumět knihovně samotné. Teprve potom můžete rozumět tomu, proč přestala fungovat a jakým způsobem jsem ji opravil. Řada problémů se váže na řetězce. Když už o nich mluvíme&hellip;

<p>Řetězce. Uffff. Kde mám začít? Python 2 používal „řetězce“ a „řetězce v Unicode“. Python 3 rozlišuje „bajty“ a „řetězce“. Všechny řetězce se nyní stávají řetězci v Unicode. Pokud s obsahem chceme zacházet jako s bajty, musíme použít nový datový typ nazvaný <code>bytes</code>. Python 3 <em>nikdy</em> skrytě nepřevádí řetězce na bajty a naopak. Takže pokud si v každém momentě nejste jistí, zda používáte ten či onen typ, kód vašeho programu téměř jistě přestane fungovat. Další podrobnosti naleznete v kapitole <a href=#chapter-strings>Řetězce</a>.

<p>Problém bajty versus řetězce se v textu této knihy vynořuje znovu a znovu.

<ul>
<li>V kapitole <a href=#chapter-files>Soubory</a> se seznámíte s rozdílem mezi čtením souborů v „binárním“ a „textovém“ režimu. Při čtení (ale také při zápisu) souborů v textovém režimu se vyžaduje zadání parametru určujícího kódování (<code>encoding</code>). Některé metody textových souborů počítají znaky, ale jiné metody zase počítají bajty. Pokud ve svém zdrojovém kódu předpokládáte, že se jeden znak rovná jednomu bajtu, pak to při přechodu na vícebajtové znaky <em>přestane fungovat</em>.
<li>V kapitole <a href=#chapter-http-web-services>Webové služby nad <abbr>HTTP</abbr></a> čte modul <code>httplib2</code> hlavičky a data prostřednictvím protokolu <abbr>HTTP</abbr>. Hlavičky se vracejí v podobě řetězců, ale těla se vracejí jako bajty.
<li>V kapitole <a href=#chapter-serializing>Serializace pythonovských objektů</a> se naučíte, proč modul <code>pickle</code> pro Python 3 definuje nový datový formát, který je zpětně nekompatibilní s verzí pro Python 2. (Nápověda: Důvodem jsou bajty a řetězce.) Python 3 podporuje také serializaci objektů do a z <abbr>JSON</abbr>, který dokonce nepracuje s typem <code>bytes</code>. Ukážeme si, jak se to dá obejít.
<li>V části <a href=#chapter-case-study-porting-chardet-to-python-3>Případová studie: Přepis <code>chardet</code> pro Python 3</a> se setkáte se zatraceným zmatkem mezi bajty a řetězci úplně všude.
</ul>

<p>Dokonce i kdyby vás Unicode nechával úplně chladné (ale ne, nenechá), budete si určitě chtít něco přečíst o <a href=#strings-formatting-strings>formátování řetězců v jazyce Python 3</a>. Zcela se liší od předpisu formátování řetězců v jazyce Python 2.

<p>S iterátory se v Pythonu 3 setkáte všude. A teď už jim rozumím mnohem víc, než tomu bylo před pěti lety, kdy jsem napsal „Dive Into Python“. Snažte se jim porozumět také, protože mnoho funkcí, které v jazyce Python 2 vracely seznamy, vrací v Pythonu 3 právě iterátory. Přinejmenším byste si měli přečíst <a href=#iterators-a-fibonacci-iterator>druhou polovinu kapitoly Iterátory</a> a <a href=#advanced-iterators-generator-expressions>druhou polovinu kapitoly Iterátory pro pokročilé</a>.

<p>Na přání čtenářů jsem přidal přílohu <a href=#chapter-special-method-names>Jména speciálních metod</a>, která se podobá kapitole <a href="http://www.python.org/doc/3.1/reference/datamodel.html#special-method-names">Data Model</a> (Datový model) uvedené v dokumentaci jazyka Python.

<p>V době, kdy jsem psal „Dive Into Python“, měly všechny dostupné knihovny pro práci s XML mizernou kvalitu. Pak ale Fredrik Lundh napsal modul <a href="http://effbot.org/zone/element-index.htm">ElementTree</a>, který není <em>ale vůbec</em> mizerný. Pythonovští bohové moudře <a href="http://docs.python.org/3.1/library/xml.etree.elementtree.html">začlenili ElementTree do standardní knihovny</a>, a tak se tento modul stal základem <a href=#chapter-xml>mé nové kapitoly o XML</a>. Starší způsoby zpracování XML jsou stále podporované, ale měli byste se jim vyhnout, protože jsou zkrátka mizerné!

<p>V Pythonu je nové také to&nbsp;&mdash;&nbsp;ne v jazyce, ale v komunitě uživatelů&nbsp;&mdash;, že se objevila úložiště kódu, jako je <a href="http://pypi.python.org/">Python Package Index</a> (PyPI). Python se dodává s utilitami k zabalení vašeho kódu do standardního formátu a tyto balíčky pak mohou být zveřejněny na PyPI. O podrobnostech se dočtete v kapitole <a href=#chapter-packaging>Balení pythonovských knihoven</a>.

</div>
<div id=chapter-installing-python>
<h1>Instalujeme Python</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> <i lang="la">Tempora mutantur nos et mutamur in illis.</i> <span class="u">&#x275E;</span><br>(Časy se mění a my se měníme s nimi.)<br>&mdash; přísloví ze starého Říma
</blockquote>
<p>&nbsp;
<h2 id=installing-python-divingin>Ponořme se</h2>
<p class=f>Než začneme programovat v jazyce Python 3, musíme si jej nainstalovat. Nebo ne?

<h2 id=installing-python-which>Který Python je pro vás ten správný?</h2>

<p>Pokud používáte účet na hostovaném serveru, mohl být Python 3 již nainstalován jeho správcem. Pokud provozujete Linux doma, můžete mít Python 3 již také k dispozici. Nejpopulárnější distribuce systému GNU/Linux obsahují v základní instalaci Python 2. Malá, ale zvětšující se skupina distribucí obsahuje také Python 3. Mac OS X se dodává s Pythonem 2 (verze spouštěná přes příkazový řádek), ale v době psaní této knihy neobsahoval Python 3. Microsoft Windows se nedodává s žádnou verzí Pythonu. Ale nepropadejte zoufalství! Nezávisle na tom, jaký operační systém používáte, můžete Python nainstalovat na několik kliknutí.

<p>Nejjednodušší způsob ověření si, zda máte k dispozici Python 3 na svém systému Linux nebo Mac OS X, začíná tím, že se dostanete <a href=#troubleshooting-getting-to-the-command-line>na příkazový řádek</a>. Jakmile se nacházíte za vyzývacím řetězcem příkazového řádku, napište jednoduše <kbd>python3</kbd> (vše malými písmeny, bez mezer), stiskněte <kbd>ENTER</kbd> a uvidíte, co se stane. Na svém domácím systému Linux už mám Python 3.1 nainstalovaný. Uvedeným příkazem vstoupím do <i>pythonovského <dfn>interaktivního shellu</dfn></i>.

<pre class='nd screen cmdline'>
<samp class=p>mark@atlantis:~$ </samp><kbd>python3</kbd>
<samp>Python 3.1 (r31:73572, Jul 28 2009, 06:52:23)
[GCC 4.2.4 (Ubuntu 4.2.4-1ubuntu4)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>></samp></pre>

<p>(Až budete chtít pythonovský interaktivní shell opustit, napište <kbd>exit()</kbd> a stiskněte <kbd>ENTER</kbd>.)

<p>Můj <a href="http://cornerhost.com/">poskytovatel webového prostoru</a> používá také Linux a umožňuje přístup přes příkazový řádek, ale Python 3 není na serveru nainstalován. (Béééé!)

<pre class='nd screen cmdline'>
<samp class=p>mark@manganese:~$ </samp><kbd>python3</kbd>
<samp>bash: python3: command not found</samp></pre>

<p>Takže zpět k otázce, kterou jsme tuto podkapitolu zahájili: „Který Python je pro vás ten správný?“ Ten, který poběží na počítači, který máte k dispozici.

<p>[Následuje návod pro instalaci pod Windows, nebo přeskočte na <a href=#installing-python-macosx>Instalace pod Mac OS X</a>, <a href=#installing-python-ubuntu>Instalace pod Ubuntu Linux</a> nebo <a href=#installing-python-other>Instalace na jiných platformách</a>.]

<p class=a>&#x2042;

<h2 id=installing-python-windows>Instalace pod Microsoft Windows</h2>

<p>V dnešní době se Windows dodávají ve dvou architekturách: 32bitové a 64bitové. Máme tu samozřejmě řadu různých <i>verzí</i> Windows&nbsp;&mdash;&nbsp;XP, Vista, Windows 7&nbsp;&mdash;, ale Python běží na všech. Rozlišení mezi 32bitovou a 64bitovou architekturou je důležitější. Pokud nemáte vůbec tušení, jakou architekturu používáte, pak je to pravděpodobně 32bitová.

<p>Přejděte na stránku <a href="http://python.org/download/"><code>python.org/download/</code></a> a stáhněte si windowsovský instalátor Python 3, který se hodí pro vaši architekturu. Možnosti vaší volby budou vypadat nějak takto:

<ul>
<li><b>Python 3.1 Windows installer</b> (Windows binary&nbsp;&mdash;&nbsp;does not include source)
<li><b>Python 3.1 Windows AMD64 installer</b> (Windows AMD64 binary&nbsp;&mdash;&nbsp;does not include source)
</ul>

<p>Nechci zde uvádět konkrétní odkazy, protože Python neustále prochází drobnými úpravami a nechci být zodpovědný za to, že jste nějakou důležitou úpravu prošvihli. Vždy byste měli nainstalovat co nejnovější verzi Pythonu 3.x, tedy pokud nemáte nějaké esoterické důvody k tomu, abyste tak neučinili.

<ol class=i>
<li>
<p class='ss nm'><img src="i/win-install-0-security-warning.png" width="409" height="309" alt="[Dialog Windows: Otevření souboru &mdash; bezpečnostní varování]" />
<p>Jakmile se stahování dokončí, poklepejte na soubor s příponou <code>.msi</code>. Protože se snažíte o spuštění programu, zobrazí Windows bezpečnostní varování. Oficiální instalátor Pythonu je digitálně podepsán jménem organizace <a href="http://www.python.org/psf/">Python Software Foundation</a>, která dohlíží na vývoj jazyka Python. Nepřijímejte imitace!
<p>Instalaci Pythonu 3 zahájíme stisknutím tlačítka <code>Run</code>.

<li>
<p class='ss nm'><img src="i/win-install-1-all-users-or-just-me.png" width="499" height="432" alt="[Instalátor Pythonu: Zvolte, zda se má Python 3.1 instalovat pro všechny uživatele tohoto počítače]" />
<p>Nejdříve se vás instalátor zeptá, zda chcete Python 3 nainstalovat pro všechny uživatele, nebo jen pro sebe. Volba „instalovat pro všechny uživatele“ je přednastavena. Pokud nemáte nějaký dobrý důvod pro jinou volbu, pak toto je ta nejlepší. (Jeden možný důvod, proč byste mohli chtít „instalovat jen pro mne“, je ten, že si chcete nainstalovat Python na počítači v práci a váš účet ve Windows nemá oprávnění administrátora. Ale proč byste v takovém případě chtěli instalovat Python bez svolení svého správce Windows? Ne abyste mě dostali do potíží!)
<p>Svoji volbu způsobu instalace potvrdíte stiskem tlačítka <code>Next</code>.

<li>
<p class='ss nm'><img src="i/win-install-2-destination-directory.png" width="499" height="432" alt="[Instalátor Pythonu: Výběr cílového adresáře]" />
<p>Instalátor vás poté vyzve k výběru instalačního adresáře. Pro všechny verze Python 3.1.x je přednastavena hodnota <code>C:\Python31\</code>, která by měla vyhovovat většině uživatelů. Pokud ovšem nemáte zvláštní důvod cestu změnit. Pokud instalujete všechny aplikace na disk označený jiným písmenem, můžete příslušnou cestu vybrat příslušnými ovládacími prvky. Nebo prostě cestu k adresáři napíšete do spodního pole. Python nemusíte instalovat jen na disk <code>C:</code>. Můžete si jej nainstalovat na libovolný disk a do libovolného adresáře.
<p>Volbu cílového adresáře potvrdíte stiskem tlačítka <code>Next</code>.

<li>
<p class='ss nm'><img src="i/win-install-3-customize.png" width="499" height="432" alt="[Instalátor Pythonu: Přizpůsobení instalace Python 3.1 vlastním požadavkům]" />
<p>Další dialogová stránka vypadá komplikovaně, ale ve skutečnosti není. V případě Pythonu 3 máte možnost neinstalovat úplně všechny jeho komponenty &mdash; podobně jako u jiných instalačních programů. Pokud máte obzvlášť málo místa na disku, můžete některé komponenty vynechat.
<ul>
<li>Volba <b>Register Extensions</b> (asociovat přípony) vám zajistí možnost spouštět pythonovské skripty (soubory s příponou <code>.py</code>) poklepáním na jejich ikonu. Je to sice doporučeno, ale není to nezbytné. (Tato volba nevyžaduje žádný diskový prostor, takže její potlačení není výhodné.)
<li><b>Tcl/Tk</b> je grafická knihovna, kterou využívá pythonovský shell. Ten budeme používat v celé knize. Velmi doporučuji, abyste tuto volbu ponechali zapnutou.
<li>Volba <b>Documentation</b> vede k instalaci souborů s nápovědou, která obsahuje mnohé z informací uvedených na <a href="http://docs.python.org/"><code>docs.python.org</code></a>. Pokud máte omezený přístup k internetu nebo pokud používáte vytáčené připojení, doporučuji volbu ponechat zapnutou.
<li>Volba <b>Utility Scripts</b> v sobě zahrnuje i instalaci skriptu <code>2to3.py</code>, o kterém se budeme učit <a href=#chapter-case-study-porting-chardet-to-python-3>v této knize později</a>. Pokud se chcete naučit přepisování existujícího kódu napsaného pro Python 2 do podoby pro Python 3, pak se zapnutí této volby vyžaduje. Pokud nemáte žádné programy napsané pro Python 2, můžete tuto volbu vypnout.
<li>Volba <b>Test Suite</b> zajistí instalaci sady skriptů, které se používají pro testování funkčnosti interpretu jazyka Python. V této knize je nebudeme používat. A nepoužíval jsem je nikdy ani během výuky programování v Pythonu. Volba je zcela na vás.
</ul>

<li>
<p class='ss nm'><img src="i/win-install-3a-disk-usage.png" width="499" height="432" alt="[Instalátor Pythonu: Požadavky na prostor na disku]" />
<p>Pokud si nejste jisti, kolik máte místa na disku, klikněte na tlačítko <code>Disk Usage</code>. Instalátor zobrazí seznam písmen vašich disků, zjistí, kolik místa je na každém z nich, a vypočítá, kolik místa na nich zbude po instalaci.
<p>Stiskem tlačítka <code>OK</code> se dostaneme na dialogovou stránku „Customizing Python“.

<li>
<p class='ss nm'><img src="i/win-install-3b-test-suite.png" width="499" height="432" alt="[Instalátor Pythonu: Vypnutím volby Test Suite ušetříte 7908 KB na disku]" />
<p>Pokud se rozhodnete volbu vynechat, stiskněte tlačítko pro rozbalení seznamu a vyberte „Entire feature will be unavailable“ (celá část bude nedostupná). Vynecháním Test Suite ušetříte na disku pěkných 7908 <abbr>KB</abbr>.
<p>Výběr voleb potvrdíte stiskem tlačítka <code>Next</code>.

<li>
<p class='ss nm'><img src="i/win-install-4-copying.png" width="499" height="432" alt="[Instalátor Pythonu: Indikace postupu instalace]" />
<p>Instalátor nakopíruje všechny nezbytné soubory do vámi vybraného adresáře. (Proběhne to tak rychle, že jsem to musel zkusit třikrát, než se mi podařilo zachytit obrázek tohoto procesu.)

<li>
<p class='ss nm'><img src="i/win-install-5-finish.png" width="499" height="432" alt="[Instalátor Pythonu: Instalace dokončena. Zvláštní poděkování Markovi Hammondovi, bez jehož po léta sdílených zkušeností s Windows by Python pro Windows byl stále jen Pythonem pro DOS]" />
<p>Stiskem tlačítka <code>Finish</code> ukončíme činnost instalátoru.

<li>
<p class='ss nm'><img src="i/win-interactive-shell.png" width="677" height="715" alt="[Windowsovská podoba pythonovského shellu, což je grafický interaktivní shell pro Python]" />
<p>Ve vašem menu <code>Start</code> by se měla objevit položka s názvem <code>Python 3.1</code>. V ní se nachází program <abbr>IDLE</abbr>. Výběrem této položky spustíte interaktivní pythonovský shell. (Poznámka překladatele: Někdy ho autor označuje jako „grafický“ interaktivní shell. Jde o obdobu interaktivního pythonovského shellu, který se spouští v konzolovém okně. Tentokrát ale využívá prostředky grafického uživatelského rozhraní (GUI) a v menu okna nalezneme i položky pro spuštění editoru nebo pro spuštění ladicího režimu. Dalo by se říct, že je to nástroj „téměř úplně, ale ne zcela naprosto nepodobný...“ klasickým IDE (integrované vývojové prostředí). Jenže to není soustředěné kolem editoru, ale spíš kolem shellu. Je to prostě IDLE. No zkrátka se na to podívejte a rozhodněte se sami, jak tomu budete říkat.)

</ol>

<p>[přeskočte na <a href=#installing-python-idle>použití pythonovského shellu</a>]

<p class=a>&#x2042;

<h2 id=installing-python-macosx>Instalace pod Mac OS X</h2>

<p>Všechny moderní počítače Macintosh používají procesor firmy Intel (stejný jako většina osobních počítačů s Windows). Starší počítače Mac používají procesory PowerPC. Rozdílům rozumět nemusíte, protože existuje jen jeden jediný instalátor Pythonu pro všechny počítače Macintosh.

<p>Přejděte na stránku <a href="http://python.org/download/"><code>python.org/download/</code></a> a stáhněte si příslušný instalátor pro Mac. Bude u něj napsáno něco ve stylu <b>Python 3.1 Mac Installer Disk Image</b>, ačkoliv číslo verze se může lišit. Ujistěte se, že stahujete verzi 3.x a ne 2.x.

<ol class=i>

<li>
<p class='ss nm'><img src="i/mac-install-0-dmg-contents.png" width="752" height="438" alt="[Obsah diskového obrazu pythonovského instalátoru]" />
<p>Váš prohlížeč by měl automaticky připojit obraz disku a otevřít okno Finder zobrazující jeho obsah. (Pokud se tak nestane, budete muset najít obraz disku ve svém adresáři pro stažené soubory a připojit jej poklepáním. Jmenuje se <code>python-3.1.dmg</code> nebo podobně.) Obraz disku obsahuje řadu textových souborů (<code>Build.txt</code>, <code>License.txt</code>, <code>ReadMe.txt</code>) a také skutečný instalační balík <code>Python.mpkg</code>.
<p>Poklepejte na <code>Python.mpkg</code> a instalátor Mac Python se spustí.

<li>
<p class='ss nm'><img src="i/mac-install-1-welcome.png" width="622" height="442" alt="[Instalátor Pythonu: Úvodní obrazovka]" />
<p>Na první stránce naleznete stručný popis jazyka Python a pro více detailů jste odkázáni na soubor <code>ReadMe.txt</code>. (...který jste nečetli. Nebo četli?)
<p>Dál se posuneme stiskem tlačítka <code>Continue</code>.

<li>
<p class='ss nm'><img src="i/mac-install-2-information.png" width="622" height="442" alt="[Instalátor Pythonu: Informace o podporovaných architekturách, prostoru na disku a přijatelných cílových adresářích]" />
<p>Následující stránka dialogu obsahuje některé důležité informace: Python vyžaduje Mac OS X 10.3 nebo novější. Pokud stále používáte Mac OS X 10.2, budete jej muset aktualizovat na vyšší verzi. Společnost Apple už pro váš operační systém neposkytuje bezpečnostní aktualizace a už při pouhém připojení na internet vystavujete svůj počítač riziku. A navíc nemůžete používat Python 3.
<p>Pokračujeme stiskem tlačítka <code>Continue</code>.

<li>
<p class='ss nm'><img src="i/mac-install-3-license.png" width="622" height="442" alt="[Instalátor Pythonu: Souhlas s licenčním ujednáním]" />
<p>Tak jako všechny dobré instalátory, i ten pythonovský zobrazí licenční ujednání. Python je open source a jeho licence je <a href="http://opensource.org/licenses/">schválena společností Open Source Initiative</a>. Během historického vývoje měl Python řadu vlastníků a sponzorů. Každý z nich zanechal v jeho licenci svůj otisk. Ale konečný výsledek vypadá takto: Python je open source, můžete jej používat na libovolné platformě, pro libovolný účel, zdarma a bez závazku k protislužbě.
<p>Stiskněte tlačítko <code>Continue</code> ještě jednou.

<li>
<p class='ss nm'><img src="i/mac-install-4-license-dialog.png" width="622" height="442" alt="[Instalátor Pythonu: Dialog pro přijetí licenčního ujednání]" />
<p>Abyste mohli instalaci dokončit, musíte kvůli manýrům v jádru applovského instalátoru projevit „souhlas“ se softwarovou licencí. Ale protože Python je open source, ve skutečnosti „souhlasíte“ s tím, že vám licence zaručuje práva navíc, než aby vás omezovala.
<p>Pokračujeme stiskem tlačítka <code>Agree</code>.

<li>
<p class='ss nm'><img src="i/mac-install-5-standard-install.png" width="622" height="442" alt="[Instalátor Pythonu: Standardní instalační obrazovka]" />
<p>Na další obrazovce můžete změnit umístění instalace. Python <strong>musíte</strong> instalovat na zaváděcí disk, ale kvůli omezením instalátoru to není vynuceno. Popravdě řečeno, nikdy jsem nepociťoval potřebu umístění instalace měnit.
<p>Na této obrazovce také můžete instalaci upravit vyloučením komponent, které nepotřebujete. Pokud tak chcete učinit, stiskněte tlačítko <code>Customize</code>. V opačném případě stiskněte tlačítko <code>Install</code>.

<li>
<p class='ss nm'><img src="i/mac-install-6-custom-install.png" width="622" height="442" alt="[Instalátor Pythonu: Obrazovka pro úpravu vlastností instalace]" />
<p>Pokud zvolíte uživatelskou úpravu instalace (Custom Install), nabídne vám instalátor následující seznam:
<ul>
<li><b>Python Framework</b>. Jde o jádro Pythonu. Proto je tato možnost předvolena a současně je zakázáno ji měnit. Tato část se nainstalovat musí.
<li><b>GUI Applications</b> v sobě zahrnuje IDLE, což je grafický pythonovský shell. Budeme jej používat během celé knihy. Velmi doporučuji, abyste tuto volbu ponechali zapnutou.
<li><b>UNIX command-line tools</b> v sobě obsahuje konzolovou aplikaci <code>python3</code>. Velmi doporučuji, abyste také tuto volbu ponechali zapnutou.
<li><b>Python Documentation</b> obsahuje mnohé z informací uvedených na <a href="http://docs.python.org/"><code>docs.python.org</code></a>. Pokud máte omezený přístup k internetu nebo pokud používáte vytáčené připojení, doporučuji volbu ponechat zapnutou.
<li><b>Shell profile updater</b> kontroluje, zda je nutné aktualizovat váš shellovský profil (použitý v <code>Terminal.app</code>) tak, aby bylo zajištěno, že umístění instalované verze Pythonu bude součástí prohledávaných cest. Tuto volbu pravděpodobně nebudete potřebovat měnit.
<li>Volbu <b>Fix system Python</b> byste měnit neměli. (Říká vašemu počítači, aby byl Python 3 použit jako preferovaný Python pro spouštění všech skriptů, včetně zabudovaných skriptů dodávaných firmou Apple. Dopadlo by to velmi špatně, protože většina těchto skriptů byla napsána pro Python 2 a pod verzí Python 3 by neběžely správně.)
</ul>
<p>Pokračujeme stiskem tlačítka <code>Install</code>.

<li>
<p class='ss nm'><img src="i/mac-install-7-admin-password.png" width="622" height="457" alt="[Instalátor Pythonu: Dialog pro zadání správcovského hesla]" />
<p>Instalátor se vás zeptá na heslo správce, protože systémové binární soubory a nástroje se instalují do adresáře <code>/usr/local/bin/</code>. Bez administrátorských oprávnění Mac Python zkrátka nenainstalujete.
<p>Stiskem tlačítka <code>OK</code> zahájíme instalaci.

<li>
<p class='ss nm'><img src="i/mac-install-8-progress.png" width="622" height="442" alt="[Instalátor Pythonu: Indikace postupu instalace.]" />
<p>Během instalace částí, které jste si vybrali, instalátor indikuje postup instalace.

<li>
<p class='ss nm'><img src="i/mac-install-9-succeeded.png" width="622" height="442" alt="[Instalátor Pythonu: Instalace byla úspěšně dokončena]" />
<p>Pokud šlo všechno dobře, oznámí vám instalátor úspěšné dokončení instalace zobrazením zelené „fajfky“.
<p>Stiskem tlačítka <code>Close</code> činnost instalátoru ukončíme.

<li>
<p class='ss nm'><img src="i/mac-install-10-application-folder.png" width="488" height="482" alt="[Obsah adresáře /Applications/Python 3.1/]" />
<p>Za předpokladu, že jste nezměnili umístění instalace, najdete nově nainstalované soubory v podadresáři <code>Python 3.1</code> uvnitř adresáře <code>/Applications</code>. Nejdůležitější součástí je zde grafický pythonovský shell zvaný <abbr>IDLE</abbr>.
<p>Poklepejte na něj a pythonovský shell se spustí.

<li>
<p class='ss nm'><img src="i/mac-interactive-shell.png" width="522" height="538" alt="[Mac Python Shell &mdash; grafický interaktivní shell pro Python]" />
<p>V pythonovském shellu strávíte při průzkumu jazyka Python nejvíce času. U příkladů budeme v této knize předpokládat, že se k pythonovskému shellu umíte dostat.

</ol>

<p>[Přeskočte na <a href=#installing-python-idle>použití pythonovského shellu</a>]

<p class=a>&#x2042;

<h2 id=installing-python-ubuntu>Instalace pod Ubuntu Linux</h2>

<p>Moderní distribuce systému Linux jsou podepřeny ohromnými úložišti předkompilovaných aplikací, které jsou připraveny k okamžité instalaci. Detaily se pro konkrétní distribuce liší. Nejsnadnější způsob instalace Pythonu 3 pod Ubuntu Linux spočívá v použití nástroje <code>Add/Remove</code>, který najdete v menu <code>Applications</code>.

<ol class=i>
<li>
<p class='ss nm'><img src="i/ubu-install-0-add-remove-programs.png" width="920" height="473" alt="[Add/Remove: Aplikace udržované firmou Canonical]" />
<p>Když poprvé spustíte aplikaci <code>Add/Remove</code>, zobrazí vám seznam předvybraných aplikací v různých kategoriích. Některé z nich jsou již nainstalované, ale většina z nich ne. Protože úložiště obsahuje přes 10 tisíc aplikací, můžete pomocí různých filtrů omezit zobrazení jen na jeho malé části. Základem je filtr „Canonical-maintained applications“, což je malá podmnožina z celkového množství aplikací, které jsou oficiálně podporovány společností Canonical, která vytvořila a udržuje distribuci Ubuntu Linux.

<li>
<p class='ss nm'><img src="i/ubu-install-1-all-open-source-applications.png" width="920" height="473" alt="[Add/Remove: Všechny open source aplikace]" />
<p>Python 3 není společností Canonical udržován, takže jako první krok potlačíme činnost tohoto filtru a vybereme „All Open Source applications“ (všechny open source aplikace).

<li>
<p class='ss nm'><img src="i/ubu-install-2-search-python-3.png" width="920" height="473" alt="[Add/Remove: Hledej Python 3]" />
<p>Jakmile změníte nastavení filtru tak, aby zahrnoval všechny open source aplikace, použijte k vyhledání <kbd>Pythonu 3</kbd> vyhledávací box nacházející se hned za nabídkou filtru.

<li>
<p class='ss nm'><img src="i/ubu-install-3-select-python-3.png" width="920" height="473" alt="[Add/Remove: Vyberte balík Python 3.0]" />
<p>V tom okamžiku se seznam aplikací zúží jen na ty, které souvisejí s <kbd>Pythonem 3</kbd>. Poté vybereme dva balíčky. Tím prvním je <code>Python (v3.0)</code>. Obsahuje vlastní interpret jazyka Python.
<li>
<p class='ss nm'><img src="i/ubu-install-4-select-idle.png" width="920" height="473" alt="[Add/Remove: Vyberte balík IDLE pro Python 3.0]" />
<p>Druhý požadovaný balíček se nachází bezprostředně nad ním: <code>IDLE (using Python-3.0)</code>. Jde o grafický pythonovský shell, který budeme používat během celé knihy.
<p>Po označení uvedených dvou balíčků pokračujte stiskem tlačítka <code>Apply Changes</code>.

<li>
<p class='ss nm'><img src="i/ubu-install-5-apply-changes.png" width="635" height="364" alt="[Add/Remove: Aplikuj změny]" />
<p>Správce balíčků vás požádá o potvrzení, že chcete přidat jak <code>IDLE (using Python-3.0)</code>, tak <code>Python (v3.0)</code>.
<p>Pokračujeme stiskem tlačítka <code>Apply</code>.

<li>
<p class='ss nm'><img src="i/ubu-install-6-download-progress.png" width="287" height="211" alt="[Add/Remove: Indikátor postupu stahování]" />
<p>Během stahování potřebných balíčků z internetového úložiště společnosti Canonical zobrazuje správce balíčků indikátor postupu stahování.

<li>
<p class='ss nm'><img src="i/ubu-install-7-install-progress.png" width="486" height="258" alt="[Add/Remove: Indikátor postupu instalace]" />
<p>Jakmile jsou balíčky staženy, zahájí správce balíčků automaticky jejich instalaci.

<li>
<p class='ss nm'><img src="i/ubu-install-8-success.png" width="591" height="296" alt="[Add/Remove: Nové aplikace byly nainstalovány]" />
<p>Pokud šlo všechno dobře, potvrdí správce balíčků, že byly oba úspěšně nainstalovány. V tomto okamžiku můžete poklepáním na <abbr>IDLE</abbr> spustit pythonovský shell, nebo můžete stiskem tlačítka <code>Close</code> ukončit činnost správce balíčků.
<p>Pythonovský shell můžete spustit kdykoliv tím způsobem, že v menu <code>Applications</code> a v podmenu <code>Programming</code> vyberete <abbr>IDLE</abbr>.

<li>
<p class='ss nm'><img src="i/ubu-interactive-shell.png" width="679" height="687" alt="[Linuxovský pythonovský shell = grafický interaktivní shell pro Python]" />
<p>V pythonovském shellu strávíte při průzkumu jazyka Python nejvíce času. U příkladů budeme v této knize předpokládat, že se k pythonovskému shellu umíte dostat.

</ol>

<p>[Přeskočte na <a href=#installing-python-idle>použití pythonovského shellu</a>]

<p class=a>&#x2042;

<h2 id=installing-python-other>Instalace na jiných platformách</h2>

<p>Python 3 je dostupný pro řadu různých platforem. Abychom byli konkrétnější, je dostupný pro prakticky každou distribuci systému Linux, <abbr>BSD</abbr> a pro distribuce založené na systému Solaris. Takže například RedHat Linux používá správce balíčků <code>yum</code>. FreeBSD má svou sbírku <a href="http://www.freebsd.org/ports/">ports and packages collection</a>, <abbr>SUSE</abbr> má <code>zypper</code> a Solaris má <code>pkgadd</code>. Když zkusíte zběžně prohledat web při zadání <code>Python 3</code> + <i>váš operační systém</i>, dozvíte se, zda je balík s Pythonem 3 dostupný, a pokud ano, jak jej můžete nainstalovat.

<p class=a>&#x2042;

<h2 id=installing-python-idle>Použití Python Shell</h2>

<p>Python Shell (kvůli skloňování a zobecnění pohledu mu budeme říkat také <em>pythonovský shell</em>) bude nástrojem pro studium syntaxe jazyka Python, zdrojem interaktivní nápovědy k příkazům a prostředkem pro ladění krátkých programů. Grafický pythonovský shell (pojmenovaný <abbr>IDLE</abbr>) obsahuje navíc ucházející textový editor, který podporuje barevné zvýrazňování syntaxe a zajišťuje spolupráci s (konzolovým) pythonovským shellem. Pokud již nemáte nějaký svůj oblíbený textový editor, měli byste si <abbr>IDLE</abbr> vyzkoušet.

<p>Ale proberme nejdříve hlavní věci. Samotný Python Shell je úžasné interaktivní prostředí, se kterým si vyhrajete. V celé knize se budete setkávat s příklady, jako je tento:

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>1 + 1</kbd>
<samp class=pp>2</samp></pre>

<p>Tři úhlové závorky (<samp class="p">&gt;&gt;&gt;</samp>) jsou vyzývacím řetězcem pythonovského shellu. Tuto část neopisujte. Vyjadřuji tím to, že byste si příklad měli vyzkoušet v pythonovském shellu.

<p>Vy budete psát pouze část <kbd class="pp">1 + 1</kbd>. V pythonovském shellu můžete napsat jakýkoliv platný pythonovský výraz nebo příkaz. Nestyďte se! Nekousne vás to! Přinejhorším se stane to, že se vám zobrazí chybové hlášení. Příkazy se provádějí okamžitě (jakmile stisknete <kbd>ENTER</kbd>). Také výrazy jsou vyhodnoceny okamžitě a pythonovský shell vytiskne jejich výsledek.

<p>Takže zobrazená část <samp class="pp">2</samp> je výsledkem vyhodnocení předchozího výrazu. Protože se tak stalo, je <kbd class="pp">1 + 1</kbd> zjevně platným pythonovským výrazem. Jeho výsledek je samozřejmě <samp class="pp">2</samp>.

<p>Vyzkoušejme něco dalšího.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>print('Hello world!')</kbd>
<samp>Hello world!</samp>
</pre>

<p>Docela jednoduché, že? Ale v pythonovském shellu toho můžete dělat mnohem víc. Když se někdy zadrhnete&nbsp;&mdash;&nbsp;když si nemůžete vzpomenout na nějaký příkaz nebo si nemůžete vzpomenout na správné argumenty předávané nějaké funkci&nbsp;&mdash;, můžete se v pythonovském shellu dostat k interaktivní nápovědě. Napište prostě <kbd>help</kbd> a stiskněte <kbd>ENTER</kbd>.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd>help</kbd>
<samp>Type help() for interactive help, or help(object) for help about object.</samp></pre>

<p>Nápovědu můžeme používat ve dvou režimech. Můžeme získat nápovědu pro jeden objekt. Vytiskne se prostě jeho dokumentace a vrátíte se na vyzývací řádek pythonovského shellu. Nebo můžeme vstoupit do <i>režimu nápovědy</i>, ve kterém místo vyhodnocování pythonovských výrazů píšeme klíčová slova nebo jména příkazů a Python zobrazuje vše, co o těchto příkazech ví.

<p>Pro vstup do interaktivního režimu nápovědy napište <kbd>help()</kbd> a stiskněte <kbd>ENTER</kbd>.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>help()</kbd>
<samp>Welcome to Python 3.0!  This is the online help utility.

If this is your first time using Python, you should definitely check out
the tutorial on the Internet at http://docs.python.org/tutorial/.

Enter the name of any module, keyword, or topic to get help on writing
Python programs and using Python modules.  To quit this help utility and
return to the interpreter, just type "quit".

To get a list of available modules, keywords, or topics, type "modules",
"keywords", or "topics".  Each module also comes with a one-line summary
of what it does; to list the modules whose summaries contain a given word
such as "spam", type "modules spam".
</samp>
<samp class=p>help> </samp></pre>

<p>Všimněte si, že se vyzývací řetězec změnil z <samp class="p">>>></samp> na <samp class="p">help></samp>. Má vám to připomenout, že se nacházíte v interaktivním režimu nápovědy. V tomto okamžiku můžete napsat libovolné klíčové slovo, příkaz, jméno modulu, jméno funkce&nbsp;&mdash;&nbsp;v podstatě cokoliv, čemu Python rozumí&nbsp;&mdash;&nbsp; a přečtete si k tomu zobrazenou dokumentaci.

<pre class=screen>
<a><samp class=p>help> </samp><kbd class=pp>print</kbd>                                                                 <span class=u>&#x2460;</span></a>
<samp>Help on built-in function print in module builtins:

print(...)
    print(value, ..., sep=' ', end='\n', file=sys.stdout)
    
    Prints the values to a stream, or to sys.stdout by default.
    Optional keyword arguments:
    file: a file-like object (stream); defaults to the current sys.stdout.
    sep:  string inserted between values, default a space.
    end:  string appended after the last value, default a newline.
</samp>
<a><samp class=p>help> </samp><kbd class=pp>PapayaWhip</kbd>                                                            <span class=u>&#x2461;</span></a>
<samp>no Python documentation found for 'PapayaWhip'
</samp>
<a><samp class=p>help> </samp><kbd class=pp>quit</kbd>                                                                  <span class=u>&#x2462;</span></a>
<samp>
You are now leaving help and returning to the Python interpreter.
If you want to ask for help on a particular object directly from the
interpreter, you can type "help(object)".  Executing "help('string')"
has the same effect as typing a particular string at the help> prompt.</samp>
<a><samp class=p>>>> </samp>                                                                        <span class=u>&#x2463;</span></a></pre>
<ol>
<li>Abyste dostali dokumentaci k funkci <code>print()</code>, napište <kbd>print</kbd> a stiskněte <kbd>ENTER</kbd>. V interaktivním režimu nápovědy se zobrazí něco podobného jako manovská stránka: jméno funkce, stručný popis, argumenty funkce a jejich přednastavené hodnoty a tak dále. Pokud se vám zdá obsah dokumentace nejasný, nepropadejte panice. V následujících několika kapitolách se o těchto věcech dozvíte více. 
<li>V interaktivním režimu nápovědy se samozřejmě nedozvíte všechno. Pokud zde napíšete něco, co není pythonovským příkazem, modulem, funkcí nebo nějakým zabudovaným klíčovým slovem, režim interaktivní nápovědy prostě pokrčí svými virtuálními rameny. 
<li>Interaktivní režim nápovědy ukončíte tím, že napíšete <kbd>quit</kbd> a stisknete <kbd>ENTER</kbd>. 
<li>Vyzývací řádek se změní zpět na <samp class="p">>>></samp>, čímž se dozvíte, že jste opustili režim interaktivní nápovědy a vrátili jste se do pythonovského shellu.
</ol>

<p>Grafický pythonovský shell <abbr>IDLE</abbr> navíc obsahuje textový editor šitý na míru jazyku Python. 

<p class=a>&#x2042; 

<h2 id=installing-python-editors>Editory a vývojová prostředí pro Python</h2>

<p>Pokud jde o psaní programů v jazyce Python, nepředstavuje <abbr>IDLE</abbr> jedinou možnost. Jakkoliv může být užitečný při seznamování se s jazykem jako takovým, mnozí vývojáři dávají přednost jiným textovým editorům nebo integrovaným vývojovým prostředím (Integrated Development Environment, čili <abbr>IDE</abbr>). Nebudu se zde jimi zabývat, ale komunita uživatelů jazyka Python udržuje <a href="http://wiki.python.org/moin/PythonEditors">seznam editorů podporujících jazyk Python</a>, který pokrývá široké rozpětí podporovaných platforem a softwarových licencí. 

<p>Možná chcete nahlédnout i do <a href="http://wiki.python.org/moin/IntegratedDevelopmentEnvironments">seznamu <abbr>IDE</abbr> podporujících jazyk Python</a>, i když zatím pouze nemnohé z nich podporují Python 3. Jedním z těch, které jej podporují, je <a href="http://pydev.sourceforge.net/">PyDev</a>, zásuvný modul pro <a href="http://eclipse.org/">Eclipse</a>, který změní Eclipse na plnohodnotné pythonovské integrované vývojové prostředí. Jak Eclipse, tak PyDev jsou multiplatformní a open source. 

<p>Z komerčních produktů jmenujme <a href="http://www.activestate.com/komodo/">Komodo <abbr>IDE</abbr></a> společnosti ActiveState. Licence je vázána na uživatele. Studenti mohou získat slevu a k dispozici je i zkušební, časově omezená verze. 

<p>V jazyce Python programuji už devět let. Své programy edituji v prostředí <a href="http://www.gnu.org/software/emacs/">GNU Emacs</a> a ladím je v konzolovém pythonovském shellu. Při vývoji v jazyce Python není žádná cesta správnější nebo vyloženě špatná. Najděte si způsob, který vyhovuje právě vám! 

</div>
<div id=chapter-your-first-python-program>
<h1>Váš první pythonovský program</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> Don’t bury your burden in saintly silence. You have a problem? Great. Rejoice, dive in, and investigate. <span class="u">&#x275E;</span><br>(Neutápějte své břímě ve svatém mlčení. Máte problém? Paráda. Radujte se, ponořte se do něj, bádejte.)<br>&mdash; <a href="http://en.wikiquote.org/wiki/Buddhism">Ven. Henepola Gunaratana</a>
</blockquote>
<p>&nbsp;
<h2 id=your-first-python-program-divingin>Ponořme se</h2>
<p class=f>Konvence nám diktuje, že bych vás teď měl otravovat základními stavebními kameny, které s programováním souvisejí. A z nich bychom pak měli pomalu budovat něco užitečného. Přeskočme to. Tady máte úplný a funkční pythonovský program. Pravděpodobně vám bude zcela nepochopitelný. Žádné strachy. Rozpitváme ho řádek po řádku. Ale nejdříve si jej celý přečtěte a zjistěte, co z něj chápete (pokud vůbec něco).
<p class=d>[<a href="examples/humansize.py">stáhnout <code>humansize.py</code></a>]
<pre class=pp><code>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}

def approximate_size(size, a_kilobyte_is_1024_bytes=True):
    '''Convert a file size to human-readable form.

    Keyword arguments:
    size -- file size in bytes
    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024
                                if False, use multiples of 1000

    Returns: string

    '''
    if size &lt; 0:
        raise ValueError('number must be non-negative')

    multiple = 1024 if a_kilobyte_is_1024_bytes else 1000
    for suffix in SUFFIXES[multiple]:
        size /= multiple
        if size &lt; multiple:
            return '{0:.1f} {1}'.format(size, suffix)

    raise ValueError('number too large')

if __name__ == '__main__':
    print(approximate_size(1000000000000, False))
    print(approximate_size(1000000000000))</code></pre>
<p>Spusťme program z příkazového řádku. Pod Windows to bude vypadat nějak takto:
<pre class='nd screen'>
<samp class=p>c:\home\diveintopython3\examples> </samp><kbd>c:\python31\python.exe humansize.py</kbd>
<samp>1.0 TB
931.3 GiB</samp></pre>
<p>Pod Mac OS X nebo pod Linuxem to bude vypadat zase takhle:
<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 humansize.py</kbd>
<samp>1.0 TB
931.3 GiB</samp></pre>

<p>Co se to vlastně stalo? Spustili jste svůj první pythonovský program. Z příkazového řádku jste zavolali interpret jazyka Python a předali jste mu jméno skriptu, který měl být proveden. Uvedený skript definuje jedinou funkci, <code>approximate_size()</code>, která přebírá přesnou velikost souboru v bajtech a vypočítá velikost „v hezčím tvaru“ (ale přibližnou). (Pravděpodobně už jste něco podobného viděli v Průzkumníku Windows, v okně Finder na Mac OS X nebo v aplikacích Nautilus nebo Dolphin nebo Thunar na Linuxu. Když si necháte složku s dokumenty zobrazit v podobě vícesloupcového seznamu, uvidíte v tabulce ikonu dokumentu, jméno dokumentu, velikost, typ, datum poslední změny a tak dále. Pokud složka obsahuje soubor se jménem <code>TODO</code> a s velikostí 1093 bajtů, nezobrazí váš správce souborů <code>TODO 1093 bytes</code>. Místo toho se ukáže něco jako <code>TODO 1 KB</code>. A právě tohle dělá funkce <code>approximate_size()</code>.)

<p>Podívejte se na konec skriptu a uvidíte dva řádky s voláním <code>print(approximate_size(<var>argumenty</var>))</code>. Jde o volání funkcí. Nejdříve se volá funkce <code>approximate_size()</code> a předávají se jí argumenty. Její návratová hodnota se předává přímo funkci <code>print()</code>. Funkce <code>print()</code> patří mezi zabudované (built-in). Její deklaraci nikdy neuvidíte. Můžete ji ale používat &mdash; kdykoliv a kdekoliv. (Zabudovaných funkcí existuje celá řada. A ještě mnohem více se jich nachází v různých <i>modulech</i>. Jen klid&hellip;)

<p>Takže proč vlastně spuštěním skriptu z příkazového řádku získáme pokaždé stejný výstup? K tomu se ještě dostaneme. Nejdříve se podíváme na funkci <code>approximate_size()</code>.

<p class=a>&#x2042;

<h2 id=your-first-python-program-declaringfunctions>Deklarace funkcí</h2>
<p>Python pracuje s funkcemi podobně jako většina dalších jazyků, ale neodděluje hlavičkové soubory jako <abbr>C++</abbr> nebo sekce <code>rozhraní</code>/<code>implementace</code> jako Pascal. Pokud potřebujete nějakou funkci, prostě ji deklarujete, jako třeba zde:
<pre class='nd pp'><code>def approximate_size(size, a_kilobyte_is_1024_bytes=True):</code></pre>
<aside>Pokud potřebujete nějakou funkci, prostě ji deklarujte.</aside>
<p>Deklarace funkce začíná klíčovým slovem <code>def</code>. Následuje jméno funkce a v závorce pak argumenty. Více argumentů se odděluje čárkami.
<p>Všimněte si, že funkce nedefinuje typ návratové hodnoty. Funkce v jazyce Python neurčují datový typ návratové hodnoty. Neurčují dokonce ani to, jestli vracejí hodnotu nebo ne. (Ve skutečnosti každá pythonovská funkce vrací hodnotu. Pokud funkce provede příkaz <code>return</code>, vrátí v něm uvedenou hodnotu. V ostatních případech vrací <code>None</code>, což je pythonovský ekvivalent hodnoty null, nil, nic, žádná hodnota.)
<blockquote class=note>
<p><span class="u">&#x261E;</span>V některých jazycích funkce (které vracejí hodnotu) začínají slovem <code>function</code> a podprogramy (které nevracejí hodnotu) začínají slovem <code>sub</code>. Jazyk Python žádné podprogramy nezná. Vše jsou funkce, všechny funkce vracejí hodnotu (i když někdy je to <code>None</code>) a všechny funkce začínají slovem <code>def</code>.
</blockquote>
<p>Funkce <code>approximate_size()</code> přebírá dva argumenty&nbsp;&mdash;&nbsp;<var>size</var> a <var>a_kilobyte_is_1024_bytes</var>&nbsp;&mdash;, ale u žádného z nich není určen datový typ. V jazyce Python nemají proměnné explicitně určen typ nikdy. Python zjistí, jakého typu proměnná je, a vnitřně si to eviduje.
<blockquote class='note compare java'>
<p><span class="u">&#x261E;</span>V jazyce Java a v dalších jazycích se statickými datovými typy musíme určovat datový typ návratové hodnoty funkce a každého argumentu funkce. V jazyce Python nikdy explicitně neurčujeme datový typ čehokoliv. Python vnitřně sleduje datový typ podle toho, jakou hodnotu jsme přiřadili.
</blockquote>

<h3 id=your-first-python-program-optional-arguments>Nepovinné a pojmenované argumenty</h3>

<p>Python umožňuje nastavit argumentům funkce implicitní hodnotu. Pokud funkci zavoláme bez zadání argumentu, získá argument svou implicitní hodnotu. Pokud použijeme pojmenované argumenty, můžeme je navíc (při volání funkce) zadat v libovolném pořadí.

<p>Teď se na deklaraci funkce <code>approximate_size()</code> podíváme ještě jednou:

<pre class='nd pp'><code>def approximate_size(size, a_kilobyte_is_1024_bytes=True):</code></pre>

<p>U druhého argumentu, <var>a_kilobyte_is_1024_bytes</var>, je uvedena implicitní hodnota <code>True</code>. To znamená, že tento argument je <i>nepovinný</i>. Funkci můžeme zavolat, aniž bychom ho zadali. Python se bude chovat, jako kdybychom při volání funkce zadali na místě druhého argumentu hodnotu <code>True</code>.

<p>Teď se podívejte na konec skriptu:

<pre class=pp><code>if __name__ == '__main__':
<a>    print(approximate_size(1000000000000, False))  <span class=u>&#x2460;</span></a>
<a>    print(approximate_size(1000000000000))         <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>Zde se funkce <code>approximate_size()</code> volá s dvěma argumenty. Protože jsme druhému argumentu explicitně předali hodnotu <code>False</code>, nabývá <var>a_kilobyte_is_1024_bytes</var> uvnitř funkce <code>approximate_size()</code> hodnotu <code>False</code>.
<li>Zde se funkce <code>approximate_size()</code> volá pouze s jedním argumentem. Ale je to v pořádku, protože druhý argument je volitelný! A protože ho volající neurčil, nabývá druhý argument implicitní hodnoty <code>True</code> &mdash; přesně jak bylo určeno v deklaraci funkce.
</ol>

<p>Hodnotu argumentu můžeme do funkce předat také jako pojmenovanou.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>from humansize import approximate_size</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>approximate_size(4000, a_kilobyte_is_1024_bytes=False)</kbd>       <span class=u>&#x2460;</span></a>
<samp class=pp>'4.0 KB'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>approximate_size(size=4000, a_kilobyte_is_1024_bytes=False)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'4.0 KB'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>approximate_size(a_kilobyte_is_1024_bytes=False, size=4000)</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>'4.0 KB'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>approximate_size(a_kilobyte_is_1024_bytes=False, 4000)</kbd>       <span class=u>&#x2463;</span></a>
<samp class=traceback>  File "&lt;stdin>", line 1
SyntaxError: non-keyword arg after keyword arg</samp>
<a><samp class=p>>>> </samp><kbd class=pp>approximate_size(size=4000, False)</kbd>                           <span class=u>&#x2464;</span></a>
<samp class=traceback>  File "&lt;stdin>", line 1
SyntaxError: non-keyword arg after keyword arg</samp></pre>
<ol>
<li>Zde se funkce <code>approximate_size()</code> volá s hodnotou prvního argumentu <code>4000</code> (<var>size</var>) a s hodnotou <code>False</code> pro pojmenovaný argument <var>a_kilobyte_is_1024_bytes</var>. (Shodou okolností je to druhý argument, ale na tom nezáleží &mdash; jak uvidíte o chvíli později.)
<li>Zde se funkce <code>approximate_size()</code> volá s hodnotou <code>4000</code> pro pojmenovaný argument <var>size</var> a s hodnotou <code>False</code> pro pojmenovaný argument <var>a_kilobyte_is_1024_bytes</var>. (Pojmenované argumenty jsou zde shodou okolností uvedeny ve stejném pořadí, v jakém jsou uvedeny v deklaraci funkce, ale na tom rovněž nezáleží.)
<li>Zde se funkce a<code>approximate_size()</code> volá s hodnotou <code>False</code> pro pojmenovaný argument <var>a_kilobyte_is_1024_bytes</var> a s hodnotou <code>4000</code> pro pojmenovaný argument <var>size</var>. (Vidíte? Já jsem vám říkal, že na pořadí nezáleží.)
<li>Toto volání selhalo, protože jsme použili pojmenovaný argument a teprve po něm následoval nepojmenovaný (poziční) argument. Tohle nefunguje nikdy. Při čtení seznamu argumentů zleva doprava se po použití prvního pojmenovaného argumentu musí všechny následující argumenty uvést také jako pojmenované.
<li>Toto volání rovněž selhává &mdash; ze stejného důvodu jako předchozí volání. Je to tak překvapivé? Když se to tak vezme, předáváme hodnotu <code>4000</code> pro pojmenovaný argument <code>size</code> a je „zřejmé“, že hodnota <code>False</code> byla myšlena jako hodnota argumentu <var>a_kilobyte_is_1024_bytes</var>. Ale Python tímto způsobem nefunguje. Jakmile použijeme pojmenovaný argument, všechny argumenty uvedené napravo od něj musí být také pojmenované.
</ol>

<p class=a>&#x2042;

<h2 id=your-first-python-program-readability>Psaní čitelného kódu</h2>
<p>Nebudu vás zde nudit dlouhým proslovem o důležitosti dokumentování vašeho kódu. Jen si uvědomte, že kód se píše jednou, ale čte se mnohokrát. A nejdůležitějším čtenářem vašeho zdrojového textu budete vy sami &mdash; šest měsíců poté, co jste jej napsali (to znamená poté, co už jste o něm všechno zapomněli a máte v něm něco opravit). V jazyce Python se čitelný kód píše snadno, takže toho využijte. Za šest měsíců mi poděkujete.
<h3 id=your-first-python-program-docstrings>Dokumentační řetězce</h3>
<p>Pythonovskou funkci můžete zdokumentovat tím, že jí přidělíte dokumentační řetězec (zkráceně <code>docstring</code>). V našem programu je u funkce <code>approximate_size()</code> dokumentační řetězec uveden:
<pre class='nd pp'><code>def approximate_size(size, a_kilobyte_is_1024_bytes=True):
    '''Convert a file size to human-readable form.

    Keyword arguments:
    size -- file size in bytes
    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024
                                if False, use multiples of 1000

    Returns: string

    '''</code></pre>
<aside>Každá funkce si zaslouží decentní docstring.</aside>
<p>Tři apostrofy uvozují víceřádkový řetězec. Vše mezi počátečními a koncovými apostrofy (nebo uvozovkami) se stává součástí jediného řetězce, včetně konců řádků, úvodních bílých znaků a jednoduchých apostrofů. Víceřádkové řetězce můžete použít kdekoliv, ale nejčastěji se s nimi setkáte při zápisech dokumentačních řetězců.
<blockquote class='note compare perl5'>
<p><span class="u">&#x261E;</span>Použití ztrojených apostrofů představuje rovněž jednoduchý způsob pro zápis řetězců, ve kterých se vyskytují jak apostrofy, tak uvozovky. Chovají se jako zápis <code>qq/.../</code> v jazyce Perl 5.
</blockquote>
<p>Vše, co se nachází mezi ztrojenými apostrofy, je dokumentační řetězec, který popisuje, co funkce dělá. Pokud <code>docstring</code> existuje, pak to musí být první věc, která se v těle funkce objeví. (To znamená, že musí být uveden na řádku následujícím za deklarací funkce.) Z technického pohledu není nutné <code>docstring</code> funkci vůbec přidělovat, ale prakticky byste to měli udělat vždy. Já vím, že jste o tom slyšeli v každém kurzu programování, který jste navštěvovali. Ale u jazyka Python máme jeden motivační faktor navíc: <code>docstring</code> je dostupný za běhu programu v podobě atributu (vlastnosti) funkce.
<blockquote class=note>
<p><span class="u">&#x261E;</span>Mnohá pythonovská integrovaná vývojová prostředí používají <code>docstring</code> pro účely kontextově citlivé nápovědy. To znamená, že po napsání jména funkce se její <code>docstring</code> zobrazí v podobě tooltipu (tj. malého informačního okénka zobrazovaného poblíž daného místa). Může to být velmi užitečné, ale bude to dobré jen tak, jak dobře napíšete dokumentační řetězce.
</blockquote>
<p class=a>&#x2042;

<h2 id=your-first-python-program-importsearchpath>Vyhledávací cesta pro <code>import</code></h2>
<p>Než půjdeme dál, chtěl bych se stručně zmínit o vyhledávací cestě pro knihovny (library search path). Když se pokoušíte importovat modul, hledá jej Python na několika místech. Přesněji řečeno, hledá jej ve všech adresářích, které jsou definovány proměnnou <code>sys.path</code>. Jde o běžný seznam a jeho obsah můžete snadno zobrazit nebo měnit prostřednictvím standardních metod seznamu. (O seznamech se dozvíme více v kapitole <a href=#native-datatypes-lists>Přirozené datové typy</a>.)
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import sys</kbd>                                                 <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>sys.path</kbd>                                                   <span class=u>&#x2461;</span></a>
<samp class=pp>['',
 '/usr/lib/python31.zip',
 '/usr/lib/python3.1',
 '/usr/lib/python3.1/plat-linux2@EXTRAMACHDEPPATH@',
 '/usr/lib/python3.1/lib-dynload',
 '/usr/lib/python3.1/dist-packages',
 '/usr/local/lib/python3.1/dist-packages']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>sys</kbd>                                                        <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;module 'sys' (built-in)></samp>
<a><samp class=p>>>> </samp><kbd class=pp>sys.path.insert(0, '/home/mark/diveintopython3/examples')</kbd>  <span class=u>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>sys.path</kbd>                                                   <span class=u>&#x2464;</span></a>
<samp class=pp>['/home/mark/diveintopython3/examples',
 '',
 '/usr/lib/python31.zip',
 '/usr/lib/python3.1',
 '/usr/lib/python3.1/plat-linux2@EXTRAMACHDEPPATH@',
 '/usr/lib/python3.1/lib-dynload',
 '/usr/lib/python3.1/dist-packages',
 '/usr/local/lib/python3.1/dist-packages']</samp></pre>
<ol>
<li>Importováním modulu <code>sys</code> zpřístupníme všechny jeho funkce a atributy.
<li><code>sys.path</code> je seznam adresářů, které tvoří aktuální vyhledávací cestu. (U vás to bude vypadat jinak v závislosti na vašem operačním systému, na verzi Pythonu, který používáte, a na tom, kam byl nainstalován.) Pokud se pokoušíte o import, hledá Python soubor s daným jménem a příponou <code>.py</code> právě v těchto adresářích (v uvedeném pořadí).
<li>No, ve skutečnosti jsem trochu zalhal. Pravda je o něco komplikovanější, protože ne všechny moduly jsou uloženy v podobě souborů s příponou <code>.py</code>. U některých jde o <i>zabudované (built-in)</i> moduly. Ve skutečnosti jsou součástí programu Python. Zabudované moduly se chovají úplně stejně jako běžné moduly, ale není k nim k dispozici pythonovský zdrojový kód, protože nejsou napsány v jazyce Python! Zabudované moduly jsou napsány v jazyce C, stejně jako samotný Python.
<li>K pythonovské vyhledávací cestě můžete za běhu přidat nový adresář tím, že jeho jméno přidáte do <code>sys.path</code>. Kdykoliv se od toho okamžiku pokusíte importovat nějaký modul, Python bude prohledávat i tento adresář. Efekt trvá tak dlouho, dokud Python běží.
<li>Použitím příkazu <code>sys.path.insert(0, <var>new_path</var>)</code> jsme vložili nový adresář jako první položku seznamu <code>sys.path</code>, což znamená, že se ocitla na začátku pythonovské vyhledávací cesty. Většinou potřebujeme právě tohle. V případě konfliktu jmen (například když se Python dodává s konkrétní knihovnou verze 2, ale my chceme použít tutéž knihovnu ve verzi 3) uvedeným obratem zajistíme, že námi požadované moduly budou nalezeny dříve než moduly dodané s Pythonem.
</ol>

<p class=a>&#x2042;

<h2 id=your-first-python-program-everythingisanobject>Všechno je objekt</h2>
<p>Pokud vám to náhodou uniklo, řekli jsme si, že pythonovské funkce mají atributy a tyto atributy jsou přístupné za běhu programu. Funkce, stejně jako všechno ostatní v Pythonu, je objektem.
<p>Spusťme interaktivní pythonovský shell a vyzkoušejme si:
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>                               <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>print(humansize.approximate_size(4096, True))</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>4.0 KiB</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(humansize.approximate_size.__doc__)</kbd>      <span class=u>&#x2462;</span></a>
<samp>Convert a file size to human-readable form.

    Keyword arguments:
    size -- file size in bytes
    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024
                                if False, use multiples of 1000

    Returns: string

</samp></pre>
<ol>
<li>Na prvním řádku importujeme program <code>humansize</code> jako modul&nbsp;&mdash;&nbsp;kus kódu, který můžeme používat interaktivně nebo z většího pythonovského programu. Jakmile je import modulu proveden, můžeme se odkazovat na jeho veřejné funkce, třídy nebo atributy. Moduly mohou dělat totéž, čímž si zpřístupňují funkčnost z jiných modulů. A my to můžeme udělat v interaktivním pythonovském shellu také. Tato koncepce je důležitá a v knize se s ní potkáme ještě mnohokrát.
<li>Pokud chceme použít funkce definované v importovaných modulech, musíme uvést i jméno modulu. Takže nestačí napsat jen <code>approximate_size</code>. Musíme uvést <code>humansize.approximate_size</code>. Pokud jste používali třídy v jazyce Java, mělo by vám to něco připomínat.
<li>Zde se místo očekávaného volání funkce ptáme na jeden z jejích atributů, který je nazván <code>__doc__</code>.
</ol>
<blockquote class='note compare perl5'>
<p><span class="u">&#x261E;</span>Pythonovský příkaz <code>import</code> se podobá příkazu <code>require</code> v jazyce Perl. Jakmile provedeme <code>import</code> pythonovského modulu, vyjadřujeme přístup k jeho funkcím zápisem <code><var>modul</var>.<var>funkce</var></code>. Jakmile v jazyce Perl provedeme příkaz <code>require</code>, dostaneme se na jeho funkce zápisem <code><var>modul</var>::<var>funkce</var></code>.
</blockquote>
<h3 id=your-first-python-program-whatsanobject>Co to vlastně je objekt?</h3>
<p>V Pythonu je objektem všechno. A vše může mít atributy a metody. Všechny funkce mají zabudovaný atribut <code>__doc__</code>, který vrací dokumentační řetězec funkce definovaný ve zdrojovém souboru. Modul <code>sys</code> je objekt, který (mimo jiné) má atribut zvaný <var>path</var>. A tak dále.
<p>Tím ale stále neodpovídáme na základnější otázku: Co je to vlastně objekt? Různé programovací jazyky definují „objekt“ různým způsobem. V některých jazycích to znamená, že <em>všechny</em> objekty <em>musí</em> mít atributy a metody. V jiných jazycích to znamená, že všechny objekty lze rozdělit do tříd. Jazyk Python definuje objekt volněji. Některé objekty nemusí mít ani atributy ani metody, <em>ale mohou je mít</em>. Ne všechny objekty mají svou třídu. Ale vše je objektem v tom smyslu, že to může být přiřazeno do proměnné nebo předáno jako argument funkce.
<p>V jiných souvislostech s programováním jste už možná slyšeli pojem „prvotřídní objekt“ („first-class object“). Kvůli lepší srozumitelnosti mu říkejme (opisem) <em>plnohodnotný objekt</em>. V jazyce Python je <i>plnohodnotným objektem</i> i funkce. Funkci můžeme předat jako argument jiné funkci. Moduly jsou rovněž <i>plnohodnotnými objekty</i>. Funkci můžeme předat jako argument celý modul. Třídy jsou také plnohodnotné objekty a jednotlivé instance třídy jsou rovněž plnohodnotnými objekty.
<p>To je velmi důležité, takže pro případ, že by vám to na začátku párkrát uteklo, zopakuji znovu: <em>V jazyce Python je všechno objektem</em>. Řetězce jsou objekty. Seznamy jsou objekty. Funkce jsou objekty. Třídy jsou objekty. Instance tříd jsou objekty. Dokonce moduly jsou objekty.
<p class=a>&#x2042;

<h2 id=your-first-python-program-indentingcode>Odsazování kódu</h2>
<p>V jazyce Python se pro označování míst, kde kód funkce začíná a kde končí, nepoužívají slova <code>begin</code> a <code>end</code> a ani žádné složené závorky. Jediným oddělovačem těla je dvojtečka (<code>:</code>) a odsazení kódu.
<pre class=pp><code><a>def approximate_size(size, a_kilobyte_is_1024_bytes=True):  <span class=u>&#x2460;</span></a>
<a>    if size &lt; 0:                                            <span class=u>&#x2461;</span></a>
<a>        raise ValueError('number must be non-negative')     <span class=u>&#x2462;</span></a>
<a>                                                            <span class=u>&#x2463;</span></a>
    multiple = 1024 if a_kilobyte_is_1024_bytes else 1000
<a>    for suffix in SUFFIXES[multiple]:                       <span class=u>&#x2464;</span></a>
        size /= multiple
        if size &lt; multiple:
            return '{0:.1f} {1}'.format(size, suffix)

    raise ValueError('number too large')</code></pre>
<ol>
<li>Bloky kódu (bloky zdrojového textu) jsou určeny jejich odsazením. „Blokem kódu“ zde rozumím volání funkcí, příkazy <code>if</code>, cykly <code>for</code>, cykly <code>while</code> a další. Blok je zahájen odsazením (odskočením řádku vpravo) a končí předsazením (odskočením následujícího řádku vlevo). Nenajdeme zde žádné explicitní závorky nebo klíčová slova. To ale znamená, že používání bílých znaků má svůj význam a že je musíme užívat důsledně. V tomto příkladu je kód funkce odsazen o čtyři mezery. Nemusí to být zrovna čtyři mezery, ale musíme použít stejné odsazení. První řádek, který není odsazený, označuje konec funkce.
<li>V Pythonu za příkazem <code>if</code> následuje blok kódu. Pokud výraz za <code>if</code> nabývá hodnoty true, provede se následující odsazený blok. V opačném případě se provede blok za <code>else</code> (pokud je uveden). Povšimněte si, že kolem výrazu chybí závorky.
<li>Tento řádek se nachází v bloku kódu, který je uvnitř příkazu <code>if</code>. Příkaz <code>raise</code> vyvolá výjimku (typu <code>ValueError</code>), ale jen v případě, kdy platí <code>size &lt; 0</code>.
<li>Zde ještě <em>není</em> konec funkce. Zcela prázdné řádky se nepočítají. Díky nim může být kód čitelnější, ale nepovažují se za oddělovače bloků kódu. Na dalším řádku funkce pokračuje.
<li>Rovněž příkaz cyklu <code>for</code> zahajuje blok kódu. Bloky kódu se mohou skládat z mnoha řádků, ale všechny musí být odsazeny stejně. Tento cyklus <code>for</code> má blok s třemi řádky kódu. Pro víceřádkové bloky kódu se nepoužívá žádná jiná zvláštní syntaxe. Prostě odsadíme a jedeme dál.
</ol>
<p>Po počátečních protestech a sarkastických přirovnáních k Fortranu si na to zvyknete a zjistíte, jaké to má výhody. Jedna z největších výhod spočívá v tom, že všechny pythonovské programy vypadají podobně, protože odsazování je vynuceno samotným jazykem a není jen věcí stylu. Pythonovský kód napsaný někým jiným se proto snadněji čte a je srozumitelnější.
<blockquote class='note compare java'>
<p><span class="u">&#x261E;</span>Python používá k oddělování příkazů konec řádku. Oddělení bloku kódu se vyjadřuje dvojtečkou a odsazením. Jazyky <abbr>C++</abbr> a Java používají k oddělování příkazů středník a k oddělování bloku kódu složené závorky.
</blockquote>
<p class=a>&#x2042;

<h2 id=your-first-python-program-exceptions>Výjimky</h2>

<p>V jazyce Python najdete výjimky všude. Používá je prakticky každý modul standardní pythonovské knihovny a samotný Python je vyvolává při mnoha různých okolnostech. V celé této knize se s nimi budete opakovaně setkávat.

<p>Co to vlastně je výjimka? Obvykle jde o projev nějaké chyby. Vyjadřuje, že něco nedopadlo dobře. (Ne všechny výjimky jsou vyjádřením chyby. Ale v tomto okamžiku na tom nezáleží.) V některých programovacích jazycích jsme vedeni k používání návratových chybových kódů, které pak <em>kontrolujeme</em>. Python nás vede k používání výjimek, které pak <em>obsluhujeme</em>.

<p>Když se v pythonovském shellu objeví chyba, vypíše nějaké podrobnosti o výjimce a jak k ní došlo. A to je právě ono. Říkáme tomu <em>neobsloužená</em> výjimka. V okamžiku vyvolání výjimky se v okolí nenacházel žádný kód, který by si toho všímal a který by se jí zabýval. Takže výjimka probublala zpět až do horních úrovní pythonovského shellu. Ten vyplivnul nějaké ladicí informace a považoval to za vyřešené. Pokud se to stane při práci v shellu, není to žádná pohroma. Ale pokud by se to stalo u vašeho skutečného pythonovského programu, pak by za předpokladu, že výjimku nic neobsloužilo, došlo ke skřípavému zastavení jeho běhu. Možná by vám to vyhovovalo, možná ne.

<blockquote class='note compare java'>
<p><span class="u">&#x261E;</span>V Pythonu nemusí funkce deklarovat, jaké výjimky mohou vyvolat &mdash; na rozdíl od jazyka Java. Rozhodnutí o tom, jaké možné výjimky potřebujete odchytávat, záleží zcela na vás.
</blockquote>

<p>Ale výjimka nemusí vést k úplnému krachu programu. Výjimky mohou být <em>obslouženy</em>. Někdy je výjimka opravdu důsledkem chyby ve vašem programu (když se například pokoušíte použít proměnnou, která neexistuje), ale někdy je výjimka výsledkem něčeho, co se dalo předvídat. Když otvíráte soubor, nemusí třeba existovat. Když importujete modul, nemusel být nainstalován. Když se připojujete k databázi, může být nedostupná nebo k ní nemůžete přistupovat kvůli nedostatečným bezpečnostním oprávněním. Pokud víte, že na nějakém řádku může vzniknout výjimka, měli byste ji obsloužit pomocí konstrukce <code>try...except</code>.

<blockquote class='note compare java'>
<p><span class="u">&#x261E;</span>Python používá bloky <code>try...except</code> k obsluze výjimek. Příkaz <code>raise</code> používá k jejich generování. Jazyky Java a <abbr>C++</abbr> používají k obsloužení výjimek bloky <code>try...catch</code>. K jejich generování používají příkaz <code>throw</code>.
</blockquote>

<p>Funkce <code>approximate_size()</code> vyvolává výjimky ve dvou různých případech: když je zadaná velikost (<var>size</var>) větší, než pro jakou byla funkce navržena, nebo když je zadaná velikost menší než nula.

<pre class='nd pp'><code>if size &lt; 0:
    raise ValueError('number must be non-negative')</code></pre>

<p>Syntaxe pro vyvolání výjimky je poměrně jednoduchá. Použijeme příkaz <code>raise</code>, za kterým uvedeme jméno výjimky a nepovinný, pro člověka srozumitelný řetězec usnadňující ladění. Zápis se podobá volání funkce. (Ve skutečnosti jsou výjimky implementovány jako třídy. Příkaz <code>raise</code> zde vytváří instanci třídy <code>ValueError</code> a její inicializační metodě předává řetězec <code>'number must be non-negative'</code> (číslo nesmí být záporné). Ale <a href=#iterators-defining-classes>nepředbíhejme</a>!)

<blockquote class=note>
<p><span class="u">&#x261E;</span>Výjimka nemusí být obsloužena ve funkci, která ji vyvolala. Pokud ji jedna funkce neobslouží, výjimka bude předána volající funkci, pak funkci, která vyvolala zase ji a tak dále, „nahoru po zásobníku“. Pokud není výjimka obsloužena vůbec, program zhavaruje a Python vypíše „traceback“ (trasovací výpis) na standardní chybový výstup a tím to končí. Znovu opakuji, možná takové chování požadujeme. Záleží to na tom, k čemu je náš program určen.
</blockquote>

<h3 id=your-first-python-program-importerror>Obsluha chyb importu</h3>

<p>Jednou ze zabudovaných výjimek jazyka Python je <code>ImportError</code>. Ta je vyvolána v okamžiku, kdy se pokoušíme o import modulu a tato operace selže. Může k tomu dojít z různých důvodů, ale v nejjednodušším případě modul nebyl nalezen ve vaší <a href=#your-first-python-program-importsearchpath>vyhledávací cestě pro import</a>. Toho můžete využít pro zabudování nepovinných vlastností svého programu. Tak například <a href=#chapter-case-study-porting-chardet-to-python-3>knihovna <code>chardet</code></a> umožňuje autodetekci znakového kódování. Možná byste chtěli, aby váš program tuto knihovnu využil <em>v případě, že existuje</em>. Pokud ji uživatel nemá nainstalovanou, měl by program bez mrknutí oka pokračovat. Můžeme toho dosáhnout použitím bloku <code>try..except</code>.

<pre class='nd pp'><code><mark>try</mark>:
  import chardet
<mark>except</mark> ImportError:
  chardet = None</code></pre>

<p>Později můžete otestovat, zda je modul <code>chardet</code> přítomen &mdash; jednoduše, příkazem <code>if</code>:

<pre class='nd pp'><code>if chardet:
  # do something
else:
  # continue anyway</code></pre>

<p>Další běžný případ použití výjimky <code>ImportError</code> souvisí se situací, kdy dva moduly implementují společné aplikační programové rozhraní (<abbr>API</abbr>), ale jeden z nich chceme používat přednostně. (Možná je rychlejší nebo používá méně paměti.) Můžeme zkusit importovat jeden modul, ale pokud import selže, vezmeme zavděk tím druhým. Tak například <a href=#chapter-xml>kapitola o XML</a> pojednává o dvou modulech, které implementují společné rozhraní zvané <code>ElementTree</code>. Prvním z nich je <code>lxml</code>, což je modul třetí strany, který si musíte sami stáhnout a nainstalovat. Tím druhým je <code>xml.etree.ElementTree</code>, který je sice pomalejší, ale je součástí standardní knihovny jazyka Python 3.

<pre class='nd pp'><code>try:
    from lxml import etree
except ImportError:
    import xml.etree.ElementTree as etree</code></pre>

<p>Na konci bloku <code>try..except</code> máte zpřístupněný <em>některý</em> z těchto modulů a máte jej pojmenovaný <var>etree</var>. Protože oba moduly implementují stejné rozhraní (<abbr>API</abbr>), nemusíte ve zbytku svého kódu neustále testovat, který modul se vlastně naimportoval. A protože se modul, který se <em>opravdu</em> naimportoval, vždy jmenuje <var>etree</var>, nemusí být zbytek vašeho kódu zaneřáděný příkazy <code>if</code>, ve kterých se volají různě pojmenované moduly.

<p class=a>&#x2042;

<h2 id=your-first-python-program-nameerror>Volné proměnné</h2>

<p>Podívejme se znovu na následující řádek kódu funkce <code>approximate_size()</code>:

<pre class='nd pp'><code>multiple = 1024 if a_kilobyte_is_1024_bytes else 1000</code></pre>

<p>Proměnnou <var>multiple</var> (násobek) jsme nikde nedeklarovali. Pouze jsme do ní přiřadili hodnotu. To je v pořádku, protože Python vám tohle dovolí. Co už vám ale Python <em>nedovolí</em>, je pokus o odkaz na proměnnou, které nebyla nikdy přiřazena hodnota. Pokud se o to pokusíme, bude vyvolána výjimka <code>NameError</code>.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>x</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
NameError: name 'x' is not defined</samp>
<samp class=p>>>> </samp><kbd class=pp>x = 1</kbd>
<samp class=p>>>> </samp><kbd class=pp>x</kbd>
<samp class=pp>1</samp></pre>

<p>Jednoho dne za to Pythonu poděkujete.

<p class=a>&#x2042;

<h2 id=your-first-python-program-case>Vše je citlivé na velikost písmen</h2>

<p>V jazyce Python je zápis všech jmen citlivý na velikost písmen. Týká se to jmen proměnných, jmen funkcí, jmen tříd, jmen modulů, jmen výjimek. Pokud to můžete zpřístupnit, nastavit, zavolat, importovat nebo to vyvolat, je to citlivé na velikost písmen.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>an_integer = 1</kbd>
<samp class=p>>>> </samp><kbd class=pp>an_integer</kbd>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd>AN_INTEGER</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
NameError: name 'AN_INTEGER' is not defined</samp>
<samp class=p>>>> </samp><kbd>An_Integer</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
NameError: name 'An_Integer' is not defined</samp>
<samp class=p>>>> </samp><kbd>an_inteGer</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
NameError: name 'an_inteGer' is not defined</samp>
</pre>

<p>A tak dále.

<p class=a>&#x2042;

<h2 id=your-first-python-program-runningscripts>Spouštění skriptů</h2>
<aside>V Pythonu je objektem všechno.</aside>
<p>V Pythonu je objektem i modul a moduly definují několik užitečných atributů. Při psaní vašich modulů toho můžeme využít k jejich snadnému testování. Vložíme do nich speciální blok kódu, který se provede v případě, kdy pythonovský soubor spustíte z příkazového řádku. Podívejte se na poslední řádky v souboru <code>humansize.py</code>:
<pre class='nd pp'><code>
if __name__ == '__main__':
    print(approximate_size(1000000000000, False))
    print(approximate_size(1000000000000))</code></pre>
<blockquote class='note compare clang'>
<p><span class="u">&#x261E;</span>Python &mdash; stejně jako jazyk <abbr>C</abbr> &mdash; používá <code>==</code> pro porovnání a <code>=</code> pro přiřazení. Na rozdíl od jazyka <abbr>C</abbr> ale Python nepodporuje přiřazovací výraz, takže odpadá možnost nechtěného přiřazení hodnoty v situaci, kdy jste měli na mysli test na rovnost.
</blockquote>
<p>Takže čím je vlastně tento příkaz <code>if</code> zvláštní? Tak tedy, moduly jsou objekty a všechny moduly mají zabudovaný atribut <code>__name__</code>. Jeho hodnota závisí na tom, jakým způsobem modul používáte. Pokud provádíte <code>import</code> modulu, pak je v atributu <code>__name__</code> zachyceno jméno jeho souboru bez cesty do adresáře a bez přípony.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<samp class=p>>>> </samp><kbd class=pp>humansize.__name__</kbd>
<samp class=pp>'humansize'</samp></pre>
<p>Ale modul můžete spustit také přímo, jako samostatný program. V takovém případě bude <code>__name__</code> nabývat speciální přednastavené hodnoty <code>__main__</code>. Python tuto skutečnost otestuje příkazem <code>if</code>, zjistí, že výraz platí, a provede blok kódu uvnitř <code>if</code>. V našem případě se vytisknou dvě hodnoty.
<pre class='nd screen'>
<samp class=p>c:\home\diveintopython3> </samp><kbd>c:\python31\python.exe humansize.py</kbd>
<samp>1.0 TB
931.3 GiB</samp></pre>
<p>A tohle všechno dělá váš první pythonovský program!
<p class=a>&#x2042;

<h2 id=your-first-python-program-furtherreading>Přečtěte si</h2>
<ul>
<li><a href="http://www.python.org/dev/peps/pep-0257/">PEP 257: Docstring Conventions</a>. Najdete zde vysvětlení, čím se liší dobrý <code>docstring</code> od vynikajícího <code>docstring</code>u.
<li><a href="http://docs.python.org/3.1/tutorial/controlflow.html#documentation-strings">Python Tutorial: Documentation Strings</a> &mdash; dotýká se stejného tématu.
<li><a href="http://www.python.org/dev/peps/pep-0008/">PEP 8: Style Guide for Python Code</a> pojednává o vhodných způsobech odsazování.
<li><a href="http://docs.python.org/3.1/reference/"><cite>Python Reference Manual</cite></a> vysvětluje co to znamená, když se řekne, že <a href="http://docs.python.org/3.1/reference/datamodel.html#objects-values-and-types">vše v Pythonu je objekt</a>, protože někteří lidé jsou <a href="http://www.douglasadams.com/dna/pedants.html">puntičkáři</a> a rádi o takových věcech dlouze diskutují.
</ul>
</div>
<div id=chapter-native-datatypes>
<h1>Přirozené datové typy</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> Wonder is the foundation of all philosophy, inquiry its progress, ignorance its end. <span class="u">&#x275E;</span><br>(Zvědavost je základem celé filozofie, hledání odpovědí na otázky ji žene vpřed, ignorance ji zabíjí.)<br>&mdash; Michel de Montaigne
</blockquote>
<p>&nbsp;
<h2 id=native-datatypes-divingin>Ponořme se</h2>
<p class=f>Datové typy. Přestaňme si na chvíli všímat <a href=#chapter-your-first-python-program>našeho prvního pythonovského programu</a> a pojďme si popovídat o datových typech. <a href=#your-first-python-program-declaringfunctions>Každá hodnota v Pythonu je určitého datového typu</a>, ale u proměnných nemusíme datový typ deklarovat. Jak to tedy funguje? Při každém přiřazení hodnoty do proměnné si Python zjistí, jakého typu hodnota je, a vnitřně si to eviduje.
<p>Python používá mnoho přirozených datových typů (ve smyslu „přirozených pro Python“). Uveďme zde ty hlavní:
<ol>
<li><b>Boolean</b> (booleovský typ) nabývá buď hodnoty <code>True</code> nebo <code>False</code>.
<li><b>Čísla</b> mohou být celá (integer; <code>1</code> a <code>2</code>), reálná (float; <code>1.1</code> a <code>1.2</code>), zlomky (fraction; <code>1/2</code> and <code>2/3</code>), nebo dokonce <a href="http://en.wikipedia.org/wiki/Complex_number">čísla komplexní</a>.
<li><b>Řetězce</b> jsou posloupnosti Unicode znaků. Tuto podobu může mít například <abbr>HTML</abbr> dokument.
<li><b>Bajty</b> a <b>pole bajtů</b>, například soubor s obrázkem ve formátu <abbr>JPEG</abbr>.
<li><b>Seznamy</b> jsou uspořádané posloupnosti hodnot.
<li><b>N-tice</b> jsou uspořádané, neměnné posloupnosti hodnot.
<li><b>Množiny</b> jsou neuspořádané kolekce hodnot.
<li><b>Slovníky</b> jsou neuspořádané kolekce dvojic klíč-hodnota.
</ol>
<p>Těch typů je samozřejmě víc. V Pythonu <a href=#your-first-python-program-everythingisanobject>je vše objektem</a>, proto musí existovat také typy jako <i>modul</i>, <i>funkce</i>, <i>třída</i>, <i>metoda</i>, <i>soubor</i>, a dokonce <i>přeložený kód</i>. S některými z nich už jsme se setkali: <a href=#your-first-python-program-runningscripts>moduly mají jména</a>, <a href=#your-first-python-program-docstrings>funkce mají <code>docstring</code></a> atd. O třídách se dozvíte v kapitole <a href=#chapter-iterators>Třídy a iterátory</a>, o souborech v kapitole <a href=#chapter-files>Soubory</a>.
<p>Řetězce a bajty jsou důležité do té míry&nbsp;&mdash;&nbsp;a jsou také dost komplikované&nbsp;&mdash;, že jim je věnována <a href=#chapter-strings>samostatná kapitola</a>. Nejdříve se podívejme na ty zbývající.
<p class=a>&#x2042;

<h2 id=native-datatypes-booleans>Booleovský typ</h2>
<aside>V booleovském kontextu můžete použít téměř libovolný výraz.</aside>
<p>Objekt booleovského typu nabývá buď hodnoty true (pravda) nebo false (nepravda). Pro přímé přiřazení <dfn>booleovských</dfn> hodnot definuje Python dvě konstanty, příhodně pojmenované <code><dfn>True</dfn></code> a <code><dfn>False</dfn></code>. Booleovská hodnota může vzniknout také vyhodnocením výrazu. Na některých místech (jako u příkazu <code>if</code>) Python dokonce předpokládá, že se výraz vyhodnotí do podoby booleovské hodnoty. Těmto místům se říká <i>booleovský kontext</i>. V booleovském kontextu můžeme použít téměř libovolný výraz. Python se pokusí získat jeho pravdivostní hodnotu. Pravidla, podle kterých se v booleovském kontextu výsledek chápe jako pravdivý nebo nepravdivý (true nebo false), jsou pro různé datové typy různá. (Jakmile uvidíte dále v této kapitole konkrétní příklady, bude vám to dávat větší smysl.)
<p>Vezměme si například následující úryvek z <a href=#your-first-python-program-divingin><code>humansize.py</code></a>:
<pre class='nd pp'><code>if size &lt; 0:
    raise ValueError('number must be non-negative')</code></pre>
<p>Proměnná <var>size</var> obsahuje celé číslo, 0 je celé číslo a <code>&lt;</code> je číselný operátor. Výsledek výrazu <code>size &lt; 0</code> má vždy booleovskou hodnotu. V pythonovském shellu si vyzkoušejte následující:
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>size = 1</kbd>
<samp class=p>>>> </samp><kbd class=pp>size &lt; 0</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>size = 0</kbd>
<samp class=p>>>> </samp><kbd class=pp>size &lt; 0</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>size = -1</kbd>
<samp class=p>>>> </samp><kbd class=pp>size &lt; 0</kbd>
<samp class=pp>True</samp></pre>
<p>V důsledku problematického dědictví z Pythonu 2 se s booleovskými hodnotami může zacházet jako s čísly. <code>True</code> je <code>1</code>; <code>False</code> je 0.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>True + True</kbd>
<samp class=pp>2</samp>
<samp class=p>>>> </samp><kbd class=pp>True - False</kbd>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd class=pp>True * False</kbd>
<samp class=pp>0</samp>
<samp class=p>>>> </samp><kbd class=pp>True / False</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
ZeroDivisionError: int division or modulo by zero</samp></pre>
<p>Ajajaj! Takové věci nedělejte. Zapomeňte, že jsem se o tom vůbec zmínil.

<p class=a>&#x2042;

<h2 id=native-datatypes-numbers>Čísla</h2>
<p>Čísla jsou obdivuhodná. Můžete si je vybrat z tak ohromného množství. Python podporuje jak <dfn>celá čísla</dfn> (integer), tak čísla <dfn>reálná</dfn> (floating point). Nerozlišují se deklarací datového typu. Python je od sebe poznává podle přítomnosti nebo nepřítomnosti <dfn>desetinné tečky</dfn>.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>type(1)</kbd>                 <span class=u>&#x2460;</span></a>
<samp class=pp>&lt;class 'int'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>isinstance(1, int)</kbd>      <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>1 + 1</kbd>                   <span class=u>&#x2462;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>1 + 1.0</kbd>                 <span class=u>&#x2463;</span></a>
<samp class=pp>2.0</samp>
<samp class=p>>>> </samp><kbd class=pp>type(2.0)</kbd>
<samp class=pp>&lt;class 'float'></samp></pre>
<ol>
<li>Pro ověření typu libovolné hodnoty nebo proměnné můžeme použít funkci <code>type()</code>. Jak se dalo čekat, hodnota <code>1</code> je typu <code>int</code>.
<li>Podobně můžeme voláním funkce <code>isinstance()</code> ověřit, zda hodnota či proměnná odpovídá zadanému typu.
<li>Přidáním <code>int</code> k <code>int</code> vzniká výsledek typu <code>int</code>.
<li>Přidáním <code>int</code> k <code>float</code> vzniká výsledek typu <code>float</code>. Aby mohl Python provést sčítání, vynutí si převod typu <code>int</code> na <code>float</code>. Poté vrátí výsledek typu <code>float</code>.
</ol>
<h3 id=native-datatypes-number-coercion>Vynucení převodu celých čísel na reálná a naopak</h3>
<p>Jak jste zrovna viděli, některé operátory (například sčítání) mohou podle potřeby vynutit převod celého čísla na číslo reálné. Ale k převodu je můžete donutit taky vy sami.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>float(2)</kbd>                <span class=u>&#x2460;</span></a>
<samp class=pp>2.0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>int(2.0)</kbd>                <span class=u>&#x2461;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>int(2.5)</kbd>                <span class=u>&#x2462;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>int(-2.5)</kbd>               <span class=u>&#x2463;</span></a>
<samp class=pp>-2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>1.12345678901234567890</kbd>  <span class=u>&#x2464;</span></a>
<samp class=pp>1.1234567890123457</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(1000000000000000)</kbd>  <span class=u>&#x2465;</span></a>
<samp class=pp>&lt;class 'int'></samp></pre>
<ol>
<li>Voláním funkce <code>float()</code> můžeme explicitně vynutit převod <code>int</code> (typ pro celé číslo) na <code>float</code> (typ pro reálné číslo).
<li>A nebude asi moc překvapivé, že voláním <code>int()</code> můžeme vynutit převod <code>float</code> na <code>int</code>.
<li>Funkce <code>int()</code> nezaokrouhluje, ale odsekává.
<li>Funkce <code>int()</code> odsekává desetinnou část u záporných čísel směrem k nule. Jde o funkci opravdového odsekávání, ne o funkci <code>floor</code> (tj. u záporných čísel dojde ke zvětšení čísla, protože například <code>&ndash;2.5</code> se změní na <code>&ndash;2</code>).
<li>Čísla typu <code>float</code> jsou uložena s přesností na 15 desetinných míst.
<li>Celá čísla mohou být libovolně velká.
</ol>
<blockquote class='note compare python2'>
<p><span class="u">&#x261E;</span>Python 2 měl oddělené typy <code>int</code> a <code>long</code>. Datový typ <code>int</code> byl omezen konstantou <code>sys.maxint</code>, která byla platformově závislá, ale obvykle nabývala hodnoty <code>2<sup>32</sup>-1</code>. Python 3 má pouze jeden celočíselný typ, který se chová většinou jako původní typ <code>long</code> z Pythonu 2. Detaily naleznete v <a href="http://www.python.org/dev/peps/pep-0237"><abbr>PEP</abbr> 237</a>.
</blockquote>
<h3 id=native-datatypes-common-numerical-operations>Běžné operace s čísly</h3>
<p>S čísly můžete dělat všechno možné.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>11 / 2</kbd>      <span class=u>&#x2460;</span></a>
<samp class=pp>5.5</samp>
<a><samp class=p>>>> </samp><kbd class=pp>11 // 2</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>5</samp>
<a><samp class=p>>>> </samp><kbd class=pp>&minus;11 // 2</kbd>    <span class=u>&#x2462;</span></a>
<samp class=pp>&minus;6</samp>
<a><samp class=p>>>> </samp><kbd class=pp>11.0 // 2</kbd>   <span class=u>&#x2463;</span></a>
<samp class=pp>5.0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>11 ** 2</kbd>     <span class=u>&#x2464;</span></a>
<samp class=pp>121</samp>
<a><samp class=p>>>> </samp><kbd class=pp>11 % 2</kbd>      <span class=u>&#x2465;</span></a>
<samp class=pp>1</samp>
</pre>
<ol>
<li>Operátor <code>/</code> provádí dělení. Vrací výsledek typu <code>float</code> dokonce i v případě, že činitel i jmenovatel jsou typu <code>int</code>.
<li>Operátor <code>//</code> provádí svým způsobem podivné celočíselné dělení. Pokud je výsledek kladný, můžete o něm uvažovat, že vznikl odseknutím desetinných míst (tedy nikoliv zaokrouhlením). Ale pozor na to.
<li>Při celočíselném dělení záporných čísel provede operátor <code>//</code> zaokrouhlení „nahoru“ k nejbližšímu celému číslu. Z matematického hlediska zaokrouhluje „dolů“, protože <code>−6</code> je menší než <code>−5</code>. Ale pokud byste očekávali, že dojde k odseknutí na <code>−5</code>, tak byste se nachytali.
<li>Operátor <code>//</code> nevrací celé číslo vždy. Pokud je čitatel nebo jmenovatel typu <code>float</code>, bude výsledek sice opět zaokrouhlen na celé číslo, ale výsledná hodnota bude typu <code>float</code>.
<li>Operátor <code>**</code> znamená „umocněno na“. <code>11<sup>2</sup></code> je <code>121</code>.
<li>Operátor <code>%</code> vrací zbytek po celočíselném dělení. <code>11</code> děleno <code>2</code> je <code>5</code> a zbytek je <code>1</code>. Takže výsledkem bude <code>1</code>.
</ol>
<blockquote class='note compare python2'>
<p><span class="u">&#x261E;</span>V Pythonu 2 obvykle operátor <code>/</code> prováděl celočíselné dělení. Ale když jste ve svém kódu použili speciální direktivu, mohli jste jeho význam přepnout na reálné dělení. V Pythonu 3 operátor <code>/</code> vyjadřuje vždy dělení s reálným výsledkem (floating point division). Na detaily se podívejte do <a href="http://www.python.org/dev/peps/pep-0238/"><abbr>PEP</abbr> 238</a>.
</blockquote>
<h3 id=native-datatypes-fractions>Zlomky</h3>
<p>Python vás neomezuje jen na celá a reálná čísla. Zvládne celou tu fantastickou matiku, kterou jste se učili na střední škole a rychle jste ji zapomněli.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import fractions</kbd>              <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>x = fractions.Fraction(1, 3)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>x</kbd>
<samp class=pp>Fraction(1, 3)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>x * 2</kbd>                         <span class=u>&#x2462;</span></a>
<samp class=pp>Fraction(2, 3)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>fractions.Fraction(6, 4)</kbd>      <span class=u>&#x2463;</span></a>
<samp class=pp>Fraction(3, 2)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>fractions.Fraction(0, 0)</kbd>      <span class=u>&#x2464;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "fractions.py", line 96, in __new__
    raise ZeroDivisionError('Fraction(%s, 0)' % numerator)
ZeroDivisionError: Fraction(0, 0)</samp></pre>
<ol>
<li>Používání zlomků zahájíme importem modulu <code>fractions</code>.
<li>Zlomek definujeme tak, že vytvoříme objekt třídy <code>Fraction</code> a předáme mu čitatele a jmenovatele.
<li>Se zlomky můžeme provádět obvyklé matematické operace. Ty vracejí nový objekt třídy <code>Fraction</code>. <code>2 * (1/3) = (2/3)</code>
<li>Objekt třídy <code>Fraction</code> zlomky automaticky krátí. <code>(6/4) = (3/2)</code>
<li>Python má dost rozumu na to, aby nevytvořil zlomek s nulovým jmenovatelem.
</ol>
<h3 id=native-datatypes-trig>Trigonometrie</h3>
<p>Python zvládne i základy trigonometrie.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import math</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>math.pi</kbd>                <span class=u>&#x2460;</span></a>
<samp class=pp>3.1415926535897931</samp>
<a><samp class=p>>>> </samp><kbd class=pp>math.sin(math.pi / 2)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>1.0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>math.tan(math.pi / 4)</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>0.99999999999999989</samp></pre>
<ol>
<li>Modul <code>math</code> definuje konstantu π, čili poměr mezi obvodem kružnice a jejím průměrem.
<li>Modul <code>math</code> zvládá všechny základní trigonometrické funkce včetně <code>sin()</code>, <code>cos()</code>, <code>tan()</code> a varianty jako <code>asin()</code>.
<li>Ale pozor na to, že Python neoplývá nekonečnou přesností. Funkce <code>tan(π / 4)</code> by měla vrátit <code>1.0</code> a ne <code>0.99999999999999989</code>.
</ol>
<h3 id=native-datatypes-numbers-in-a-boolean-context>Čísla v booleovském kontextu</h3>
<aside>Nulová hodnota se interpretuje jako false, nenulová jako true.</aside>
<p>Čísla můžete použít <a href=#native-datatypes-booleans>v booleovském kontextu</a> &mdash; například v příkazu <code>if</code>. Nulové hodnoty se interpretují jako false, nenulové jako true.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>def is_it_true(anything):</kbd>             <span class=u>&#x2460;</span></a>
<samp class=p>... </samp><kbd class=pp>  if anything:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("yes, it's true")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("no, it's false")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(1)</kbd>                         <span class=u>&#x2461;</span></a>
<samp>yes, it's true</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(-1)</kbd>
<samp>yes, it's true</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(0)</kbd>
<samp>no, it's false</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(0.1)</kbd>                       <span class=u>&#x2462;</span></a>
<samp>yes, it's true</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(0.0)</kbd>
<samp>no, it's false</samp>
<samp class=p>>>> </samp><kbd class=pp>import fractions</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(fractions.Fraction(1, 2))</kbd>  <span class=u>&#x2463;</span></a>
<samp>yes, it's true</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(fractions.Fraction(0, 1))</kbd>
<samp>no, it's false</samp></pre>
<ol>
<li>A to víte, že své vlastní funkce můžete definovat i v pythonovském interaktivním shellu? Stačí zmáčknout <kbd>ENTER</kbd> na konci každého řádku a vše ukončit stiskem <kbd>ENTER</kbd> na prázdném řádku.
<li>V booleovském kontextu se nenulová celá čísla chápou jako true a nula jako false.
<li>Nenulová reálná čísla se chápou jako true, <code>0.0</code> se chápe jako false. Ale bacha na tu poslední hodnotu! Pokud dojde k sebemenší zaokrouhlovací chybě (což není nemožné, jak jste si mohli všimnout v předchozí podkapitole), pak bude Python testovat místo nuly například <code>0.0000000000001</code> a vrátí hodnotu <code>True</code>.
<li>Zlomky můžeme také použít v booleovském kontextu. Hodnota <code>Fraction(0, n)</code> se pro všechny hodnoty <var>n</var> vyhodnotí jako false. Všechny ostatní zlomky se vyhodnotí jako true.
</ol>
<p class=a>&#x2042;

<h2 id=native-datatypes-lists>Seznamy</h2>
<p>Seznamy jsou v Pythonu nejpoužívanějšími datovými typy. Když řeknu „<dfn>seznam</dfn>“ (anglicky list [list]), může vás napadnout „pole, jehož velikost musím předem deklarovat, které může obsahovat jen prvky stejného typu atd.“. Tímto směrem neuvažujte. Seznamy jsou mnohem lepší.
<blockquote class='note compare perl5'>
<p><span class="u">&#x261E;</span>Pythonovský seznam se podobá poli (array) v Perl 5. Proměnné polí v jazyce Perl 5 vždycky začínají znakem <code>@</code>. Pythonovské proměnné můžou být pojmenovány zcela libovolně. Python si vnitřně eviduje jejich datový typ.
</blockquote>
<blockquote class='note compare java'>
<p><span class="u">&#x261E;</span>Pythonovský seznam má větší možnosti než pole (array) v jazyce Java. (Ačkoliv pokud je to vše, co od života očekáváte, můžete jej tímto způsobem používat.) Podobnější je mu třída <code>ArrayList</code>, která umožňuje uchovávání libovolných objektů a při přidání nových položek se může dynamicky zvětšit.
</blockquote>
<h3 id=native-datatypes-creatinglists>Vytvoření seznamu</h3>
<p>Seznam můžeme vytvořit snadno. Čárkami oddělené hodnoty uzavřeme do hranatých závorek.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'mpilgrim', 'z', 'example']</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'mpilgrim', 'z', 'example']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[0]</kbd>                                        <span class=u>&#x2461;</span></a>
<samp class=pp>'a'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[4]</kbd>                                        <span class=u>&#x2462;</span></a>
<samp class=pp>'example'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[-1]</kbd>                                       <span class=u>&#x2463;</span></a>
<samp class=pp>'example'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[-3]</kbd>                                       <span class=u>&#x2464;</span></a>
<samp class=pp>'mpilgrim'</samp></pre>
<ol>
<li>Nejdříve jsme nadefinovali seznam s pěti položkami. Všimněte si, že zachovávají své původní pořadí. Není to náhoda. Seznam je uspořádaná kolekce položek.
<li>Seznam můžeme používat jako pole s indexováním od nuly. První prvek každého neprázdného seznamu zpřístupníme vždy zápisem <code>a_list[0]</code>.
<li>Poslední prvek tohoto pětiprvkového seznamu je <code>a_list[4]</code>, protože indexování začíná nulou.
<li>Záporným indexem zpřístupňujeme položky ve směru od konce seznamu k začátku. Poslední prvek každého neprázdného seznamu zpřístupníme vždy zápisem <code>a_list[-1]</code>.
<li>Pokud se vám zdá použití záporného indexu matoucí, uvažujte o něm takto: <code>a_list[-<var>n</var>] == a_list[len(a_list) - <var>n</var>]</code>. Takže pro náš seznam pak platí <code>a_list[-3] == a_list[5 - 3] == a_list[2]</code>.
</ol>
<h3 id=native-datatypes-slicinglists>Vytváření podseznamů</h3>
<aside>a_list[0] je vždy první položkou seznamu a_list.</aside>
<p>Jakmile máme vytvořen seznam, můžeme získat jakoukoliv jeho část. Anglicky se tomu říká „<i>slicing</i> the list“, což můžeme přeložit jako „<i>vykrajování</i> ze seznamu“ nebo „výřez ze seznamu“ nebo &mdash; z pohledu abstraktního záměru &mdash; vytváření podseznamu.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'mpilgrim', 'z', 'example']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[1:3]</kbd>            <span class=u>&#x2460;</span></a>
<samp class=pp>['b', 'mpilgrim']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[1:-1]</kbd>           <span class=u>&#x2461;</span></a>
<samp class=pp>['b', 'mpilgrim', 'z']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[0:3]</kbd>            <span class=u>&#x2462;</span></a>
<samp class=pp>['a', 'b', 'mpilgrim']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[:3]</kbd>             <span class=u>&#x2463;</span></a>
<samp class=pp>['a', 'b', 'mpilgrim']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[3:]</kbd>             <span class=u>&#x2464;</span></a>
<samp class=pp>['z', 'example']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[:]</kbd>              <span class=u>&#x2465;</span></a>
<samp class=pp>['a', 'b', 'mpilgrim', 'z', 'example']</samp></pre>
<ol>
<li>Část seznamu, výřez (slice), můžeme získat zadáním dvou indexů. Návratovou hodnotou je nový seznam, který obsahuje položky od prvního indexu výřezu (v tomto případě <code>a_list[1]</code>) až po položku (ale vyjma) s druhým indexem výřezu (v našem případě <code>a_list[3]</code>).
<li>Výřez funguje i v případě, kdy je hodnota jednoho nebo obou indexů výřezu záporná. Můžete si pomoci následujícím způsobem uvažování. Když se na seznam díváme zleva doprava, pak první index výřezu určuje první položku, kterou chceme, a druhý index výřezu určuje první položku, kterou nechceme. Vrací se vše mezi tím.
<li>Seznamy se indexují od nuly, takže zápis <code>a_list[0:3]</code> vrací první tři položky seznamu počínaje položkou <code>a_list[0]</code> až po <code>a_list[3]</code> vyjma (ta už se nevrací).
<li>Pokud je levý index výřezu roven nule, můžeme nulu vynechat a Python si ji tam dosadí. Takže zápis <code>a_list[:3]</code> vede ke stejnému výsledku jako <code>a_list[0:3]</code>, protože počáteční nula se dosadí jako implicitní hodnota.
<li>Podobně, pokud by pravý index výřezu měl mít hodnotu rovnou délce seznamu, můžeme jej vynechat. Protože náš seznam má pět položek, vede zápis <code>a_list[3:]</code> ke stejnému výsledku jako <code>a_list[3:5]</code>. A najdeme zde potěšitelnou symetrii. V našem pětiprvkovém seznamu vrací zápis <code>a_list[:3]</code> první tři položky a <code>a_list[3:]</code> vrací zbývající dvě. Obecně platí, že <code>a_list[:<var>n</var>]</code> vždy vrátí prvních <var>n</var> položek a <code>a_list[<var>n</var>:]</code> vrátí zbytek &mdash; nezávisle na délce seznamu.
<li>Pokud vynecháme oba indexy výřezu, jsou ve výsledku zahrnuty všechny položky původního seznamu. Ale není to totéž jako původní proměnná <var>a_list</var>. Jde o nový seznam, který má shodou okolností stejné položky. Zápis <code>a_list[:]</code> je tedy zkratkou pro získání úplné kopie seznamu.
</ol>
<h3 id=native-datatypes-extendinglists>Přidávání položek do seznamu</h3>
<p>Položku můžeme do seznamu přidat čtyřmi způsoby.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list = a_list + [2.0, 3]</kbd>    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_list</kbd>                        <span class=u>&#x2461;</span></a>
<samp class=pp>['a', 2.0, 3]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.append(True)</kbd>           <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 2.0, 3, True]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.extend(['four', '&Omega;'])</kbd>  <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 2.0, 3, True, 'four', '&Omega;']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.insert(0, '&Omega;')</kbd>         <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['&Omega;', 'a', 2.0, 3, True, 'four', '&Omega;']</samp></pre>
<ol>
<li>Operátor <code>+</code> spojí seznamy a vytvoří nový seznam. Seznam může obsahovat libovolný počet položek. Neexistuje zde žádný limit (pouze velikost dostupné paměti). Ale co se týká paměti, měli bychom si dát pozor na to, že spojením seznamů vzniká v paměti další seznam. V našem případě je nový seznam ihned přiřazen do existující proměnné <var>a_list</var>. Takže tento řádek kódu ve skutečnosti představuje dvoufázový proces&nbsp;&mdash;&nbsp;spojení (konkatenace) a přiřazení&nbsp;&mdash;, který může u rozsáhlých seznamů (dočasně) spotřebovat velké množství paměti.
<li>Seznam může obsahovat položky libovolného datového typu a v jednom seznamu nemusí být všechny položky stejného typu. V našem případě máme seznam obsahující řetězec, reálné číslo a celé číslo.
<li>Metoda <code>append()</code> přidává jednu položku na konec seznamu. (Teď už máme v seznamu položky se <em>čtyřmi</em> rozdílnými datovými typy!)
<li>Seznamy jsou implementovány formou třídy. „Vytvoření“ seznamu tedy znamená vytvoření instance třídy. V tomto smyslu mají seznamy metody, které nad nimi pracují. Metoda <code>extend()</code> přebírá jeden argument, kterým je seznam. Každý jeho prvek připojí na konec původního seznamu (append).
<li>Metoda <code>insert()</code> vloží do seznamu jednu položku. Prvním argumentem je index první položky seznamu, která bude z této pozice odsunuta. Položky seznamu nemusí být jedinečné. Například v našem případě teď seznam obsahuje dvě samostatné položky s hodnotou <code>'Ω'</code>: první položku (<code>a_list[0]</code>) a poslední položku (<code>a_list[6]</code>).
</ol>

<blockquote class='note compare perl'>
<p><span class="u">&#x261E;</span>Volání metody <code><var>a_list</var>.insert(0, <var>value</var>)</code> se podobá použití funkce <code>unshift()</code> v jazyce Perl. Vloží prvek na začátek seznamu a index všech ostatních položek se zvýší, aby vzniklo potřebné místo.
</blockquote>

<p>Podívejme se podrobněji na rozdíly mezi <code>append()</code> a <code>extend()</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'c']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.extend(['d', 'e', 'f'])</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'c', 'd', 'e', 'f']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_list)</kbd>                     <span class=u>&#x2461;</span></a>
<samp class=pp>6</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list[-1]</kbd>
<samp class=pp>'f'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.append(['g', 'h', 'i'])</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'c', 'd', 'e', 'f', ['g', 'h', 'i']]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_list)</kbd>                     <span class=u>&#x2463;</span></a>
<samp class=pp>7</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list[-1]</kbd>
<samp class=pp>['g', 'h', 'i']</samp></pre>
<ol>
<li>Metoda <code>extend()</code> přebírá jeden argument, kterým je vždy seznam, a přidá každý jeho prvek do seznamu <var>a_list</var>.
<li>Pokud začnete se seznamem o třech položkách a rozšíříte jej voláním <code>extend()</code> o seznam s dalšími třemi položkami, dostanete seznam s šesti položkami.
<li>Ve srovnání s tím metoda <code>append()</code> přebírá jeden argument, který může být libovolného datového typu. Na tomto řádku předáváme metodě <code>append()</code> seznam s třemi položkami.
<li>Pokud jsme začali se seznamem o šesti položkách a předaný seznam připojíme na konec, dostaneme seznam se sedmi položkami. Proč se sedmi? Protože poslední položkou (kterou jsme právě připojili) je <em>celý seznam</em>. Seznam může obsahovat data libovolného typu, včetně seznamu. Může to být právě to, co jste chtěli. Nebo možná nechtěli. Každopádně jste si o to řekli, a proto jste to dostali.
</ol>
<h3 id=native-datatypes-searchinglists>Vyhledávání hodnoty v seznamu</h3>
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'new', 'mpilgrim', 'new']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.count('new')</kbd>       <span class=u>&#x2460;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'new' in a_list</kbd>           <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>'c' in a_list</kbd>
<samp class=pp>False</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.index('mpilgrim')</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>3</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.index('new')</kbd>       <span class=u>&#x2463;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.index('c')</kbd>         <span class=u>&#x2464;</span></a>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
ValueError: list.index(x): x not in list</samp></pre>
<ol>
<li>Metoda <code>count()</code> vrací počet výskytů určité hodnoty v seznamu (což se dalo čekat).
<li>Pokud se chcete dozvědět jen to, jestli nějaká hodnota v seznamu je nebo ne, pak je použití operátoru <code>in</code> o něco rychlejší než volání metody <code>count()</code>. Operátor <code>in</code> vždy vrací <code>True</code> nebo <code>False</code>. Neřekne vám, kolikrát se daná hodnota v seznamu vyskytuje.
<li>Ani operátor <code>in</code> ani metoda <code>count()</code> vám ale neřeknou, <em>kde</em> se v seznamu hodnota vyskytuje. Pokud chcete zjistit, kde se hodnota v seznamu nachází, použijte metodu <code>index()</code>. Pokud neřeknete jinak, bude prohledávat celý seznam. Ale nepovinným druhým argumentem můžete zadat index (od nuly), na kterém má hledání začít. A můžeme dokonce zadat nepovinný třetí argument s indexem místa, kde má hledání skončit.
<li>Metoda <code>index()</code> najde <em>první</em> výskyt zadané hodnoty v seznamu. V tomto případě se hodnota <code>'new'</code> vyskytuje v seznamu dvakrát: <code>a_list[2]</code> a <code>a_list[4]</code>. Ale metoda <code>index()</code> vrátí jen index prvního výskytu.
<li>Co byste ale možná <em>nečekali</em>, je to, že v případě nenalezení hodnoty v seznamu vyvolá metoda <code>index()</code> výjimku.
</ol>

<p>Počkat! Co? Je to tak. Pokud metoda <code>index()</code> nenajde v seznamu zadanou hodnotu, vyvolá výjimku. Jde o zjevně odlišné chování ve srovnání s jinými jazyky, které vracejí nějakou neplatnou hodnotu indexu (jako například <code>-1</code>). Ze začátku se vám to může zdát protivné, ale myslím, že to časem oceníte. Znamená to, že program zhavaruje v místě vzniku problému místo toho, aby potichu a divně selhal o chvíli později. Vzpomeňte si, že hodnota <a href=#native-datatypes-creatinglists><code>-1</code> je platným indexem prvku v seznamu</a>. Kdyby metoda <code>index()</code> místo výjimky vracela hodnotu <code>-1</code>, mohlo by to vést k poměrně nezábavným zážitkům při ladění.

<h3 id=native-datatypes-removingfromlists>Odstraňování položek ze seznamu</h3>

<aside>V seznamech nikdy nevznikají díry.</aside>

<p>Seznamy se mohou automaticky nafukovat a smršťovat. Jejich expanzi už jsme si ukázali. Odstraňování položek ze seznamu můžeme také provést několika způsoby.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'new', 'mpilgrim', 'new']</kbd>
<samp class=p>>>> </samp><kbd class=pp>a_list[1]</kbd>
<samp class=pp>'b'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>del a_list[1]</kbd>         <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'new', 'mpilgrim', 'new']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[1]</kbd>             <span class=u>&#x2461;</span></a>
<samp class=pp>'new'</samp></pre>
<ol>
<li>Pro odstranění určené položky ze seznamu můžeme použít příkaz <code><dfn>del</dfn></code>.
<li>Pokud se pokoušíme o přístup k položce s indexem <code>1</code> poté, co jsme položku s indexem <code>1</code> odstranili, <em>nedojde</em> k chybě. Poziční index všech položek, které následují za rušenou položkou, bude posunut tak, aby byla vzniklá mezera zaplněna.
</ol>

<p>Že neznáte ten správný poziční index? Žádný problém. Odstranění položek můžete předepsat také jejich hodnotou.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.remove('new')</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'mpilgrim', 'new']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.remove('new')</kbd>  <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'mpilgrim']</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list.remove('new')</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
ValueError: list.remove(x): x not in list</samp></pre>
<ol>
<li>K odstranění položky ze seznamu můžete použít metodu <code>remove()</code>. Metoda <code>remove()</code> přebírá zadanou <em>hodnotu</em> a odstraní ze seznamu její první výskyt. A opět. Všechny položky, které následují za rušenou položkou, budou posunuty tak, aby byla vzniklá mezera zaplněna. V seznamech nikdy nevznikají díry.
<li>Metodu <code>remove()</code> můžete volat, kdykoliv se vám to hodí. Ale pokud se pokusíte o odstranění položky s hodnotou, která se v seznamu nevyskytuje, bude vyvolána výjimka.
</ol>

<h3 id=native-datatypes-popgoestheweasel>Odstraňování položek ze seznamu: Bonusové kolo</h3>

<p>Další zajímavou metodou seznamu je <code>pop()</code>. Metoda <code>pop()</code> představuje další způsob <a href=#native-datatypes-removingfromlists>odstraňování položek ze seznamu</a>, ale s malou fintou.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'new', 'mpilgrim']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.pop()</kbd>   <span class=u>&#x2460;</span></a>
<samp class=pp>'mpilgrim'</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'new']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.pop(1)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'b'</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'new']</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list.pop()</kbd>
<samp class=pp>'new'</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list.pop()</kbd>
<samp class=pp>'a'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.pop()</kbd>   <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
IndexError: pop from empty list</samp></pre>
<ol>
<li>Pokud voláme metodu <code>pop()</code> bez argumentů, odstraní poslední položku seznamu <em>a vrátí hodnotu, která byla odstraněna</em>.
<li>Metodou <code>pop()</code> můžeme ze seznamu odstranit libovolnou položku. Jednoduše jí předáme poziční index. Odstraní požadovanou položku, posune následující položky tak, aby zaplnila mezeru, a vrátí odstraněnou hodnotu.
<li>Pokud voláme <code>pop()</code> pro prázdný seznam, vznikne výjimka.
</ol>

<blockquote class='note compare perl'>
<p><span class="u">&#x261E;</span>Volání metody seznamu <code>pop()</code> bez argumentu se podobá volání funkce <code>pop()</code> v jazyce Perl. Odstraní poslední položku seznamu a vrátí hodnotu, která byla odstraněna. V jazyce Perl existuje také funkce <code>shift()</code>, která odstraní první položku a vrátí její hodnotu. Jde o ekvivalent pythonovského volání <code><var>a_list</var>.pop(0)</code>.
</blockquote>

<h3 id=native-datatypes-lists-in-a-boolean-context>Seznamy v booleovském kontextu</h3>
<aside>Prázdné seznamy se vyhodnocují jako false, ostatní seznamy jako true.</aside>
<p>Seznam můžeme použít také <a href=#native-datatypes-booleans>v booleovském kontextu</a>, jako například v příkazu <code>if</code>.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(anything):</kbd>
<samp class=p>... </samp><kbd class=pp>  if anything:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("yes, it's true")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("no, it's false")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true([])</kbd>             <span class=u>&#x2460;</span></a>
<samp>no, it's false</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(['a'])</kbd>          <span class=u>&#x2461;</span></a>
<samp>yes, it's true</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true([False])</kbd>        <span class=u>&#x2462;</span></a>
<samp>yes, it's true</samp></pre>
<ol>
<li>Prázdný seznam se v booleovském kontextu vyhodnocuje jako false.
<li>Libovolný seznam, který obsahuje aspoň jednu položku, se vyhodnocuje jako true.
<li>Libovolný neprázdný seznam se vyhodnocuje jako true. Hodnota položek je nepodstatná.
</ol>

<p class=a>&#x2042;

<h2 id=native-datatypes-tuples>N-tice</h2>

<p><dfn>N-tice</dfn> (anglicky <dfn>tuple</dfn>) se chová jako neměnitelný seznam. Jakmile je n-tice jednou vytvořena, nedá se nijak změnit.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple = ("a", "b", "mpilgrim", "z", "example")</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_tuple</kbd>
<samp class=pp>('a', 'b', 'mpilgrim', 'z', 'example')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple[0]</kbd>                                        <span class=u>&#x2461;</span></a>
<samp class=pp>'a'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple[-1]</kbd>                                       <span class=u>&#x2462;</span></a>
<samp class=pp>'example'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple[1:3]</kbd>                                      <span class=u>&#x2463;</span></a>
<samp class=pp>('b', 'mpilgrim')</samp></pre>
<ol>
<li>N-tice se definuje stejným způsobem jako seznam. Jediný rozdíl spočívá v tom, že posloupnost prvků neuzavřeme do hranatých závorek, ale do kulatých.
<li>Prvky n-tice mají definované pořadí, stejně jako u seznamu. N-tice se indexují od nuly (jako seznam), takže první element neprázdné n-tice se zapisuje vždy <code>a_tuple[0]</code>.
<li>Záporné indexy se vyhodnocují od konce n-tice, stejně jako u seznamu.
<li>Dají se z nich získávat výřezy (slice), stejně jako u seznamů. Když získáte výřez se seznamu, má podobu nového seznamu. Když předepíšete výřez z n-tice, dostanete novou n-tici.
</ol>

<p>Hlavní rozdíl mezi n-ticemi a seznamy je ten, že n-tice nemohou být změněny. Z technického pohledu říkáme, že n-tice jsou <dfn>neměnitelné</dfn> (anglicky <dfn>immutable</dfn>). Prakticky se to projevuje tak, že neposkytují žádnou metodu, která by nám je dovolila změnit. Seznamy mají metody jako <code>append()</code>, <code>extend()</code>, <code>insert()</code>, <code>remove()</code> a <code>pop()</code>. N-tice žádnou z těchto metod nemají. Z n-tice můžeme vytvořit výřez (protože se vytváří nová n-tice), můžeme zjišťovat, zda n-tice obsahuje určitou hodnotu (protože tím ke změně n-tice nedochází) a&hellip; to je všechno.

<pre class=screen>
# pokračování předchozího příkladu
<samp class=p>>>> </samp><kbd class=pp>a_tuple</kbd>
<samp class=pp>('a', 'b', 'mpilgrim', 'z', 'example')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple.append("new")</kbd>               <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
AttributeError: 'tuple' object has no attribute 'append'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple.remove("z")</kbd>                 <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
AttributeError: 'tuple' object has no attribute 'remove'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple.index("example")</kbd>            <span class=u>&#x2462;</span></a>
<samp class=pp>4</samp>
<a><samp class=p>>>> </samp><kbd class=pp>"z" in a_tuple</kbd>                      <span class=u>&#x2463;</span></a>
<samp class=pp>True</samp></pre>
<ol>
<li>Do n-tice nemůžeme přidávat další prvky. N-tice nemají ani metodu <code>append()</code> ani <code>extend()</code>.
<li>Z n-tice nemůžeme prvky odstranit. N-tice nemají žádnou z metod <code>remove()</code> nebo <code>pop()</code>.
<li>V n-tici <em>můžeme</em> prvky vyhledávat, protože tím nedochází k její změně.
<li>Můžeme také použít operátor <code>in</code> pro testování, zda n-tice obsahuje zadaný prvek.
</ol>

<p>Takže na co jsou n-tice dobré?</p>

<ul>
<li>N-tice jsou rychlejší než seznamy. Pokud potřebujete nadefinovat konstantní sadu hodnot a vše, co s nimi budete kdy chtít dělat, bude jejich procházení, použijte místo seznamu n-tici.
<li>Pokud data nepotřebujete měnit a učiníte je „chráněnými proti zápisu“, bude váš kód bezpečnější. Pokud použijete místo seznamu n-tici, je to, jako kdybyste použili příkaz <code>assert</code>, který by kontroloval, zda jsou data konstantní. Překonat to můžeme jen záměrně (a s využitím specifické funkce).
<li>Některé n-tice mohou být použity jako slovníkové klíče (přesněji řečeno, n-tice, které obsahují <i>neměnitelné</i> (immutable) hodnoty jako jsou řetězce, čísla a jiné n-tice). V roli slovníkových klíčů nemůžou nikdy vystupovat seznamy, protože seznamy nejsou neměnitelné (immutable).
</ul>

<blockquote class=note>
<p><span class="u">&#x261E;</span>N-tice mohou být převedeny na seznamy a naopak. Zabudovaná funkce <code>tuple()</code> může převzít seznam a vrací n-tici se stejnými prvky. A naopak funkce <code>list()</code> může převzít zadanou n-tici a vrací seznam. Z pohledu účinku tedy funkce <code>tuple()</code> seznam zmrazí a funkce naopak <code>list()</code> rozpustí n-tici.
</blockquote>

<h3 id=native-datatypes-tuples-in-a-boolean-context>N-tice v booleovském kontextu</h3>

<p>N-tice můžeme použít <a href=#native-datatypes-booleans>v booleovském kontextu</a>, jako například v příkazu <code>if</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(anything):</kbd>
<samp class=p>... </samp><kbd class=pp>  if anything:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("yes, it's true")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("no, it's false")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(())</kbd>             <span class=u>&#x2460;</span></a>
<samp>no, it's false</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(('a', 'b'))</kbd>     <span class=u>&#x2461;</span></a>
<samp>yes, it's true</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true((False,))</kbd>       <span class=u>&#x2462;</span></a>
<samp>yes, it's true</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type((False))</kbd>              <span class=u>&#x2463;</span></a>
<samp class=pp>&lt;class 'bool'></samp>
<samp class=p>>>> </samp><kbd class=pp>type((False,))</kbd>
<samp class=pp>&lt;class 'tuple'></samp></pre>
<ol>
<li>Prázdná n-tice se v booleovském kontextu vyhodnocuje jako false.
<li>Libovolná n-tice s alespoň jednou položkou se vyhodnocuje jako true.
<li>Libovolná n-tice s alespoň jednou položkou se vyhodnocuje jako true. Hodnota položek je nepodstatná. Ale co tady dělá ta čárka?
<li>Pokud chceme vytvořit n-tici s jedinou položkou, pak musíme za hodnotu připsat čárku. Pokud bychom čárku nepřidali, Python by si myslel, že jsme jednoduše přidali nadbytečnou dvojici závorek. Je to sice neškodné, ale n-tice se tím nevytvoří.
</ol>

<h3 id=native-datatypes-multivar>Přiřazení více hodnot najednou</h3>

<p>Následuje parádní programátorská zkratka. V Pythonu můžete n-tici použít pro přiřazení více hodnot najednou.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>v = ('a', 2, True)</kbd>
<a><samp class=p>>>> </samp><kbd>(x, y, z) = v</kbd>       <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>x</kbd>
<samp class=pp>'a'</samp>
<samp class=p>>>> </samp><kbd class=pp>y</kbd>
<samp class=pp>2</samp>
<samp class=p>>>> </samp><kbd class=pp>z</kbd>
<samp class=pp>True</samp></pre>
<ol>
<li><var>v</var> je n-tice o třech prvcích a <code>(x, y, z)</code> je n-tice s třemi proměnnými. Přiřazení jedné do druhé vede k přiřazení každé z hodnot n-tice <var>v</var> do jednotlivých proměnných v uvedeném pořadí.
</ol>

<p>Využít se toho dá všemožnými způsoby. Dejme tomu, že chcete pojmenovat řadu hodnot. K rychlému přiřazení po sobě jdoucích hodnot můžete využít zabudovanou funkci <code>range()</code> a vícenásobné přiřazení.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7)</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>MONDAY</kbd>                                                                       <span class=u>&#x2461;</span></a>
<samp class=pp>0</samp>
<samp class=p>>>> </samp><kbd class=pp>TUESDAY</kbd>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd class=pp>SUNDAY</kbd>
<samp class=pp>6</samp></pre>
<ol>
<li>Zabudovaná funkce <code>range()</code> vytváří posloupnost celých čísel. (Z technického hlediska nevrací funkce <code>range()</code> seznam ani n-tici, ale <a href=#chapter-iterators>iterátor</a>. Odlišnosti se naučíme později.) <var>MONDAY</var>, <var>TUESDAY</var>, <var>WEDNESDAY</var>, <var>THURSDAY</var>, <var>FRIDAY</var>, <var>SATURDAY</var>, a <var>SUNDAY</var> jsou proměnné, které definujeme. (Tento příklad pochází z modulu <code>calendar</code>, což je malý zábavný modul, který tiskne kalendář podobně jako <abbr>UNIX</abbr>ový program <code>cal</code>. Modul <code>calendar</code> definuje pro dny v týdnu celočíselné konstanty.)
<li>V tomto okamžiku má každá z proměnných svou hodnotu: Proměnná <var>MONDAY</var> je rovna <code>0</code>, <var>TUESDAY</var> má hodnotu <code>1</code> a tak dále.
</ol>

<p>Současného přiřazení více proměnným můžeme využít také pro vytváření funkcí, které vracejí více hodnot najednou. Jednoduše v nich vrátíme n-tici se všemi požadovanými hodnotami. Ve volajícím kódu se k výsledku můžeme chovat jako k jedné n-tici, nebo jej můžeme přiřadit do více jednotlivých proměnných. Tento obrat používá řada standardních pythonovských knihoven, včetně modulu <code>os</code>. O něm si něco řekneme <a href=#comprehensions-os>v následující kapitole</a>.

<p class=a>&#x2042;

<h2 id=native-datatypes-sets>Množiny</h2>

<p><dfn>Množina</dfn> (set) je neuspořádanou kolekcí jedinečných hodnot. Jedna množina může obsahovat hodnoty libovolného neměnitelného (immutable) datového typu. Pokud máme k dispozici dvě množiny, můžeme s nimi provádět standardní množinové operace, jako je sjednocení, průnik a rozdíl množin.

<h3 id=native-datatypes-creating-a-set>Vytvoření množiny</h3>

<p>Ale nejdříve proberme základy. Množinu vytvoříme snadno.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_set = {1}</kbd>     <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(a_set)</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;class 'set'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set = {1, 2}</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2}</samp></pre>
<ol>
<li>Pokud chceme vytvořit množinu s jednou hodnotou, uzavřeme hodnotu do složených závorek (<code>{}</code>).
<li>Množiny jsou ve skutečnosti implementovány jako <a href=#iterators-defining-classes>třídy</a>, ale tím se teď nebudeme zatěžovat.
<li>Pokud chceme vytvořit množinu s více hodnotami, oddělíme hodnoty čárkami a vše uzavřeme do složených závorek.
</ol>

<p>Množinu můžeme vytvořit i ze <a href=#native-datatypes-lists>seznamu</a>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'mpilgrim', True, False, 42]</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set = set(a_list)</kbd>                           <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_set</kbd>                                         <span class=u>&#x2461;</span></a>
<samp class=pp>{'a', False, 'b', True, 'mpilgrim', 42}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list</kbd>                                        <span class=u>&#x2462;</span></a>
<samp class=pp>['a', 'b', 'mpilgrim', True, False, 42]</samp></pre>
<ol>
<li>K vytvoření množiny ze seznamu použijeme funkce <code>set()</code>. (Puntičkáři, kteří vědí, jak jsou množiny implementovány, by zde podotkli, že ve skutečnosti nejde o volání funkce, ale o vytváření instance třídy. Já vám <em>slibuji</em>, že se o tomto rozdílu dozvíte v této knize později. Prozatím nám bude stačit vědět, že <code>set()</code> se chová jako funkce a že vrací množinu.)
<li>Jak už jsem se zmínil dříve, jedna množina může obsahovat hodnoty libovolného datového typu. A zmínil jsem se také, že množiny jsou <em>neuspořádané</em>. Tato množina si nepamatuje původní pořadí prvků v seznamu, který byl použit k jejímu vytvoření. Pokud byste do množiny přidávali další prvky, nebude si množina pamatovat pořadí, v jakém jste je vkládali.
<li>Původní seznam zůstává nezměněn.
</ol>

<p id=native-datatypes-emptyset>Že zatím nemáte k dispozici žádné hodnoty? Žádný problém. Můžeme vytvořit prázdnou množinu.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_set = set()</kbd>    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_set</kbd>            <span class=u>&#x2461;</span></a>
<samp class=pp>set()</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(a_set)</kbd>      <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;class 'set'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_set)</kbd>       <span class=u>&#x2463;</span></a>
<samp class=pp>0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>not_sure = {}</kbd>    <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>type(not_sure)</kbd>
<samp class=pp>&lt;class 'dict'></samp></pre>
<ol>
<li>K vytvoření prázdné množiny zavoláme <code>set()</code> bez argumentů.
<li>Zobrazená reprezentace prázdné množiny vypadá trochu divně. Očekávali jste spíš něco jako <code>{}</code>? Tímto způsobem se vyjadřuje prázdný slovník a ne množina. O slovnících se dozvíme později, ale ještě v této kapitole.
<li>Navzdory podivnosti zobrazené reprezentace to skutečně <em>je</em> množina...
<li>...a tato množina neobsahuje žádné prvky.
<li>Prázdnou množinu nelze vytvořit zápisem dvou složených závorek kvůli historickým způsobům přeneseným z Pythonu 2. Tímto způsobem se vyjadřuje prázdný slovník a ne množina.
</ol>

<h3 id=native-datatypes-modifying-sets>Úprava množiny</h3>

<p>Do existující množiny můžeme přidávat hodnoty dvěma různými způsoby: metodou <code>add()</code> a metodou <code>update()</code>.\

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 2}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.add(4)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 4}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_set)</kbd>    <span class=u>&#x2461;</span></a>
<samp class=pp>3</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.add(1)</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 4}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_set)</kbd>    <span class=u>&#x2463;</span></a>
<samp class=pp>3</samp></pre>
<ol>
<li>Metoda <code>add()</code> přebírá jeden argument, který může být libovolného datového typu, a přidává zadanou hodnotu do množiny.
<li>Množina teď má tři členy.
<li>Množiny jsou kolekcemi <em>jedinečných hodnot</em>. Pokud do množiny zkusíme přidat hodnotu, která se v ní již nachází, neudělá to nic. Nevznikne chyba. Jde zkrátka o prázdnou operaci.
<li>Množina má <em>pořád</em> jen tři členy.
</ol>

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 2, 3}</kbd>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 3}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.update({2, 4, 6})</kbd>                       <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_set</kbd>                                         <span class=u>&#x2461;</span></a>
<samp class=pp>{1, 2, 3, 4, 6}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.update({3, 6, 9}, {1, 2, 3, 5, 8, 13})</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 3, 4, 5, 6, 8, 9, 13}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.update([10, 20, 30])</kbd>                    <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 3, 4, 5, 6, 8, 9, 10, 13, 20, 30}</samp></pre>
<ol>
<li>Metoda <code>update()</code> přebírá jeden argument, rovněž množinu, a přidá všechny její členy do původní množiny. Je to, jako kdybychom volali metodu <code>add()</code> pro všechny členy množiny předané argumentem.
<li>Protože cílová množina nemůže obsahovat jednu hodnotu dvakrát, duplicitní hodnoty se ignorují.
<li>Ve skutečnosti můžete metodu <code>update()</code> volat s libovolným počtem argumentů. Pokud ji zavoláte s dvěma množinami, metoda <code>update()</code> přidá všechny členy z každé z předaných množin do původní množiny (duplicitní hodnoty se přeskočí).
<li>Metoda <code>update()</code> umí zpracovat objekty různých datových typů, včetně seznamů. Pokud jí předáte seznam, pak metoda <code>update()</code> přidá do původní množiny všechny členy seznamu.
</ol>

<h3 id=native-datatypes-removing-from-sets>Odstraňování položek z množiny</h3>

<p>Jednotlivé hodnoty lze z množiny odstranit třemi způsoby. První dva, <code>discard()</code> a <code>remove()</code>, se liší v jedné malé drobnosti.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 3, 6, 10, 15, 21, 28, 36, 45}</kbd>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 3, 36, 6, 10, 45, 15, 21, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.discard(10)</kbd>                        <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 3, 36, 6, 45, 15, 21, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.discard(10)</kbd>                        <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 3, 36, 6, 45, 15, 21, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.remove(21)</kbd>                         <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 3, 36, 6, 45, 15, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.remove(21)</kbd>                         <span class=u>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
KeyError: 21</samp></pre>
<ol>
<li>Metoda <code>discard()</code> přebírá jeden argument a zadanou hodnotu odebere z množiny.
<li>Pokud metodu <code>discard()</code> voláme s hodnotou, která v množině neexistuje, neprovede se nic. Nevznikne chyba. Jde o prázdnou operaci.
<li>Metoda <code>remove()</code> také přebírá hodnotu jediného argumentu a také odstraňuje hodnotu z množiny.
<li>Odlišnost se projeví v případě, kdy se zadaná hodnota v množině nenachází. V takovém případě metoda <code>remove()</code> vyvolá výjimku <code>KeyError</code>.
</ol>

<p>Množiny, stejně jako seznamy, podporují metodu <code>pop()</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 3, 6, 10, 15, 21, 28, 36, 45}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.pop()</kbd>                                <span class=u>&#x2460;</span></a>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd class=pp>a_set.pop()</kbd>
<samp class=pp>3</samp>
<samp class=p>>>> </samp><kbd class=pp>a_set.pop()</kbd>
<samp class=pp>36</samp>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{6, 10, 45, 15, 21, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.clear()</kbd>                              <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>set()</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.pop()</kbd>                                <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
KeyError: 'pop from an empty set'</samp></pre>
<ol>
<li>Metoda <code>pop()</code> odstraní jeden prvek z množiny a vrátí jeho hodnotu. Ale množiny jsou neuspořádané a neexistuje u nich nic takového jako „poslední“ hodnota. Proto také neexistuje možnost ovlivnit, která hodnota bude odstraněna. Je to zcela náhodné.
<li>Metoda <code>clear()</code> odstraní <em>všechny</em> prvky množiny a množina se stane prázdnou. Ve výsledku je to stejné jako provedení příkazu <code>a_set = set()</code>, který vytvoří novou prázdnou množinu a přepíše původní hodnotu proměnné <var>a_set</var>.
<li>Pokus o volání metody <code>pop()</code> pro prázdnou množinu vede k vyvolání výjimky <code>KeyError</code>.
</ol>

<h3 id=native-datatypes-common-set-operations>Běžné množinové operace</h3>

<p>Pythonovský datový typ <code>set</code> podporuje několik běžných množinových operací.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {2, 4, 5, 9, 12, 21, 30, 51, 76, 127, 195}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>30 in a_set</kbd>                                                     <span class=u>&#x2460;</span></a>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>31 in a_set</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>b_set = {1, 2, 3, 5, 6, 8, 9, 12, 15, 17, 18, 21}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.union(b_set)</kbd>                                              <span class=u>&#x2461;</span></a>
<samp class=pp>{1, 2, 195, 4, 5, 6, 8, 12, 76, 15, 17, 18, 3, 21, 30, 51, 9, 127}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.intersection(b_set)</kbd>                                       <span class=u>&#x2462;</span></a>
<samp class=pp>{9, 2, 12, 5, 21}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.difference(b_set)</kbd>                                         <span class=u>&#x2463;</span></a>
<samp class=pp>{195, 4, 76, 51, 30, 127}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.symmetric_difference(b_set)</kbd>                               <span class=u>&#x2464;</span></a>
<samp class=pp>{1, 3, 4, 6, 8, 76, 15, 17, 18, 195, 127, 30, 51}</samp></pre>
<ol>
<li>Pokud chceme otestovat, zda je daná hodnota prvkem množiny, použijeme operátor <code>in</code>. Funguje stejným způsobem jako u seznamů.
<li>Metoda <code>union()</code> (sjednocení) vrací novou množinu, která obsahuje všechny prvky jak z jedné, tak z druhé množiny.
<li>Metoda <code>intersection()</code> (průnik) vrací novou množinu, která obsahuje všechny prvky nacházející se v <em>obou množinách současně</em>.
<li>Metoda <code>difference()</code> (rozdíl) vrací novou množinu obsahující všechny prvky, které se nacházejí v množině <var>a_set</var>, ale nenacházejí se v množině <var>b_set</var>.
<li>Metoda <code>symmetric_difference()</code> (symetrický rozdíl) vrací novou množinu obsahující všechny prvky, které se nacházejí <em>právě v jedné</em> z množin.
</ol>

<p>Tři z těchto metod jsou symetrické.

<pre class=screen>
# pokračování předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>b_set.symmetric_difference(a_set)</kbd>                                       <span class=u>&#x2460;</span></a>
<samp class=pp>{3, 1, 195, 4, 6, 8, 76, 15, 17, 18, 51, 30, 127}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.symmetric_difference(a_set) == a_set.symmetric_difference(b_set)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.union(a_set) == a_set.union(b_set)</kbd>                                <span class=u>&#x2462;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.intersection(a_set) == a_set.intersection(b_set)</kbd>                  <span class=u>&#x2463;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.difference(a_set) == a_set.difference(b_set)</kbd>                      <span class=u>&#x2464;</span></a>
<samp class=pp>False</samp></pre>
<ol>
<li>Symetrický rozdíl množin <var>a_set</var> od <var>b_set</var> <em>vypadá</em> jinak než symetrický rozdíl množin <var>b_set</var> od <var>a_set</var>. Ale pamatujte na to, že množiny jsou neuspořádané. Jakékoliv dvě množiny, jejichž všechny hodnoty se shodují (žádná nesmí být vynechána), se považují za shodné.
<li>A přesně tento případ nastal zde. Nenechte se zmást reprezentacemi těchto množin zobrazenými pythonovským shellem. Obsahují stejné hodnoty, takže jsou shodné.
<li>Sjednocení dvou množin je také symetrické.
<li>Průnik dvou množin je rovněž symetrický.
<li>Rozdíl dvou množin symetrický není. Ono to dává smysl. Podobá se to odčítání jednoho čísla od druhého. Na pořadí operandů zde záleží.
</ol>

<p>A nakonec tu máme několik otázek, které můžeme množinám položit.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 2, 3}</kbd>
<samp class=p>>>> </samp><kbd class=pp>b_set = {1, 2, 3, 4}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.issubset(b_set)</kbd>    <span class=u>&#x2460;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.issuperset(a_set)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.add(5)</kbd>             <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set.issubset(b_set)</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>b_set.issuperset(a_set)</kbd>
<samp class=pp>False</samp></pre>
<ol>
<li>Množina <var>a_set</var> je <dfn>podmnožinou</dfn> množiny <var>b_set</var>&nbsp;&mdash;&nbsp;všechny prvky množiny <var>a_set</var> jsou současně prvky množiny <var>b_set</var>.
<li>Stejnou otázku můžeme položit obráceně. Množina <var>b_set</var> je <dfn>nadmnožinou</dfn> množiny <var>a_set</var>, protože všechny prvky množiny <var>a_set</var> jsou současně prvky množiny <var>b_set</var>.
<li>Jakmile do množiny <var>a_set</var> přidáme hodnotu, která se v množině <var>b_set</var> nenachází, oba testy vrátí hodnotu <code>False</code>.
</ol>

<h3 id=native-datatypes-sets-in-a-boolean-context>Množiny v booleovském kontextu</h3>

<p>Množiny můžeme použít <a href=#native-datatypes-booleans>v booleovském kontextu</a>, například v příkazu <code>if</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(anything):</kbd>
<samp class=p>... </samp><kbd class=pp>  if anything:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("yes, it's true")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("no, it's false")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(set())</kbd>          <span class=u>&#x2460;</span></a>
<samp>no, it's false</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true({'a'})</kbd>          <span class=u>&#x2461;</span></a>
<samp>yes, it's true</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true({False})</kbd>        <span class=u>&#x2462;</span></a>
<samp>yes, it's true</samp></pre>
<ol>
<li>Prázdná množina se v booleovském kontextu vyhodnocuje jako false.
<li>Libovolná množina s alespoň jedním prvkem se vyhodnocuje jako true.
<li>Libovolná množina s alespoň jedním prvkem se vyhodnocuje jako true. Hodnota prvků je nepodstatná.
</ol>

<p class=a>&#x2042;

<h2 id=native-datatypes-dictionaries>Slovníky</h2>

<p><dfn>Slovník</dfn> (dictionary) je neuspořádaná kolekce dvojic klíč-hodnota. Když do slovníku přidáme klíč, musíme do něj současně přidat i hodnotu, která ke klíči patří. (Hodnotu můžeme v budoucnu kdykoliv změnit.) Pythonovské slovníky jsou optimalizované pro získávání hodnoty k zadanému klíči, ale ne naopak.
<blockquote class='note compare perl5'>
<p><span class="u">&#x261E;</span>Pythonovský slovník se chová jako hash (čti [heš]; vyhledávací tabulka) v Perl 5. V jazyce Perl 5 začínají proměnné typu hash vždy znakem <code>%</code>. Pythonovské proměnné mohou být pojmenovány zcela libovolně. Python si vnitřně eviduje jejich datový typ.
</blockquote>
<h3 id=native-datatypes-creating-dictionaries>Vytvoření slovníku</h3>
<p>Slovník vytvoříme snadno. Syntaxe se podobá <a href=#native-datatypes-sets>množinové</a>, ale místo pouhé hodnoty zadáváme dvojice klíč-hodnota. Jakmile slovník existuje, můžeme v něm vyhledávat hodnoty podle jejich klíče.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict = {'server': 'db.diveintopython3.org', 'database': 'mysql'}</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'server': 'db.diveintopython3.org', 'database': 'mysql'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['server']</kbd>                                                    <span class=u>&#x2461;</span></a>
'db.diveintopython3.org'
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['database']</kbd>                                                  <span class=u>&#x2462;</span></a>
'mysql'
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['db.diveintopython3.org']</kbd>                                    <span class=u>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
KeyError: 'db.diveintopython3.org'</samp></pre>
<ol>
<li>Nejdříve vytvoříme slovník s dvěma položkami a přiřadíme ho do proměnné <var>a_dict</var>. Každá položka je tvořena dvojicí klíč-hodnota a celý výčet položek je uzavřen ve složených závorkách.
<li>Řetězec <code>'server'</code> je zde klíčem a k němu přidruženou hodnotou, na kterou se odkážeme zápisem <code>a_dict['server']</code>, je <code>'db.diveintopython3.org'</code>.
<li>Řetězec <code>'database'</code> je zde klíčem. K němu přidruženou hodnotou, na kterou se odkážeme zápisem <code>a_dict['database']</code>, je <code>'mysql'</code>.
<li>Hodnoty můžeme získat na základě klíče, ale klíče nemůžeme získat na základě znalosti hodnoty. Takže <code>a_dict['server']</code> obsahuje <code>'db.diveintopython3.org'</code>, ale <code>a_dict['db.diveintopython3.org']</code> vyvolá výjimku, protože <code>'db.diveintopython3.org'</code> není klíčem.
</ol>
<h3 id=native-datatypes-modifying-dictionaries>Úprava slovníku</h3>
<p>Slovníky nemají žádné předem určené omezení velikosti. Dvojici klíč-hodnota můžeme do slovníku přidat kdykoliv. Nebo můžeme měnit hodnotu příslušející ke klíči. Pokračování předchozího příkladu:
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'server': 'db.diveintopython3.org', 'database': 'mysql'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['database'] = 'blog'</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'server': 'db.diveintopython3.org', 'database': 'blog'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['user'] = 'mark'</kbd>      <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>                       <span class=u>&#x2462;</span></a>
<samp class=pp>{'server': 'db.diveintopython3.org', 'user': 'mark', 'database': 'blog'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['user'] = 'dora'</kbd>      <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'server': 'db.diveintopython3.org', 'user': 'dora', 'database': 'blog'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['User'] = 'mark'</kbd>      <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'User': 'mark', 'server': 'db.diveintopython3.org', 'user': 'dora', 'database': 'blog'}</samp></pre>
<ol>
<li>Ve slovníku se nemohou nacházet duplicitní klíče. Pokud přiřadíme hodnotu k existujícímu klíči, dojde k přepsání původní hodnoty.
<li>Dvojici klíč-hodnota můžeme přidat kdykoliv. Tato syntaxe se shoduje s případem změny existujících hodnot.
<li>Nová položka slovníku (klíč <code>'user'</code>, hodnota <code>'mark'</code>) se objevila uprostřed. To, že se u prvního příkladu položky objevily seřazené, byla pouhá náhoda. Stejná náhoda je to, že se nyní jeví jako rozházené.
<li>Přiřazení hodnoty k existujícímu klíči slovníku vede k prosté náhradě staré hodnoty novou.
<li>Změní se tímto příkazem hodnota klíče <code>user</code> zpět na „mark“? Nikoliv! Prohlédněte si klíč pořádně. V řetězci <kbd>User</kbd> je napsáno velké <kbd>U</kbd>. Klíče slovníků jsou citlivé na velikost písmen, takže tento příkaz vytváří novou dvojici klíč-hodnota a existující hodnotu nepřepíše. Klíč se vám sice může zdát podobný, ale z pohledu Pythonu je úplně jiný.
</ol>
<h3 id=native-datatypes-mixed-value-dictionaries>Slovníky se smíšeným obsahem</h3>
<p>Slovníky nejsou určeny jen pro řetězce. Hodnoty ve slovníku mohou být libovolného datového typu včetně celých čísel, booleovských hodnot, libovolných objektů nebo dokonce slovníků. Uvnitř jednoho slovníku nemusí být všechny hodnoty stejného typu. Můžeme je míchat podle potřeby. Klíče slovníků mají větší omezení, ale mohou být typu řetězec, celé číslo a několika dalších typů. Datové typy klíčů v jednom slovníku můžeme také míchat.
<p>Se slovníky s neřetězcovými klíči a hodnotami jsme se vlastně už setkali v kapitole <a href=#your-first-python-program-divingin>Váš první pythonovský program</a>.
<pre class='nd pp'><code>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}</code></pre>
<p>Teď to v interaktivním shellu rozkucháme.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],</kbd>
<samp class=p>... </samp><kbd class=pp>            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>len(SUFFIXES)</kbd>      <span class=u>&#x2460;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>1000 in SUFFIXES</kbd>   <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>SUFFIXES[1000]</kbd>     <span class=u>&#x2462;</span></a>
<samp class=pp>['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>SUFFIXES[1024]</kbd>     <span class=u>&#x2463;</span></a>
<samp class=pp>['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>SUFFIXES[1000][3]</kbd>  <span class=u>&#x2464;</span></a>
<samp class=pp>'TB'</samp></pre>
<ol>
<li>Funkce <code>len()</code>, podobně jako u <a href=#native-datatypes-lists>seznamů</a> a <a href=#native-datatypes-sets>množin</a>, vrací počet klíčů ve slovníku.
<li>A stejně jako u seznamů a množin můžeme použít operátor <code>in</code> k testování, zda je zadaný klíč ve slovníku definován.
<li>Číslo <code>1000</code> <em>je</em> klíčem ve slovníku <code>SUFFIXES</code>. Jeho hodnotou je seznam osmi položek (osmi řetězců, abychom byli přesní).
<li>A podobně i číslo <code>1024</code> je klíčem ve slovníku <code>SUFFIXES</code>. Jeho hodnotou je také seznam s osmi položkami.
<li>A protože <code>SUFFIXES[1000]</code> obsahuje seznam, můžeme jeho jednotlivé prvky zpřístupňovat prostřednictvím indexu (od nuly).
</ol>
<h3 id=native-datatypes-dictionaries-in-a-boolean-context>Slovníky v booleovském kontextu</h3>
<aside>Prázdné slovníky se vyhodnocují jako false, všechny ostatní slovníky jako true.</aside>
<p>Slovník můžeme použít <a href=#native-datatypes-booleans>v booleovském kontextu</a>, jako například v příkazu <code>if</code>.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(anything):</kbd>
<samp class=p>... </samp><kbd class=pp>  if anything:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("yes, it's true")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("no, it's false")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true({})</kbd>             <span class=u>&#x2460;</span></a>
<samp>no, it's false</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true({'a': 1})</kbd>       <span class=u>&#x2461;</span></a>
<samp>yes, it's true</samp></pre>
<ol>
<li>Prázdný slovník se v booleovském kontextu vyhodnocuje jako false.
<li>Slovník s alespoň jednou dvojicí klíč-hodnota se vyhodnocuje jako true.
</ol>
<p class=a>&#x2042;

<h2 id=native-datatypes-none><code>None</code></h2>
<p><code><dfn>None</dfn></code> [nan] je speciální pythonovskou konstantou. Vyjadřuje <dfn>žádnou</dfn> hodnotu. Ale <code>None</code> není totéž co <code>False</code>. <code>None</code> není nula. <code>None</code> není prázdný řetězec. Pokud porovnáme <code>None</code> s čímkoliv jiným než s <code>None</code>, vždycky dostaneme <code>False</code>.
<p><code>None</code> je jedinou „žádnou“ hodnotou. Má svůj vlastní datový typ (<code>NoneType</code>). Hodnotu <code>None</code> můžeme přiřadit do libovolné proměnné, ale nemůžeme vytvořit jiný objekt typu <code>NoneType</code>. Všechny proměnné, jejichž hodnota je <code>None</code>, jsou vzájemně shodné.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>type(None)</kbd>
<samp class=pp>&lt;class 'NoneType'></samp>
<samp class=p>>>> </samp><kbd class=pp>None == False</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>None == 0</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>None == ''</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>None == None</kbd>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>x = None</kbd>
<samp class=p>>>> </samp><kbd class=pp>x == None</kbd>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>y = None</kbd>
<samp class=p>>>> </samp><kbd class=pp>x == y</kbd>
<samp class=pp>True</samp>
</pre>
<h3 id=native-datatypes-none-in-a-boolean-context><code>None</code> v booleovském kontextu</h3>
<p>V <a href=#native-datatypes-booleans>booleovském kontextu</a> se <code>None</code> vyhodnocuje jako false a <code>not None</code> jako true.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(anything):</kbd>
<samp class=p>... </samp><kbd class=pp>  if anything:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("yes, it's true")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("no, it's false")</kbd>
<samp class=p>...</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(None)</kbd>
<samp>no, it's false</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(not None)</kbd>
<samp>yes, it's true</samp></pre>
<p class=a>&#x2042;

<h2 id=native-datatypes-furtherreading>Přečtěte si</h2>
<ul>
<li><a href="http://docs.python.org/3.1/library/stdtypes.html#boolean-operations-and-or-not">Boolean operations</a> (booleovské operace)
<li><a href="http://docs.python.org/3.1/library/stdtypes.html#numeric-types-int-float-long-complex">Numeric types</a> (číselné typy)
<li><a href="http://docs.python.org/3.1/library/stdtypes.html#sequence-types-str-unicode-list-tuple-buffer-xrange">Sequence types</a> (typy posloupností)
<li><a href="http://docs.python.org/3.1/library/stdtypes.html#set-types-set-frozenset">Set types</a> (množinové typy)
<li><a href="http://docs.python.org/3.1/library/stdtypes.html#mapping-types-dict">Mapping types</a> (mapovací typy, vyhledávací tabulky)
<li><a href="http://docs.python.org/3.1/library/fractions.html">modul <code>fractions</code></a> (zlomky)
<li><a href="http://docs.python.org/3.1/library/math.html">modul <code>math</code></a> (matematický)
<li><a href="http://www.python.org/dev/peps/pep-0237/"><abbr>PEP</abbr> 237: Unifying Long Integers and Integers</a> (sjednocení velkých celých čísel a celých čísel)
<li><a href="http://www.python.org/dev/peps/pep-0238/"><abbr>PEP</abbr> 238: Changing the Division Operator</a> (změna operátoru dělení)
</ul>
</div>
<div id=chapter-comprehensions>
<h1>Generátorová notace</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> Our imagination is stretched to the utmost, not, as in fiction, to imagine things which are not really there, but just to comprehend those things which are. <span class="u">&#x275E;</span><br>(Naše představivost je napjatá do krajnosti. Ne jako u fikce, abychom si představili věci, které zde nejsou, ale proto, abychom jen obsáhli věci, které jsou zde.)<br>&mdash; <a href="http://en.wikiquote.org/wiki/Richard_Feynman">Richard Feynman</a>
</blockquote>
<p>&nbsp;
<h2 id=comprehensions-divingin>Ponořme se</h2>
<p class=f>V každém programovacím jazyce najdeme určitý rys, který záměrně zjednodušuje nějakou komplikovanou věc. Pokud přicházíte se zkušenostmi z jiného jazyka, můžete to snadno přehlédnout, protože váš starý jazyk právě tu určitou věc nezjednodušoval (protože dalo práci místo toho zjednodušit něco jiného). V této kapitole se seznámíme s generátorovou notací seznamů (list comprehensions), s generátorovou notací slovníků (dictionary comprehensions) a s generátorovou notací množin (set comprehensions). Jde o tři související koncepty, jejichž jádrem je jedna velmi mocná technika. Ale nejdříve si uděláme malou odbočku ke dvěma modulům, které vám usnadní orientaci ve vašem lokálním souborovém systému.

<p class=a>&#x2042;

<h2 id=comprehensions-os>Práce se soubory a s adresáři</h2>

<p>Python 3 se dodává s modulem zvaným <code>os</code>, což je zkratka pro „operační systém“. <a href="http://docs.python.org/3.1/library/os.html">Modul <code>os</code></a> obsahuje spoustu funkcí pro získávání informací o lokálních adresářích, souborech, procesech a proměnných prostředí&nbsp;&mdash;&nbsp;a v některých případech s nimi umožňuje manipulovat. Python se snaží co nejlépe, aby pro <a href=#chapter-installing-python>všechny podporované operační systémy</a> nabízel jednotné <abbr>API</abbr> (aplikační programové rozhraní). Cílem je, aby vaše programy běžely na libovolném počítači a aby přitom obsahovaly co nejméně kódu, který by byl závislý na platformě.

<h3 id=comprehensions-getcwd>Aktuální pracovní adresář</h3>

<p>Pokud s Pythonem právě začínáte, strávíte ještě hodně času <a href=#installing-python-idle>v pythonovském shellu</a>. V celé knize se budete setkávat s příklady, jako je tento:

<ol>
<li>Importujte jeden z modulů nacházejících se <a href="examples/">v adresáři <code>examples</code></a> (příklady).
<li>Zavolejte funkci z tohoto modulu.
<li>Vysvětlete výsledky.
</ol>

<aside>Vždy existuje to, čemu se říká aktuální pracovní adresář.</aside>

<p>Pokud o aktuálním pracovním adresáři nic nevíte, pak krok 1 pravděpodobně selže a objeví se výjimka <code>ImportError</code>. Proč? Protože Python se bude po modulu dívat <a href=#your-first-python-program-importsearchpath>ve vyhledávací cestě pro import</a>, ale nenajde jej, protože adresář <code>examples</code> se v žádném adresáři z vyhledávací cesty nenachází. Aby to prošlo, můžete udělat jednu ze dvou věcí:

<ol>
<li>Adresář <code>examples</code> přidáte do vyhledávací cesty pro import.
<li>Změníte aktuální pracovní adresář na <code>examples</code>.
</ol>

<p>Aktuální pracovní adresář je neviditelný údaj, který si Python neustále udržuje v paměti. Aktuální pracovní adresář existuje vždy &mdash; ať už jste v pythonovském shellu, spouštíte svůj vlastní pythonovský skript z příkazového řádku nebo spouštíte pythonovský <abbr>CGI</abbr> skript na nějakém webovém serveru.

<p>Pro vypořádání se s aktuálním pracovním adresářem nabízí modul <code>os</code> dvě funkce.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import os</kbd>                                            <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.getcwd())</kbd>                                   <span class=u>&#x2461;</span></a>
<samp>C:\Python31</samp>
<a><samp class=p>>>> </samp><kbd class=pp>os.chdir('/Users/pilgrim/diveintopython3/examples')</kbd>  <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.getcwd())</kbd>                                   <span class=u>&#x2463;</span></a>
<samp>C:\Users\pilgrim\diveintopython3\examples</samp></pre>
<ol>
<li>Modul <code>os</code> je součástí Pythonu. Můžete jej importovat kdykoliv a kdekoliv.
<li>Informaci o aktuálním pracovním adresáři získáte použitím funkce <code>os.getcwd()</code>. Pokud používáte grafický pythonovský shell, pak se aktuální pracovní adresář zpočátku nachází v adresáři, ve kterém je umístěn spustitelný program pythonovského shellu. Při práci pod Windows to záleží na tom, kam jste Python nainstalovali. Výchozí adresář je <code>c:\Python31</code>. Pokud používáte konzolový pythonovský shell, pak se aktuální pracovní adresář zpočátku nachází v adresáři, ve kterém jste spustili <code>python3</code>.
<li>Aktuální pracovní adresář můžeme měnit použitím funkce <code>os.chdir()</code>.
<li>Při volání funkce <code>os.chdir()</code> jsem použil cestu v linuxovém stylu (normální lomítka, žádné písmeno disku), i když pracuji pod Windows. To je právě jedno z míst, kde se Python snaží zamaskovat rozdíly mezi operačními systémy.
</ol>

<h3 id=comprehensions-ospath>Práce se jmény souborů a adresářů</h3>

<p>Když už se bavíme o adresářích, chtěl bych vás upozornit na modul <code>os.path</code>. Ten obsahuje funkce pro manipulace se jmény souborů a adresářů.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.path.join('/Users/pilgrim/diveintopython3/examples/', 'humansize.py'))</kbd>              <span class=u>&#x2460;</span></a>
<samp>/Users/pilgrim/diveintopython3/examples/humansize.py</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.path.join('/Users/pilgrim/diveintopython3/examples', 'humansize.py'))</kbd>               <span class=u>&#x2461;</span></a>
<samp>/Users/pilgrim/diveintopython3/examples\humansize.py</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.path.expanduser('~'))</kbd>                                                               <span class=u>&#x2462;</span></a>
<samp>c:\Users\pilgrim</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.path.join(os.path.expanduser('~'), 'diveintopython3', 'examples', 'humansize.py'))</kbd>  <span class=u>&#x2463;</span></a>
<samp>c:\Users\pilgrim\diveintopython3\examples\humansize.py</samp></pre>
<ol>
<li>Funkce <code>os.path.join()</code> sestaví cestu z jedné nebo více částí cesty. V tomto případě jednoduše spojí řetězce.
<li>Tento příklad už není tak jednoduchý. Funkce <code>os.path.join()</code> před napojením jména souboru navíc přidá k cestě jedno lomítko. Místo obyčejného lomítka použila zpětné lomítko, protože jsem tento příklad pouštěl pod Windows. Pokud byste stejný příklad zkoušeli na systémech Linux nebo Mac OS X, použilo by se normální lomítko. Nepárejte se s lomítky. Používejte vždy <code>os.path.join()</code> a nechejte na Pythonu, aby udělal, co je správné.
<li>Funkce <code>os.path.expanduser()</code> rozepíše cestu, která pro vyjádření domácího adresáře aktuálního uživatele používá znak <code>~</code>. Funguje to na libovolné platformě, kde mají uživatelé přidělený svůj domácí adresář, tedy na Linuxu, Mac OS X a ve Windows. Vrácená cesta neobsahuje koncové lomítko, ale to funkci <code>os.path.join()</code> nevadí.
<li>Kombinováním těchto technik můžeme snadno konstruovat cesty do adresářů a k souborům, které se nacházejí v uživatelově domácím adresáři. Funkce <code>os.path.join()</code> přebírá libovolný počet argumentů. Jakmile jsem to zjistil, skákal jsem radostí, protože při přípravě mých nástrojů v nějakém novém jazyce je <code>addSlashIfNecessary()</code> (přidejLomítkoPokudJeToNutné) jednou z těch otravných malých funkcí, které si musím vždy znovu napsat. V Pythonu takovou funkci <em>nepište</em>. Chytří lidé už se o to postarali za vás.
</ol>

<p>Modul <code>os.path</code> obsahuje také funkce, které umí rozdělit plné cesty, jména adresářů a souborů na jejich podstatné části.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pathname = '/Users/pilgrim/diveintopython3/examples/humansize.py'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>os.path.split(pathname)</kbd>                                        <span class=u>&#x2460;</span></a>
<samp class=pp>('/Users/pilgrim/diveintopython3/examples', 'humansize.py')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>(dirname, filename) = os.path.split(pathname)</kbd>                  <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>dirname</kbd>                                                        <span class=u>&#x2462;</span></a>
<samp class=pp>'/Users/pilgrim/diveintopython3/examples'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>filename</kbd>                                                       <span class=u>&#x2463;</span></a>
<samp class=pp>'humansize.py'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>(shortname, extension) = os.path.splitext(filename)</kbd>            <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>shortname</kbd>
<samp class=pp>'humansize'</samp>
<samp class=p>>>> </samp><kbd class=pp>extension</kbd>
<samp class=pp>'.py'</samp></pre>
<ol>
<li>Funkce <code>split</code> rozdělí plnou cestu a vrátí n-tici, která obsahuje zvlášť cestu a zvlášť jméno souboru.
<li>Pamatujete si, že jsme se bavili o možnosti vracet více hodnot z funkce <a href=#native-datatypes-multivar>přiřazením hodnot více proměnným najednou</a>? Funkce <code>os.path.split()</code> dělá přesně tohle. Výsledek funkce <code>split</code> přiřadíme do n-tice s dvěma proměnnými. Každá z proměnných získá hodnotu odpovídajícího prvku vracené dvojice.
<li>První proměnná, <var>dirname</var>, obdrží hodnotu prvního prvku n-tice, kterou vrací funkce <code>os.path.split()</code>, a sice cestu k souboru.
<li>Druhá proměnná, <var>filename</var>, obdrží hodnotu druhého prvku n-tice vracené funkcí <code>os.path.split()</code>, jméno souboru.
<li>Modul <code>os.path</code> obsahuje také funkci <code>os.path.splitext()</code>, která rozdělí jméno souboru a vrací dvojici obsahující jméno souboru bez přípony a příponu. Pro jejich přiřazení do oddělených proměnných použijeme stejnou techniku.
</ol>

<h3 id=comprehensions-glob>Výpis adresářů</h3>

<p>Dalším nástrojem z pythonovské standardní knihovny je modul <code>glob</code>. Umožní nám z programu snadno získat obsah nějakého adresáře. Používá typ zástupných znaků (wildcards), které už asi znáte z práce na příkazovém řádku.

<aside>Modul <code>glob</code> používá shellovské zástupné znaky.</aside>

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>os.chdir('/Users/pilgrim/diveintopython3/')</kbd>
<samp class=p>>>> </samp><kbd class=pp>import glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>glob.glob('examples/*.xml')</kbd>                  <span class=u>&#x2460;</span></a>
<samp class=pp>['examples\\feed-broken.xml',
 'examples\\feed-ns0.xml',
 'examples\\feed.xml']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>os.chdir('examples/')</kbd>                        <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>glob.glob('*test*.py')</kbd>                       <span class=u>&#x2462;</span></a>
<samp class=pp>['alphameticstest.py',
 'pluraltest1.py',
 'pluraltest2.py',
 'pluraltest3.py',
 'pluraltest4.py',
 'pluraltest5.py',
 'pluraltest6.py',
 'romantest1.py',
 'romantest10.py',
 'romantest2.py',
 'romantest3.py',
 'romantest4.py',
 'romantest5.py',
 'romantest6.py',
 'romantest7.py',
 'romantest8.py',
 'romantest9.py']</samp></pre>
<ol>
<li>Modul <code>glob</code> zpracovává masku se zástupným znakem a vrací cesty ke všem souborům a adresářům, které masce se zástupným znakem odpovídají. V tomto příkladu je maska složena z cesty do adresáře a z „<code>*.xml</code>“. Budou jí odpovídat všechny <code>.xml</code> soubory v podadresáři <code>examples</code>.
<li>Teď jako aktuální pracovní adresář zvolíme podadresář <code>examples</code>. Funkce <code>os.chdir()</code> umí pracovat i s relativními cestami.
<li>Ve vzorku pro funkci <code>glob</code> můžeme použít více zástupných znaků. Tento příklad nalezne v aktuálním pracovním adresáři všechny soubory, které končí příponou <code>.py</code> a kdekoliv ve jméně souboru obsahují slovo <code>test</code>.
</ol>

<h3 id=comprehensions-osstat>Získání dalších informací o souboru</h3>

<p>Každý moderní souborový systém ukládá o každém souboru metadata, jako jsou: datum vytvoření, datum poslední modifikace, velikost souboru atd. Pro zpřístupnění těchto metadat poskytuje Python jednotné <abbr>API</abbr>. Soubor se nemusí otevírat. Vše, co potřebujete znát, je jeho jméno.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.getcwd())</kbd>                 <span class=u>&#x2460;</span></a>
<samp class=pp>c:\Users\pilgrim\diveintopython3\examples</samp>
<a><samp class=p>>>> </samp><kbd class=pp>metadata = os.stat('feed.xml')</kbd>     <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>metadata.st_mtime</kbd>                  <span class=u>&#x2462;</span></a>
<samp class=pp>1247520344.9537716</samp>
<a><samp class=p>>>> </samp><kbd class=pp>import time</kbd>                        <span class=u>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>time.localtime(metadata.st_mtime)</kbd>  <span class=u>&#x2464;</span></a>
<samp class=pp>time.struct_time(tm_year=2009, tm_mon=7, tm_mday=13, tm_hour=17,
  tm_min=25, tm_sec=44, tm_wday=0, tm_yday=194, tm_isdst=1)</samp>
</pre>
<ol>
<li>Aktuálním pracovním adresářem je složka <code>examples</code>.
<li><code>feed.xml</code> je soubor ve složce <code>examples</code>. Voláním funkce <code>os.stat()</code> získáme objekt, který obsahuje několik různých typů informací o souboru (metadat).
<li><code>st_mtime</code> zachycuje čas poslední modifikace, ale není uložen ve tvaru, který by byl moc použitelný. (Z technického pohledu je to počet sekund od Epochy, kde Epocha je definována jako první sekunda 1. ledna 1970. Vážně!)
<li>Modul <code>time</code> je součástí standardní pythonovské knihovny. Obsahuje funkce pro převody mezi různými reprezentacemi času, pro formátování času do řetězcové podoby a pro hraní si s časovými zónami.
<li>Funkce <code>time.localtime()</code> převádí hodnotu času ze sekund-od-Epochy (z položky <code>st_mtime</code> objektu vraceného funkcí <code>os.stat()</code>) na použitelnější strukturu obsahující rok, měsíc, den, hodinu, minutu, sekundu atd. Tento soubor byl naposledy změněn 13. července 2009 přibližně v 17 hodin a 25 minut.
</ol>

<pre class=screen>
# pokračování předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>metadata.st_size</kbd>                              <span class=u>&#x2460;</span></a>
<samp class=pp>3070</samp>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>humansize.approximate_size(metadata.st_size)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'3.0 KiB'</samp></pre>
<ol>
<li>Funkce <code>os.stat()</code> vrací také velikost souboru, a to v položce <code>st_size</code>. Soubor <code>feed.xml</code> obsahuje <code>3070</code> bajtů.
<li>Položku <code>st_size</code> můžeme předat <a href=#your-first-python-program-divingin>funkci <code>approximate_size()</code></a>.
</ol>

<h3 id=comprehensions-abspath>Jak vytvořit absolutní cesty</h3>

<p><a href=#comprehensions-osstat>V předcházející podkapitole</a> jsme voláním funkce <code>glob.glob()</code> získali seznam s relativními cestami. V prvním příkladu jsme získali cesty jako <code>'examples\feed.xml'</code>. V druhém příkladu jsme získali dokonce ještě kratší relativní cesty jako <code>'romantest1.py'</code>. Za předpokladu, že zůstaneme ve stejném pracovním adresáři, můžeme tyto relativní cesty používat pro otevření souborů nebo pro získávání jejich metadat. Ale pokud chceme vytvořit absolutní cestu&nbsp;&mdash;&nbsp;tj. takovou, která obsahuje jména všech adresářů až po kořenový adresář nebo včetně jména disku&nbsp;&mdash;, budeme potřebovat funkci <code>os.path.realpath()</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os</kbd>
<samp class=p>>>> </samp><kbd class=pp>print(os.getcwd())</kbd>
<samp class=pp>c:\Users\pilgrim\diveintopython3\examples</samp>
<samp class=p>>>> </samp><kbd class=pp>print(os.path.realpath('feed.xml'))</kbd>
<samp class=pp>c:\Users\pilgrim\diveintopython3\examples\feed.xml</samp></pre>

<p class=a>&#x2042;

<h2 id=comprehensions-listcomprehension>Generátorová notace seznamu</h2>

<aside>V generátorové notaci seznamu můžeme použít libovolný pythonovský výraz.</aside>

<p><dfn>Generátorová notace seznamu</dfn> (anglicky list comprehension [list komprihenšn]) umožňuje stručný zápis vytvoření seznamu z jiného seznamu aplikováním funkce na všechny prvky zdrojového seznamu. (Poznámka překladatele: Pojem „list comprehension“ je znám z deklarativních jazyků a má charakter syntaktické konstrukce. V jazyce Python se „vnitřku“ deklarativního zápisu podobá <a href=#advanced-iterators-generator-expressions>generátorový výraz</a>. Tímto způsobem byl odvozen český pojem „generátorová notace“. Někdy je pojem „list comprehension“ použit v procedurálním, dynamickém smyslu. V takové situaci můžeme uvažovat o pojmu „generátor seznamu“. Pokud se bavíme o jeho výsledku, můžeme uvažovat i o pojmu „generovaný seznam“. Vzhledem k tomu, že zavedený český pojem pro tuto konstrukci asi neexistuje &mdash; studentům příslušných oborů vysokých škol přijde po krátké chvíli anglický pojem srozumitelný &mdash;, budu volněji používat některou z uvedených variant. Někdy budu poněkud dlouhý pojem „generátorová notace seznamu“ zkracovat. Kritériem volby bude dobrá srozumitelnost.)

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = [1, 9, 8, 4]</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>[elem * 2 for elem in a_list]</kbd>           <span class=u>&#x2460;</span></a>
<samp class=pp>[2, 18, 16, 8]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list</kbd>                                  <span class=u>&#x2461;</span></a>
<samp class=pp>[1, 9, 8, 4]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list = [elem * 2 for elem in a_list]</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd>a_list</kbd>
<samp class=pp>[2, 18, 16, 8]</samp></pre>
<ol>
<li>Aby nám to začalo dávat smysl, podívejme se na zápis zprava doleva. Seznam <var>a_list</var> je zde zdrojem zobrazení. Interpret jazyka Python prochází seznam <var>a_list</var> po jednom prvku a dočasně přiřazuje jeho hodnotu do proměnné <var>elem</var>. Poté Python aplikuje funkci <code><var>elem</var> * 2</code> a připojí výsledek na konec cílového seznamu.
<li>Generátorová notace produkuje nový seznam. Původní seznam zůstává nezměněný.
<li>Výsledek generátoru seznamu můžeme bezpečně přiřadit do proměnné, která zachycovala původní seznam. Python nejdříve vytvoří nový seznam v paměti a teprve po dokončení jeho generování přiřadí výsledek do původní proměnné.
</ol>

<p>V generátorové notaci seznamu můžeme využít libovolný pythonovský výraz, včetně funkcí z modulu <code>os</code>, které slouží k manipulaci se soubory a adresáři.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>glob.glob('*.xml')</kbd>                                 <span class=u>&#x2460;</span></a>
<samp class=pp>['feed-broken.xml', 'feed-ns0.xml', 'feed.xml']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>[os.path.realpath(f) for f in glob.glob('*.xml')]</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>['c:\\Users\\pilgrim\\diveintopython3\\examples\\feed-broken.xml',
 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed-ns0.xml',
 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed.xml']</samp>
</pre>
<ol>
<li>Toto volání vrací seznam všech <code>.xml</code> souborů v aktuálním pracovním adresáři.
<li>Tato generátorová notace přebírá předchozí seznam <code>.xml</code> souborů a transformuje jej na seznam jmen s plnou cestou.
</ol>

<p>Generátorová notace seznamu může navíc předepisovat i filtraci položek. To znamená, že může vyprodukovat výsledek, který bude kratší než původní seznam.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>[f for f in glob.glob('*.py') if os.stat(f).st_size > 6000]</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>['pluraltest6.py',
 'romantest10.py',
 'romantest6.py',
 'romantest7.py',
 'romantest8.py',
 'romantest9.py']</samp>
</pre>
<ol>
<li>Filtraci seznamu provedeme vložením podmínky <code>if</code> na konec generátorové notace. Pro každou položku seznamu bude vyhodnocen výraz za klíčovým slovem <code>if</code>. Pokud je výsledkem výrazu <code>True</code>, pak bude položka zahrnuta do výstupu. Tato generátorová notace seznamu předepisuje zpracování všech souborů s příponou <code>.py</code> v aktuálním adresáři. Výraz za <code>if</code> zajišťuje filtraci seznamu testováním, zda je velikost každého souboru větší než <code>6000</code> bajtů. Takových souborů je šest, takže generátorová notace produkuje seznam se šesti jmény souborů.
</ol>

<p>Všechny předchozí příklady generátorové notace seznamu používaly jen jednoduché výrazy&nbsp;&mdash;&nbsp;násobení čísla konstantou, volání jedné funkce, nebo jednoduše vracely původní položky seznamu (po filtraci). Ale generátorová notace seznamu může být libovolně složitá.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>[(os.stat(f).st_size, os.path.realpath(f)) for f in glob.glob('*.xml')]</kbd>            <span class=u>&#x2460;</span></a>
<samp class=pp>[(3074, 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed-broken.xml'),
 (3386, 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed-ns0.xml'),
 (3070, 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed.xml')]</samp>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>[(humansize.approximate_size(os.stat(f).st_size), f) for f in glob.glob('*.xml')]</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>[('3.0 KiB', 'feed-broken.xml'),
 ('3.3 KiB', 'feed-ns0.xml'),
 ('3.0 KiB', 'feed.xml')]</samp></pre>
<ol>
<li>Tato generátorová notace nalezne v aktuálním pracovním adresáři všechny soubory s příponou <code>.xml</code>, zjistí velikost každého z nich (voláním funkce <code>os.stat()</code>) a vytvoří dvojice obsahující jméno souboru a absolutní cestu k souboru (voláním funkce <code>os.path.realpath()</code>).
<li>Tento generátorový zápis seznamu vychází z předchozího. Pro velikost každého <code>.xml</code> souboru se volá <a href=#your-first-python-program-divingin>funkce <code>approximate_size()</code></a>.
</ol>

<p class=a>&#x2042;

<h2 id=comprehensions-dictionarycomprehension>Generátorová notace slovníku</h2>

<p><dfn>Generátorová notace slovníku</dfn> (anglicky dictionary comprehension [dikšenri komprihenšn]) se podobá generátorové notaci seznamu, ale místo seznamu popisuje vytvoření slovníku.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>metadata = [(f, os.stat(f)) for f in glob.glob('*test*.py')]</kbd>    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>metadata[0]</kbd>                                                     <span class=u>&#x2461;</span></a>
<samp class=pp>('alphameticstest.py', nt.stat_result(st_mode=33206, st_ino=0, st_dev=0,
 st_nlink=0, st_uid=0, st_gid=0, st_size=2509, st_atime=1247520344,
 st_mtime=1247520344, st_ctime=1247520344))</samp>
<a><samp class=p>>>> </samp><kbd class=pp>metadata_dict = {f:os.stat(f) for f in glob.glob('*test*.py')}</kbd>  <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>type(metadata_dict)</kbd>                                             <span class=u>&#x2463;</span></a>
<samp>&lt;class 'dict'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(metadata_dict.keys())</kbd>                                      <span class=u>&#x2464;</span></a>
<samp class=pp>['romantest8.py', 'pluraltest1.py', 'pluraltest2.py', 'pluraltest5.py',
 'pluraltest6.py', 'romantest7.py', 'romantest10.py', 'romantest4.py',
 'romantest9.py', 'pluraltest3.py', 'romantest1.py', 'romantest2.py',
 'romantest3.py', 'romantest5.py', 'romantest6.py', 'alphameticstest.py',
 'pluraltest4.py']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>metadata_dict['alphameticstest.py'].st_size</kbd>                     <span class=u>&#x2465;</span></a>
<samp class=pp>2509</samp></pre>
<ol>
<li>Toto není generátorová notace slovníku, ale <a href=#comprehensions-listcomprehension>generátorová notace seznamu</a>. Nalezne všechny soubory s příponou <code>.py</code>, které ve svém jméně obsahují podřetězec <code>test</code>. Pak se vytvoří dvojice obsahující jméno souboru a jeho metadata (voláním funkce <code>os.stat()</code>).
<li>Každá položka výsledného seznamu je dvojice.
<li>Ale toto už je generátorová notace slovníku. Až na dva rozdíly se syntaxe podobá generátorové notaci seznamu. Zaprvé, místo do hranatých závorek je celá uzavřena do složených závorek. Zadruhé, pro každou položku místo jednoho výrazu obsahuje dva výrazy oddělené dvojtečkou. Výraz před dvojtečkou (v našem případě <code>f</code>) představuje klíč slovníku. Výraz za dvojtečkou (v našem případě <code>os.stat(f)</code>) je hodnota.
<li>Generátorová notace slovníku produkuje slovník.
<li>Klíče uvedeného slovníku zachycují jména souborů, která se vrátila z volání <code>glob.glob('*test*.py')</code>.
<li>Hodnotou přidruženou ke každému klíči je hodnota vrácená funkcí <code>os.stat()</code>. To znamená, že v tomto slovníku můžeme na základě jména souboru „vyhledat“ jeho metadata. Jednou z částí metadat je <code>st_size</code>, zachycující velikost souboru. Soubor <code>alphameticstest.py</code> obsahuje <code>2509</code> bajtů.
</ol>

<p>Také u generátorové notace slovníků (podobně jako u generátorové notace seznamů) můžeme přidat podmínku <code>if</code>, která zajistí filtraci vyhodnocením výrazu pro každou položku vstupní posloupnosti.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob, humansize</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>metadata_dict = {f:os.stat(f) for f in glob.glob('*')}</kbd>                                  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>humansize_dict = {os.path.splitext(f)[0]:humansize.approximate_size(meta.st_size) \     </kbd>
<samp class=p>... </samp><kbd class=pp>                  for f, meta in metadata_dict.items() if meta.st_size > 6000}</kbd>          <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>list(humansize_dict.keys())</kbd>                                                             <span class=u>&#x2462;</span></a>
<samp class=pp>['romantest9', 'romantest8', 'romantest7', 'romantest6', 'romantest10', 'pluraltest6']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>humansize_dict['romantest9']</kbd>                                                            <span class=u>&#x2463;</span></a>
<samp class=pp>'6.5 KiB'</samp></pre>
<ol>
<li>Tato generátorová notace konstruuje seznam všech souborů v aktuálním pracovním adresáři (<code>glob.glob('*')</code>), získává metadata každého souboru (<code>os.stat(f)</code>) a vytváří slovník, jehož klíči jsou jména souborů a k nim přiřazené hodnoty jsou metadata každého souboru.
<li>Tato generátorová notace vychází z předchozí. Odfiltrovává soubory menší než <code>6000</code> bajtů (<code>if meta.st_size &gt; 6000</code>) a takto přefiltrovaný seznam používá k vytvoření slovníku. Jeho klíče tvoří jména souborů bez přípony (<code>os.path.splitext(f)[0]</code>) a hodnotami jsou přibližné velikosti těchto souborů (<code>humansize.approximate_size(meta.st_size)</code>).
<li>V předchozím příkladu jsme si ukázali, že těchto souborů je šest. Z toho vyplývá, že slovník bude mít šest položek.
<li>Hodnotou každého klíče je řetězec vrácený funkcí <code>approximate_size()</code>.
</ol>

<h3 id=comprehensions-stupiddicttricks>Další legrácky s generátorovou notací slovníků</h3>

<p>Následující trik využívající generátorové notace slovníku se nám jednoho dne může hodit. Jde o vzájemnou záměnu klíčů a hodnot slovníku.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_dict = {'a': 1, 'b': 2, 'c': 3}</kbd>
<samp class=p>>>> </samp><kbd class=pp>{value:key for key, value in a_dict.items()}</kbd>
<samp class=pp>{1: 'a', 2: 'b', 3: 'c'}</samp></pre>

<p>Bude to samozřejmě fungovat jen v případě, kdy jsou hodnoty ve slovníku neměnitelného typu (immutable), jako jsou řetězce nebo n-tice. Pokud totéž zkusíte se slovníkem, který obsahuje seznamy, dojde k velkolepé havárii.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_dict = {'a': [1, 2, 3], 'b': 4, 'c': 5}</kbd>
<samp class=p>>>> </samp><kbd class=pp>{value:key for key, value in a_dict.items()}</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;stdin>", line 1, in &lt;dictcomp>
TypeError: unhashable type: 'list'</samp></pre>

<p class=a>&#x2042;

<h2 id=comprehensions-setcomprehension>Generátorová notace množin</h2>

<p>Neměli bychom opomenout, že i syntaxe pro množiny zahrnuje generátorovou notaci. Pozoruhodně se podobá syntaxi pro generátorový zápis slovníků. Jediný rozdíl spočívá v tom, že množiny mají místo párů <em>klíč: hodnota</em> jen hodnoty.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = set(range(10))</kbd>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>{x ** 2 for x in a_set}</kbd>           <span class=u>&#x2460;</span></a>
<samp class=pp>{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>{x for x in a_set if x % 2 == 0}</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>{0, 8, 2, 4, 6}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>{2**x for x in range(10)}</kbd>         <span class=u>&#x2462;</span></a>
<samp class=pp>{32, 1, 2, 4, 8, 64, 128, 256, 16, 512}</samp>
</pre>
<ol>
<li>Vstupem generátorové notace množiny může být množina. Tato generátorová notace množiny vyhodnocuje druhé mocniny prvků z množiny čísel od <code>0</code> do <code>9</code>.
<li>Generátorové notace množin (stejně jako generátorové notace seznamů a slovníků) mohou obsahovat podmínku <code>if</code>, která vstupní položky před zařazením do výsledné množiny filtruje.
<li>Vstupem generátorové notace množiny ale nemusí být množina. Může jí být jakákoliv posloupnost.
</ol>

<p class=a>&#x2042;

<h2 id=comprehensions-furtherreading>Přečtěte si</h2>
<ul>
<li><a href="http://docs.python.org/3.1/library/os.html">modul <code>os</code></a> (standardní dokumentace)
<li><a href="http://www.doughellmann.com/PyMOTW/os/"><code>os</code>&nbsp;&mdash;&nbsp;Portable access to operating system specific features</a> (přenositelné zpřístupnění specifických vlastností vázaných na operační systém)
<li><a href="http://docs.python.org/3.1/library/os.path.html">modul <code>os.path</code></a> (standardní dokumentace)
<li><a href="http://www.doughellmann.com/PyMOTW/ospath/"><code>os.path</code>&nbsp;&mdash;&nbsp;Platform-independent manipulation of file names</a> (platformově nezávislá manipulace se jmény souborů)
<li><a href="http://docs.python.org/3.1/library/glob.html">modul <code>glob</code></a> (standardní dokumentace)
<li><a href="http://www.doughellmann.com/PyMOTW/glob/"><code>glob</code>&nbsp;&mdash;&nbsp;Filename pattern matching</a> (vyhledávání souborů podle vzorků)
<li><a href="http://docs.python.org/3.1/library/time.html">modul <code>time</code></a> (standardní dokumentace)
<li><a href="http://www.doughellmann.com/PyMOTW/time/"><code>time</code>&nbsp;&mdash;&nbsp;Functions for manipulating clock time</a> (funkce pro manipulaci času hodin)
<li><a href="http://docs.python.org/3.1/tutorial/datastructures.html#list-comprehensions">List comprehensions</a> (standardní tutorial)
<li><a href="http://docs.python.org/3.1/tutorial/datastructures.html#nested-list-comprehensions">Nested list comprehensions</a> (vnořená generátorová notace seznamů; standardní tutorial)
<li><a href="http://docs.python.org/3.1/tutorial/datastructures.html#looping-techniques">Looping techniques</a> (techniky zápisu cyklů; standardní tutorial)
</ul>
</div>
<div id=chapter-strings>
<h1>Řetězce</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> I’m telling you this ’cause you’re one of my friends.<br>
My alphabet starts where your alphabet ends! <span class="u">&#x275E;</span><br>(Protože jedním z mých přátel jsi, tak říkám ti:<br>Má abeceda začíná tam, kde tvá končí!)<br>&mdash; Dr. Seuss, On Beyond Zebra!
</blockquote>
<p>&nbsp;
<h2 id=strings-boring-stuff>Pár nudných věcí, kterým musíte rozumět dříve, než se budeme moci ponořit</h2>
<p class=f>Přemýšlí o tom jen málo lidí, ale text je neuvěřitelně komplikovaný. Začněme s abecedou. Obyvatelé <a href="http://en.wikipedia.org/wiki/Bougainville_Province">Bougainville</a> používají nejmenší abecedu na světě. Jejich <a href="http://en.wikipedia.org/wiki/Rotokas_alphabet">abeceda Rotokas</a> se skládá z pouhých 12 písmen: A, E, G, I, K, O, P, R, S, T, U a V. Na opačném konci spektra najdeme jazyky, jako jsou čínština, japonština a korejština, které používají tisíce znaků. Angličtina používá 26 písmen&nbsp;&mdash;&nbsp;nebo 52, pokud počítáte zvlášť malá a velká písmena&nbsp;&mdash;&nbsp;a k tomu pár interpunkčních znaků, jako jsou <i class="baa">!@#$%&amp;</i>.

<p>Pokud v souvislosti s počítači mluvíte o „textu“, pak pravděpodobně myslíte „znaky a symboly na počítačové obrazovce“. Ale počítače nepracují se znaky a symboly. Pracují s bity a bajty. Každý kousek textu, který jste kdy spatřili na počítačové obrazovce, byl ve skutečnosti uložen v určitém <i>znakovém kódování</i>. Zhruba řečeno, kódování znaků zachycuje vztah mezi tím, co vidíte na obrazovce, a tím, co je ve skutečnosti uloženo v paměti počítače a na disku. Znakových kódování se používá velmi mnoho. Některá jsou optimalizována pro konkrétní jazyk, jakým je ruština, čínština nebo angličtina. Jiná kódování se mohou používat pro více jazyků.

<p>Ve skutečnosti je to ještě mnohem komplikovanější. Řada znaků je společná pro více různých kódování, ale každé kódování může pro jejich uložení v paměti nebo na disku používat jinou posloupnost bajtů. Takže o znakovém kódování můžete uvažovat jako o dešifrovacím klíči. Kdykoliv vám někdo poskytne posloupnost bajtů&nbsp;&mdash;&nbsp;soubor, webovou stránku, cokoliv&nbsp;&mdash;&nbsp;a bude tvrdit, že to je „text“, budete k úspěšnému dekódování bajtů na znaky chtít vědět také to, jaké kódování znaků bylo použito. Pokud vám někdo poskytne špatný klíč nebo vám dokonce nedá žádný, postaví vás před nevyhnutelný úkol rozlousknout kód sami. Může se stát, že při tom uděláte chybu a výsledek bude zmatený.

<aside>Vše, co jste si mysleli, že o řetězcích víte, je vám k ničemu.</aside>

<p>Určitě už jste viděli webové stránky s podivnými znaky podobnými otazníku na místech, kde měly být apostrofy. Obvykle to znamená, že autor stránky neuvedl jejich správné kódování a váš prohlížeč musel hádat. Výsledkem byla směs očekávaných a neočekávaných znaků. U anglického textu to vnímáme spíš jen rušivě, ale v jiných jazycích může být výsledek zcela nečitelný.

<p>Každý význačný jazyk na světě má definováno své znakové kódování. Každé kódování znaků bylo kvůli rozdílům v jazycích optimalizováno pro konkrétní jazyk, protože paměťový a diskový prostor byly v minulosti velmi drahé. Mám tím na mysli to, že pro reprezentaci znaků jazyka používalo každé kódování stejný interval čísel (0&ndash;255). Pravděpodobně znáte například kódování <abbr>ASCII</abbr>, které ukládá anglické znaky jako čísla z intervalu 0 až 127. (65 je velké „A“, 97 je malé „a“ atd.) Angličtina má velmi jednoduchou abecedu, která může být úplně vyjádřena méně než 128 čísly. Pro ty z vás, kteří umí počítat ve dvojkové soustavě, na to stačí 7 z 8 bitů v bajtu.

<p>Západoevropské jazyky, jakou jsou francouzština, španělština a němčina, používají více znaků než angličtina. Přesněji řečeno, najdete v nich písmena kombinovaná s různými diakritickými značkami, jako například u znaku <code>ñ</code> používaného ve španělštině. Nejběžnějším kódováním je u těchto jazyků CP-1252. Označuje se také „windows-1252“, protože se široce používá v Microsoft Windows. Kódování CP-1252 sdílí znaky v intervalu 0&ndash;127 s <abbr>ASCII</abbr>, ale rozpíná se i do intervalu 128&ndash;255. Nalezneme v něm takové znaky jako n-s-vlnkou (241), u-s-přehláskou (252) atd. Pořád ale jde o jednobajtové kódování. Největší možné číslo (255) se pořád vejde do jednoho bajtu.

<p>Pak tu ale máme jazyky, jako je čínština, japonština a korejština, které používají takové množství znaků, že vyžadují vícebajtové znakové sady. Každý jejich „znak“ je vyjádřen dvoubajtovým číslem v intervalu 0&ndash;65535. Ale u různých vícebajtových kódování se pořád setkáváme se stejným problémem, jako u různých jednobajtových kódování. Každé z nich používá stejná čísla pro vyjádření různých věcí. Používají jen širší interval čísel, protože musí vyjádřit mnohem více znaků.

<p>Ve světě, který ještě nebyl propojen sítí a kde „text“ bylo něco, co jste si sami napsali a příležitostně vytiskli, to většinou bylo přijatelné. „Prostého textu“ jste ale moc nenašli. Zdrojové texty byly v <abbr>ASCII</abbr> a všichni ostatní používali textové procesory, které definovaly své vlastní (netextové) formáty. Ty si spolu s informacemi o stylu ukládaly také informaci o znakovém kódování. Lidé tyto dokumenty četli prostřednictvím stejných textových procesorů, jaké použil původní autor, takže všechno víceméně fungovalo.

<p>Teď si představte vzestup globálních sítí s elektronickou poštou a s webem. Spousty „prostých textů“ létají kolem zeměkoule &mdash; byly napsány na jednom počítači, přeneseny přes druhý a zobrazovány na třetím počítači. Počítače vidí jen čísla. Ale čísla mohou znamenat různé věci. Ach ne! Co budeme dělat? Takže systém musel být navržen tak, aby si každý „prostý text“ s sebou nesl informaci o kódování. Připomeňme si, že jde o dešifrovací klíč, který převádí čísla srozumitelná počítači na znaky čitelné člověkem. Chybějící dešifrovací klíč vede ke zkreslenému textu, zmatkům nebo k něčemu horšímu.

<p>Teď si představte, že bychom více kusů textu chtěli uložit na stejném místě, jako například ve stejné databázové tabulce uchovávající doručenou elektronickou poštu. Pro každý kousek musíme stejně uložit i znakové kódování, abychom text dokázali správně zobrazit. Myslíte si, že je to příliš tvrdý požadavek? Zkuste ve své e-mailové databázi vyhledávat. To znamená, že budete muset za běhu provádět převody mezi různými kódováními. Tady přestává legrace, že?

<p>Teď si představte, že byste měli vícejazyčné dokumenty, ve kterých se znaky z různých jazyků vyskytují vedle sebe, v tom samém dokumentu. (Nápověda: Programy, které se o to pokoušely, typicky používaly pomocné kódy (escape) pro přepínání „režimů“. Prásk, teď jste v ruském režimu koi8-r, takže 241 znamená Я; bum, teď jste řeckém režimu pro Mac, takže 241 znamená ώ.) I <em>v takových</em> dokumentech byste samozřejmě chtěli umět vyhledávat.

<p>Tak a teď plačte, protože vše, co jste si mysleli, že o řetězcích víte, je vám k ničemu. Nic takového jako „prostý text“ neexistuje.

<p class=a>&#x2042;

<h2 id=strings-one-ring-to-rule-them-all>Unicode</h2>

<p><i>Vstupte do světa <dfn>Unicode</dfn>.</i>

<p>Unicode je systém navržený tak, aby bylo možné vyjádřit <em>každý</em> znak z <em>každého</em> jazyka. Každé písmeno, znak nebo ideogram se v Unicode vyjadřují jako 4bajtové číslo. Každé číslo vyjadřuje jedinečný znak, který se používá alespoň v jednom jazyce našeho světa. (Ne všechna čísla jsou využita, ale těch použitých je více než 65535. To znamená, že dva bajty nestačí.) Znaky, které se používají ve více jazycích, mají obvykle stejné číslo &mdash; pokud neexistuje dobrý etymologický důvod, aby tomu tak nebylo. Bez ohledu na další okolnosti je ale pro každý znak vyhrazeno jedno číslo a pro každé číslo jen jeden znak. Jedno číslo vždy znamená jedinou věc. Nepoužívají se žádné dříve zmíněné „režimy“. <code>U+0041</code> znamená vždy <code>'A'</code>, a to i v případech, pokud by váš jazyk <code>'A'</code> nepoužíval.

<p>Na první pohled to vypadá jako výborná myšlenka. Jedno kódování vládne všem. Více jazyků v jednom dokumentu. Už nikdy více „přepínání režimu“ uprostřed textu jen kvůli přepnutí kódování. Ale už v této chvíli by vás měla napadnout zjevná otázka. Čtyři bajty? Pro každý jeden znak<span class="u" title="kombinace vykřičníku s otazníkem!">&#8253;</span> To vypadá jako hrozné plýtvání. Obzvlášť pro jazyky, jako jsou angličtina nebo španělština, které k vyjádření každého používaného znaku potřebují méně než jeden bajt (256 čísel). Ve skutečnosti je to plýtvání i pro jazyky založené na ideogramech (jako je čínština), které na jeden znak nepotřebují nikdy více než dva bajty.

<p>Existuje kódování Unicode, které používá čtyři bajty na znak. Nazývá se UTF-32, podle počtu 32 bitů, což jsou 4 bajty. UTF-32 je přímočaré kódování. Každé číslo uložené na čtyřech bajtech se reprezentuje jako Unicode znak se stejným číslem. Má to své výhody. Nejdůležitější z nich je ta, že <var>N</var>-tý znak řetězce můžeme zpřístupnit v konstantním čase. <var>N</var>-tý znak totiž začíná na <var>4×N</var>-tém bajtu. Ale má to i nevýhody. Ta nejzjevnější je, že na každý podělaný znak potřebujeme čtyři bajty.

<p>Znaků je v Unicode velmi mnoho, ale ukazuje se, že většina lidí nepoužije nikdy žádný, který by ležel mimo prvních 65535. Takže tu máme další kódování Unicode. Nazývá se UTF-16 (protože 16 bitů jsou 2 bajty). V UTF-16 se každý znak s číslem z intervalu 0&ndash;65535 kóduje do dvou bajtů. Pokud opravdu potřebujeme vyjádřit zřídka používané Unicode znaky z „astrální roviny“ (přesahující 65535), používá UTF-16 jisté špinavé triky. Nejzjevnější výhoda: UTF-16 je prostorově dvakrát efektivnější než UTF-32, protože pro uložení každého znaku potřebujeme jen dva bajty místo čtyř (s výjimkou těch, pro které to neplatí). A pokud budeme předpokládat, že řetězec neobsahuje žádné znaky z astrální roviny, můžeme snadno najít <var>N-tý</var> znak v konstantním čase. Ten předpoklad je docela dobrý, ale jen do doby, kdy to přestane platit.

<p>Ale jak UTF-32, tak UTF-16 mají také méně zřejmé nevýhody. Různé počítačové systémy ukládají jednotlivé bajty různým způsobem. Tak například znak <code>U+4E2D</code> by mohl být v UTF-16 uložen buď jako <code>4E 2D</code> nebo <code>2D 4E</code>. Závisí to na tom, zda systém používá přístup big-endian (na menší adrese významnější bajt) nebo little-endian (na menší adrese méně významný bajt). (Pro UTF-32 existují dokonce ještě další možnosti uspořádání bajtů.) Pokud váš dokument nikdy neopustí váš počítač, je to v suchu&nbsp;&mdash;&nbsp;různé aplikace budou na stejném počítači používat stejné pořadí bajtů. Ale v okamžiku, kdy budete chtít dokument přenášet mezi systémy, třeba prostřednictvím webu nebo něčeho takového, budeme potřebovat způsob, jak vyjádřit námi používané pořadí uložených bajtů. V opačném případě by cílový systém neuměl zjistit, zda dvoubajtová posloupnost <code>4E 2D</code> znamená <code>U+4E2D</code> nebo <code>U+2D4E</code>.

<p>Vícebajtová kódování Unicode pro vyřešení tohoto problému definují „Byte Order Mark“ (značka pořadí bajtů; zkráceně BOM). Jde o speciální netisknutelný znak, který můžete vložit na začátek svého dokumentu, abyste dali najevo, v jakém pořadí jsou vaše bajty uvedeny. Pro UTF-16 je Byte Order Mark roven <code>U+FEFF</code>. Pokud obdržíte dokument v <abbr>UTF-16</abbr> začínající bajty <code>FF FE</code>, pak víte, že jde o jedno z možných pořadí bajtů. Pokud začíná bajty <code>FE FF</code>, pak víte, že pořadí bajtů je obrácené.

<p>Přesto UTF-16 není zcela ideální. Platí to zvláště v případech, kdy používáte velké množství <abbr>ASCII</abbr> znaků. Když o tom popřemýšlíte, dokonce i čínské webové stránky budou obsahovat velké množství <abbr>ASCII</abbr> znaků&nbsp;&mdash;&nbsp;všechny ty značky a atributy, které obklopují tisknutelné čínské znaky. Pokud umíme najít <var>N-tý</var> znak v konstantním čase, je to fajn. Ale pořád tu máme nepříjemný problém s těmi znaky z astrální roviny. To znamená, že nemůžete <em>zaručit</em>, že každý znak je uložen přesně na dvou bajtech. Takže <em>ve skutečnosti</em> nemůžete <var>N-tý</var> znak najít v konstantním čase &mdash; pokud si ovšem neudržujete oddělený index. A mezi námi, ve světě se nachází ohromné množství <abbr>ASCII</abbr> textů&hellip;

<p>Těmito otázkami se už zabývali jiní a přišli s řešením:

<p class=xxxl>UTF-8

<p><abbr>UTF-8</abbr> je kódovací systém s <em>proměnnou délkou</em>. To znamená, že různé Unicode znaky zabírají různý počet bajtů. Pro <abbr>ASCII</abbr> znaky (A-Z atd.) používá <abbr>UTF-8</abbr> jen jeden bajt na znak. Ve skutečnosti používá přesně tentýž bajt. Prvních 128 znaků (0&ndash;127) se v <abbr>UTF-8</abbr> nedá rozlišit od <abbr>ASCII</abbr>. Znaky z „rozšířené latinky“, jako jsou ñ a ö, budou zabírat dva bajty. (Bajty zde nevyjadřují kód z Unicode tak jednoduchým způsobem, jako je tomu u UTF-16. Je do toho zataženo trošku složitější hraní si s bity.) Čínské znaky jako 中 zabírají tři bajty. Zřídka používané znaky z „astrální roviny“ zabírají čtyři bajty.

<p>Nevýhody: Protože každý znak zabírá různý počet bajtů, je nalezení <var>N</var>-tého znaku operací o složitosti O(N). To znamená, že čím je řetězec delší, tím déle budeme znak na určené pozici vyhledávat. Při kódování znaků na bajty a dekódování bajtů na znaky se musíme navíc zabývat dalšími manipulacemi s bity.

<p>Výhody: Kódovaní běžných <abbr>ASCII</abbr> znaků je extrémně efektivní. Při kódování znaků z rozšířené latinky není horší než UTF-16. Pro čínské znaky je lepší než UTF-32. A díky jednoznačnému způsobu manipulace s bity zde neexistují žádné problémy s pořadím bajtů. (To mi musíte věřit, protože to tady nebudu matematicky zdůvodňovat.) Dokument kódovaný v <abbr>UTF-8</abbr> používá na každém počítači přesně stejnou posloupnost bajtů.

<p class=a>&#x2042;

<h2 id=strings-divingin>Ponořme se</h2>

<p>V Pythonu 3 jsou všechny řetězce posloupnostmi znaků v Unicode. Nenajdeme zde nic takového jako pythonovský řetězec kódovaný v <abbr>UTF-8</abbr> nebo pythonovský řetězec kódovaný v CP-1252. „Je tento řetězec v <abbr>UTF-8</abbr>?“ &mdash; toto je nesmyslná otázka. <abbr>UTF-8</abbr> představuje způsob kódování znaků do posloupnosti bajtů. Pokud chcete vzít řetězec a přeměnit jej na posloupnost bajtů v určitém znakovém kódování, může vám v tom Python 3 pomoci. Pokud chcete vzít posloupnost bajtů a přeměnit ji na řetězec, pomůže vám s tím Python 3 také. Ale bajty nejsou znaky. Bajty jsou prostě bajty. Znak je abstrakce. A řetězce jsou posloupnostmi těchto abstrakcí.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>s = '深入 Python'</kbd>    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>len(s)</kbd>               <span class=u>&#x2461;</span></a>
<samp class=pp>9</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s[0]</kbd>                 <span class=u>&#x2462;</span></a>
<samp class=pp>'深'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s + ' 3'</kbd>             <span class=u>&#x2463;</span></a>
<samp class=pp>'深入 Python 3'</samp></pre>
<ol>
<li>Řetězec vytvoříme tak, že posloupnost znaků uzavřeme do uvozovacích znaků.  Pythonovské řetězce mohou být definovány uzavřením buď do apostrofů (<code>'</code>; single quotes) nebo do uvozovek (<code>"</code>; double quotes).<!--"-->
<li>Zabudovaná funkce <code><dfn>len</dfn>()</code> vrací délku řetězce, tj. počet znaků. Je to stejná funkce, jakou používáme pro <a href=#native-datatypes-extendinglists>nalezení délky seznamu, n-tice, množiny nebo slovníku</a>. Řetězec připomíná n-tici znaků.
<li>S využitím indexové notace můžeme získat jednotlivé znaky řetězce, podobně jako u seznamu.
<li>Operátor <code>+</code> provádí <dfn>konkatenaci</dfn> řetězců (zřetězení, spojení), stejně jako u seznamů.
</ol>

<p class=a>&#x2042;

<h2 id=strings-formatting-strings>Formátovací řetězce</h2>

<aside>Řetězce definujeme uzavřením do apostrofů nebo do uvozovek.</aside>
<p>Podívejme se znovu na <a href=#your-first-python-program-divingin><code>humansize.py</code></a>:

<p class=d>[<a href="examples/humansize.py">stáhnout <code>humansize.py</code></a>]
<pre class=pp><code><a>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],         <span class=u>&#x2460;</span></a>
            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}

def approximate_size(size, a_kilobyte_is_1024_bytes=True):
<a>    '''Convert a file size to human-readable form.                          <span class=u>&#x2461;</span></a>

    Keyword arguments:
    size -- file size in bytes
    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024
                                if False, use multiples of 1000

    Returns: string

<a>    '''                                                                     <span class=u>&#x2462;</span></a>
    if size &lt; 0:
<a>        raise ValueError('number must be non-negative')                     <span class=u>&#x2463;</span></a>

    multiple = 1024 if a_kilobyte_is_1024_bytes else 1000
    for suffix in SUFFIXES[multiple]:
        size /= multiple
        if size &lt; multiple:
<a>            return '{0:.1f} {1}'.format(size, suffix)                       <span class=u>&#x2464;</span></a>

    raise ValueError('number too large')</code></pre>
<ol>
<li><code>'KB'</code>, <code>'MB'</code>, <code>'GB'</code>&hellip; to všechno jsou řetězce.
<li>Dokumentační řetězce funkcí jsou řetězce. Tento dokumentační řetězec se rozprostírá přes několik řádků. Proto je použita trojice apostrofů na začátku i na konci řetězce.
<li>Tato trojice apostrofů ukončuje dokumentační řetězec.
<li>Zde máme další řetězec, který předáváme objektu výjimky jako lidsky čitelnou podobu chybového hlášení.
<li>A tady máme&hellip; hej, co je sakra tohle?
</ol>

<p>Python 3 podporuje <dfn>formátování</dfn> hodnot do řetězců. Možné jsou i velmi komplikované výrazy, ale nejzákladnější použití spočívá ve vložení hodnoty do řetězce s jednou oblastí náhrad.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>username = 'mark'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>password = 'PapayaWhip'</kbd>                             <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>"{0}'s password is {1}".format(username, password)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>"mark's password is PapayaWhip"</samp></pre>
<ol>
<li>Ne, moje heslo doopravdy nezní <kbd>PapayaWhip</kbd>.
<li>Tady se děje spousta věcí. Zaprvé, voláme zde metodu řetězcového literálu. <em>Řetězce jsou objekty</em> a objekty mají metody. Zadruhé, vyhodnocením celého výrazu vznikne řetězec. Zatřetí, <code>{0}</code> a <code>{1}</code> jsou <i>oblasti náhrad</i> (replacement fields), do kterých budou dosazeny argumenty předané metodě <code><dfn>format</dfn>()</code>.
</ol>

<h3 id=strings-compound-field-names>Složená jména oblastí</h3>

<p>Předchozí příklad ukazoval nejjednodušší případ, kdy jsou v oblastech náhrad použita pouze celá čísla. Celá čísla se v oblastech náhrad považují za indexy do seznamu argumentů metody <code>format()</code>. To znamená, že <code>{0}</code> je nahrazena prvním argumentem (v našem případě <var>username</var>), <code>{1}</code> je nahrazena druhým argumentem (<var>password</var>) atd. Můžeme použít tolik pozičních indexů, kolik máme argumentů. A argumentů můžeme mít tolik, kolik chceme. Ale oblasti náhrad jsou ještě mnohem mocnější.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>si_suffixes = humansize.SUFFIXES[1000]</kbd>      <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>si_suffixes</kbd>
<samp class=pp>['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'1000{0[0]} = 1{0[1]}'.format(si_suffixes)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'1000KB = 1MB'</samp>
</pre>
<ol>
<li>Místo volání funkce z modulu <code>humansize</code> si půjčíme jednu z datových struktur, která je v něm definována: seznam přípon jednotek „SI“ (mocniny čísla 1000).
<li>Vypadá to složitě, ale není to složité. <code>{0}</code> se odkazuje na první argument předaný metodě <code>format()</code>, tedy na <var>si_suffixes</var>. Ale <var>si_suffixes</var> má podobu seznamu. Takže <code>{0[0]}</code> odkazuje na první položku seznamu, který je prvním argumentem předaným metodě <code>format()</code>: <code>'KB'</code>. Podobně <code>{0[1]}</code> odkazuje na druhou položku stejného seznamu: <code>'MB'</code>. Všechno vně složených závorek&nbsp;&mdash;&nbsp;včetně <code>1000</code>, rovnítka a mezer&nbsp;&mdash;&nbsp;zůstává nedotčeno. Konečným výsledkem je řetězec <code>'1000KB = 1MB'</code>.
</ol>

<aside>{0} je nahrazena prvním argumentem metody format(). {1} je nahrazena druhým argumentem.</aside>
<p>Tento příklad ukazuje, že <em>specifikátory formátu mohou pro zpřístupnění položek a vlastností datových struktur používat (téměř) pythonovskou syntaxi</em>. Říká se tomu <i>složená jména oblastí</i> (compound field names). Funkční jsou následující složená jména oblastí:

<ul>
<li>Předání seznamu a zpřístupnění položky seznamu indexem (jako v předchozím příkladu).
<li>Předání slovníku a zpřístupnění jeho hodnoty uvedením klíče.
<li>Předání modulu a zpřístupnění jeho proměnných a funkcí jménem.
<li>Předání instance třídy a zpřístupnění jejích vlastností a metod jménem.
<li><em>Libovolná kombinace výše uvedeného.</em>
</ul>

<p>Abych vás ohromil, tady máte příklad, který vše kombinuje:

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<samp class=p>>>> </samp><kbd class=pp>import sys</kbd>
<samp class=p>>>> </samp><kbd class=pp>'1MB = 1000{0.modules[humansize].SUFFIXES[1000][0]}'.format(sys)</kbd>
<samp class=pp>'1MB = 1000KB'</samp></pre>

<p>A teď si popíšeme, jak to funguje:

<ul>
<li>Modul <code>sys</code> v sobě udržuje informace o momentálně běžící pythonovské instanci. Protože jsme provedli jeho import, můžeme celý modul <code>sys</code> předat jako argument metody <code>format()</code>. Takže pole náhrad <code>{0}</code> odkazuje na modul <code>sys</code>.
<li><code>sys.modules</code> je slovník všech modulů, které byly importovány touto instancí Pythonu. V roli klíčů vystupují jména modulů uvedená jako řetězce. Hodnotami jsou vlastní objekty modulů. Takže oblast náhrad <code>{0.modules}</code> odkazuje na slovník importovaných modulů.
<li><code>sys.modules['humansize']</code> odkazuje na modul <code>humansize</code> module, který jsme právě importovali. Oblast náhrad <code>{0.modules[humansize]}</code> odkazuje na modul <code>humansize</code>. Povšimněte si zde malého rozdílu v syntaxi. Ve skutečném pythonovském kódu jsou klíči slovníku <code>sys.modules</code> řetězce. Abychom se jimi mohli odkázat, musíme jméno modulu uzavřít do apostrofů (jako například <code>'humansize'</code>). Jenže uvnitř oblasti náhrad apostrofy kolem slovníkového klíče vynecháváme (tj. <code>humansize</code>). Citujme <a href="http://www.python.org/dev/peps/pep-3101/">PEP 3101: Advanced String Formatting</a>, „Pravidla pro předávání klíčů položek jsou velmi jednoduchá.  Pokud klíč začíná číslicí, bude chápán jako číslo. V ostatních případech bude použit jako řetězec.“
<li><code>sys.modules['humansize'].SUFFIXES</code> je slovník definovaný na začátku modulu <code>humansize</code>. Odkazuje se na něj oblast náhrad <code>{0.modules[humansize].SUFFIXES}</code>.
<li><code>sys.modules['humansize'].SUFFIXES[1000]</code> je seznam přípon jednotek <abbr>SI</abbr>: <code>['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']</code>. Takže oblast náhrad <code>{0.modules[humansize].SUFFIXES[1000]}</code> se odkazuje na zmíněný seznam.
<li><code>sys.modules['humansize'].SUFFIXES[1000][0]</code> je první položkou seznamu přípon jednotek <abbr>SI</abbr>: <code>'KB'</code>. Z toho plyne, že celá oblast náhrad <code>{0.modules[humansize].SUFFIXES[1000][0]}</code> je nahrazena dvojznakovým řetězcem <code>KB</code>.
</ul>

<h3 id=strings-format-specifiers>Specifikátory formátu</h3>

<p>Ale počkat! Ono je toho ještě víc! Podívejme se ještě jednou na tento divný řádek kódu ze souboru <code>humansize.py</code>:

<pre class='nd pp'><code>if size &lt; multiple:
    return '{0:.1f} {1}'.format(size, suffix)</code></pre>

<p><code>{1}</code> je nahrazena druhým argumentem předaným metodě <code>format()</code>, a tím je <var>suffix</var>. Ale co znamená <code>{0:.1f}</code>? Jde o dvě věci: význam <code>{0}</code> už znáte, ale význam <code>:.1f</code> ještě ne. Druhá část (dvojtečka a to, co následuje) definuje <i>specifikátor formátu</i> (format specifier), který upřesňuje, jak má být dosazovaná hodnota formátována.

<blockquote class='note compare clang'>
<p><span class="u">&#x261E;</span>Specifikátory formátu vám dovolí upravit výsledný text do řady užitečných podob &mdash; podobně jako funkce <code><dfn>printf</dfn>()</code> v jazyce C. Můžete přidat vycpávku z nul nebo z mezer, zarovnat řetězce, řídit počet desetinných míst a dokonce konvertovat čísla do šestnáctkové soustavy.
</blockquote>

<p>Dvojtečka (<code>:</code>) uvnitř oblasti náhrad označuje začátek specifikátoru formátu. Specifikátor „<code>.1</code>“ znamená „zaokrouhli na nejbližší desetiny“ (tj. zobraz jen jedno místo za desetinnou tečkou). Specifikátor „<code>f</code>“ znamená „číslo s pevnou řádovou čárkou“ (jako opak k exponenciálnímu zápisu nebo k jiným způsobům reprezentace čísla). Takže pokud má <var>size</var> hodnotu <code>698.24</code> a <var>suffix</var> hodnotu <code>'GB'</code>, pak naformátovaný řetězec bude mít podobu <code>'698.2 GB'</code>. Hodnota <code>698.24</code> bude zaokrouhlena na jedno desetinné místo a hodnota <var>suffix</var> bude připojena za číslo.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>'{0:.1f} {1}'.format(698.24, 'GB')</kbd>
<samp class=pp>'698.2 GB'</samp></pre>

<p>Detaily kolem specifikátorů formátů naleznete v oficiální pythonovské dokumentaci, v části <a href="http://docs.python.org/3.1/library/string.html#format-specification-mini-language">Format Specification Mini-Language</a>.

<p class=a>&#x2042;

<h2 id=strings-common-string-methods>Další běžné metody řetězců</h2>

<p>S řetězci můžeme, kromě formátování, provádět řadu dalších užitečných kousků.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>s = '''Finished files are the re-</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>... </samp><kbd>sult of years of scientif-</kbd>
<samp class=p>... </samp><kbd>ic study combined with the</kbd>
<samp class=p>... </samp><kbd>experience of years.'''</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>s.splitlines()</kbd>                     <span class=u>&#x2461;</span></a>
<samp class=pp>['Finished files are the re-',
 'sult of years of scientif-',
 'ic study combined with the',
 'experience of years.']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(s.lower())</kbd>                   <span class=u>&#x2462;</span></a>
<samp>finished files are the re-
sult of years of scientif-
ic study combined with the
experience of years.</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s.lower().count('f')</kbd>               <span class=u>&#x2463;</span></a>
<samp class=pp>6</samp></pre>
<ol>
<li>V interaktivním pythonovském shellu můžeme zadat i <dfn>víceřádkové</dfn> řetězce. Pokud zahájíme víceřádkový řetězec uvedením trojitého uvozovacího znaku, můžeme jednoduše stisknout <kbd>ENTER</kbd> a interaktivní shell nás vyzve k zadání pokračování řetězce. Zapsáním uzavírací trojice uvozovacího znaku označíme konec řetězce. Po následném stisku <kbd>ENTER</kbd> se příkaz provede. (V tomto případě bude řetězec přiřazen do proměnné <var>s</var>).
<li>Metoda <code><dfn>splitlines</dfn>()</code> přebírá jeden víceřádkový řetězec a vrací seznam řetězců, ve kterém každá položka reprezentuje jeden řádek z originálu. Všimněte si, že znaky konců řádků nejsou do jednotlivých řádků zahrnuty.
<li>Metoda <code>lower()</code> převádí celý řetězec na malá písmena. (Podobně zase metoda <code>upper()</code> převádí řetězec na velká písmena.)
<li>Metoda <code>count()</code> vrací počet výskytů zadaného podřetězce. Ano, v uvedené větě je opravdu šest „f“!
</ol>

<p>Vezměme si další běžný případ. Dejme tomu, že máme seznam dvojic klíč-hodnota ve tvaru <code><var>key1</var>=<var>value1</var>&amp;<var>key2</var>=<var>value2</var></code> a my bychom je chtěli rozdělit a vytvořit z nich slovník v podobě <code>{key1: value1, key2: value2}</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>query = 'user=pilgrim&amp;database=master&amp;password=PapayaWhip'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list = query.split('&amp;')</kbd>                                        <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['user=pilgrim', 'database=master', 'password=PapayaWhip']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list_of_lists = [v.split('=', 1) for v in a_list if '=' in v]</kbd>  <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list_of_lists</kbd>
<samp class=pp>[['user', 'pilgrim'], ['database', 'master'], ['password', 'PapayaWhip']]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict = dict(a_list_of_lists)</kbd>                                   <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'password': 'PapayaWhip', 'user': 'pilgrim', 'database': 'master'}</samp></pre>

<ol>
<li>Řetězcové metodě <code><dfn>split</dfn>()</code> jsme zadali jeden argument, hodnotu oddělovače. Metoda v místech zadaného oddělovače rozdělí řetězec na seznam řetězců. Zde je jako oddělovač použit znak ampersand, ale může to být cokoliv.
<li>Teď máme seznam řetězců, kde každý obsahuje klíč, následuje znak rovnítka a poté hodnota. K průchodu tímto seznamem a k rozdělení každého řetězce na dva v místě rovnítka můžeme použít <a href=#comprehensions-listcomprehension>generátorovou notaci seznamu</a> (list comprehension). Druhý nepovinný argument metody <code>split()</code> říká, kolikrát chceme dělení řetězce provést. Hodnota <code>1</code> znamená „rozdělit jen jednou“, takže metoda <code>split()</code> vrátí dvouprvkový seznam. (Hodnota by teoreticky mohla také obsahovat znak rovnítka. Pokud bychom použili pouze <code>'key=value=foo'.split('=')</code>, dostali bychom seznam s třemi prvky <code>['key', 'value', 'foo']</code>.)
<li>A nakonec necháme Pythonu převést tento seznam seznamů na slovník jednoduše tím, že jej předáme funkci <code>dict()</code>.
</ol>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Předchozí příklad se hodně podobá získávání parametrů dotazu uvedeného v <abbr>URL</abbr>, ale rozklad opravdu používaných <abbr>URL</abbr> je ve skutečnosti složitější. Pokud se máte zabývat parametry dotazu v <abbr>URL</abbr>, pak pro vás bude mnohem lepší, když použijete funkci <a href="http://docs.python.org/3.1/library/urllib.parse.html#urllib.parse.parse_qs"><code>urllib.parse.parse_qs()</code></a>. Ta je schopná zvládnout i některé ne příliš zřejmé hraniční případy.
</blockquote>

<h3 id=strings-slicingstrings>Vykrajování podřetězců</h3>
<p>Jakmile máme vytvořen řetězec, můžeme získat jakoukoliv jeho část v podobě nového řetězce. Anglicky se tomu říká „<i>slicing</i> the string“, což můžeme přeložit jako „vykrajování z řetězce“ nebo „výřez z řetězce“. Vykrajování podřetězců funguje naprosto stejně jako <a href=#native-datatypes-slicinglists>vykrajování podseznamů</a>. Ono to dává smysl, protože řetězce jsou prosté posloupnosti znaků.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_string = 'My alphabet starts where your alphabet ends.'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[3:11]</kbd>           <span class=u>&#x2460;</span></a>
<samp class=pp>'alphabet'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[3:-3]</kbd>           <span class=u>&#x2461;</span></a>
<samp class=pp>'alphabet starts where your alphabet en'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[0:2]</kbd>            <span class=u>&#x2462;</span></a>
<samp class=pp>'My'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[:18]</kbd>            <span class=u>&#x2463;</span></a>
<samp class=pp>'My alphabet starts'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[18:]</kbd>            <span class=u>&#x2464;</span></a>
<samp class=pp>' where your alphabet ends.'</samp></pre>
<ol>
<li>Část řetězce, výřez (slice), můžeme získat zadáním dvou indexů. Návratovou hodnotou je nový řetězec, který obsahuje všechny znaky (při zachování pořadí) počínaje prvním indexem výřezu a konče znakem před druhým indexem.
<li>Při vykrajování z řetězců můžeme rovněž použít záporné indexy výřezu, stejně jako u seznamu.
<li>Řetězce se indexují od nuly, takže zápis <code>a_string[0:2]</code> vrací první dva znaky řetězce počínaje znakem <code>a_string[0]</code> až po <code>a_string[2]</code> vyjma (ten už ve výsledku nebude).
<li>Pokud je levý index výřezu roven nule, můžeme nulu vynechat. Bude dosazena implicitně. Takže zápis <code>a_string[:18]</code> je stejný jako <code>a_string[0:18]</code>. Počáteční nula se dosadí jako implicitní hodnota.
<li>Podobně, pokud by pravý index výřezu měl mít hodnotu rovnou délce řetězce, můžeme jej vynechat. Takže <code>a_string[18:]</code> je totéž jako <code>a_string[18:44]</code>, protože v tomto řetězci se nachází 44 znaků. A najdeme zde opět potěšitelnou symetrii. Pro tento 44znakový řetězec vrací zápis <code>a_string[:18]</code> prvních 18 znaků a <code>a_string[18:]</code> vrací vše kromě prvních 18 znaků. Obecně platí, že <code>a_string[:<var>n</var>]</code> vždy vrátí prvních <var>n</var> znaků a <code>a_string[<var>n</var>:]</code> vrátí zbytek &mdash; nezávisle na délce řetězce.
</ol>

<p class=a>&#x2042;

<h2 id=strings-byte-arrays>Řetězce vs. bajty</h2>

<p><dfn>Bajty</dfn> jsou bajty, znaky jsou abstrakce. Neměnitelná posloupnost Unicode znaků se nazývá <i>řetězec</i>. Neměnitelná posloupnost čísel z intervalu 0&ndash;255 se nazývá objekt typu <i>bytes</i>.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>by = b'abcd\x65'</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'abcde'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(by)</kbd>          <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;class 'bytes'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>           <span class=u>&#x2462;</span></a>
<samp class=pp>5</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by += b'\xff'</kbd>     <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'abcde\xff'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>           <span class=u>&#x2464;</span></a>
<samp class=pp>6</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by[0]</kbd>             <span class=u>&#x2465;</span></a>
<samp class=pp>97</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by[0] = 102</kbd>       <span class=u>&#x2466;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'bytes' object does not support item assignment</samp></pre>
<ol>
<li>Objekt typu <code>bytes</code> definujeme použitím <code>b''</code>, tedy syntaxe pro „<dfn>bajtový literál</dfn>“ . Každý bajt uvnitř bajtového literálu může být buď <abbr>ASCII</abbr> znak, nebo zakódované šestnáctkové číslo od <code>\x00</code> do <code>\xff</code> (0&ndash;255).
<li>Bajtový objekt je typu <code>bytes</code>.
<li>Délku obsahu objektu typu <code>bytes</code> můžeme získat zabudovanou funkcí <code>len()</code>, tedy stejně jako u seznamů a řetězců.
<li>A stejně jako u seznamů a řetězců, pro konkatenaci (zřetězení, spojení) objektů typu <code>bytes</code> můžeme použít operátor <code>+</code>. Výsledkem je nový objekt typu <code>bytes</code>.
<li>Zřetězením 5bajtového objektu a jednobajtového objektu typu <code>bytes</code> vznikne 6bajtový objekt typu <code>bytes</code>.
<li>Stejně jako u seznamů a řetězců můžeme jednotlivé bajty z objektu typu <code>bytes</code> zpřístupnit indexovou notací. Položkami řetězců jsou znaky, položkami objektu typu <code>bytes</code> jsou čísla. Konkrétně jsou to celá čísla z intervalu 0&ndash;255.
<li>Objekt typu <code>bytes</code> je neměnitelný (immutable). Jednotlivým bajtům nemůžeme nic přiřadit. Pokud potřebujete měnit jednotlivé bajty, můžete buď použít <a href=#strings-slicingstrings>výřezy (slicing)</a> a operátor konkatenace (fungují stejně jako u řetězců), nebo můžete objekt typu <code>bytes</code> konvertovat na objekt typu <code>bytearray</code>.
</ol>

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>by = b'abcd\x65'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>barr = bytearray(by)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>barr</kbd>
<samp class=pp>bytearray(b'abcde')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(barr)</kbd>             <span class=u>&#x2461;</span></a>
<samp class=pp>5</samp>
<a><samp class=p>>>> </samp><kbd class=pp>barr[0] = 102</kbd>         <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>barr</kbd>
<samp class=pp>bytearray(b'fbcde')</samp></pre>
<ol>
<li>Pro konverzi objektu typu <code>bytes</code> na objekt měnitelného typu <code>bytearray</code> použijte zabudovanou funkci <code>bytearray()</code>.
<li>Všechny metody a operace, které můžete provádět s objektem typu <code>bytes</code>, můžete provádět i s objektem typu <code>bytearray</code>.
<li>Jedním z rozdílů je to, že objektu typu <code>bytearray</code> můžete při využití indexové notace přiřazovat hodnoty jednotlivým bajtům. Přiřazovaná hodnota musí být celé číslo v intervalu 0&ndash;255.
</ol>

<p>Jednou z věcí, které <em>nikdy nemůžete udělat</em>, je míchání bajtů s řetězci.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>by = b'd'</kbd>
<samp class=p>>>> </samp><kbd class=pp>s = 'abcde'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>by + s</kbd>                       <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: can't concat bytes to str</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s.count(by)</kbd>                  <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: Can't convert 'bytes' object to str implicitly</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s.count(by.decode('ascii'))</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>1</samp></pre>
<ol>
<li>Bajty a řetězce nelze spojovat. Jsou různých datových typů.
<li>Nemůžete spočítat výskyt bajtů v řetězci, protože v řetězci žádné bajty nejsou. Řetězec je posloupností znaků. Možná jste měli na mysli „spočítej výskyty řetězce, který bychom získali po dekódování této posloupnosti bajtů při použití určitého znakového kódování“? V pořádku, ale budete to muset zapsat explicitně. Python 3 neprovádí <dfn>implicitní</dfn> konverzi bajtů na řetězce a řetězců na bajty.
<li>Překvapivou shodou okolností tento řádek kódu říká „spočítej výskyty řetězce, který bychom získali po dekódování této posloupnosti bajtů při určitém znakovém kódování“.
</ol>

<p>A tady máme spojení mezi řetězci a bajty: objekt typu <code>bytes</code> má metodu <code><dfn>decode</dfn>()</code>, která přebírá znakové kódování a vrací řetězec. A řetězce zase mají metodu <code><dfn>encode</dfn>()</code>, která přebírá znakové kódování a vrací objekt typu <code>bytes</code>. V předchozím případě bylo dekódování poměrně přímočaré&nbsp;&mdash;&nbsp;co se týká konverze posloupnosti bajtů v kódování <abbr>ASCII</abbr> na řetězec znaků. Ale stejný postup funguje pro libovolné kódování, které odpovídá znakům řetězce. Platí to dokonce i pro historická (ne Unicode) kódování.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_string = '深入 Python'</kbd>         <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>len(a_string)</kbd>
<samp class=pp>9</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by = a_string.encode('utf-8')</kbd>    <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'\xe6\xb7\xb1\xe5\x85\xa5 Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>
<samp class=pp>13</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by = a_string.encode('gb18030')</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'\xc9\xee\xc8\xeb Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>
<samp class=pp>11</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by = a_string.encode('big5')</kbd>     <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'\xb2`\xa4J Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>
<samp class=pp>11</samp>
<a><samp class=p>>>> </samp><kbd class=pp>roundtrip = by.decode('big5')</kbd>    <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>roundtrip</kbd>
<samp class=pp>'深入 Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>a_string == roundtrip</kbd>
<samp class=pp>True</samp></pre>
<ol>
<li>Toto je řetězec. Má devět znaků.
<li>Toto je objekt typu <code>bytes</code>. Obsahuje 13 bajtů. Posloupnost bajtů vznikla zakódováním řetězce <var>a_string</var> do <abbr>UTF-8</abbr>.
<li>Tento objekt typu <code>bytes</code> obsahuje 11 bajtů. Vznikl zakódováním řetězce <var>a_string</var> v kódování <a href="http://en.wikipedia.org/wiki/GB_18030">GB18030</a>.
<li>Toto je objekt typu <code>bytes</code>. Má 11 bajtů. Jde o <em>zcela jinou posloupnost bajtů</em>, která vznikla zakódováním řetězce <var>a_string</var> v kódování <a href="http://en.wikipedia.org/wiki/Big5">Big5</a>.
<li>Toto je řetězec. Má devět znaků. Jde o posloupnost znaků, kterou jsme získali, když jsme objekt <var>by</var> dekódovali algoritmem Big5. Shoduje se s původním řetězcem.
</ol>

<p class=a>&#x2042;

<h2 id=strings-py-encoding>Závěrečná poznámka: Kódování znaků v pythonovském zdrojovém textu</h2>

<p>Python 3 předpokládá, že váš zdrojový kód&nbsp;&mdash;&nbsp;tj. každý soubor s příponou <code>.py</code>&nbsp;&mdash;&nbsp;je uložen v kódování <abbr>UTF-8</abbr>.

<blockquote class='note compare python2'>
<p><span class="u">&#x261E;</span>V Pythonu 2 bylo u souborů s příponou <code>.py</code> <dfn>výchozím</dfn> kódováním <abbr>ASCII</abbr>. V Pythonu 3 je <a href="http://www.python.org/dev/peps/pep-3120/">výchozím kódováním <abbr>UTF-8</abbr></a>.
</blockquote>

<p>Pokud byste ve svých zdrojových textech chtěli používat jiné kódování, můžete na první řádek souboru vložit deklaraci použitého kódování. Tato deklarace říká, že soubor <code>.py</code> používá kódování windows-1252:

<pre class='nd pp'><code># -*- coding: windows-1252 -*-</code></pre>

<p>Z technického pohledu můžete deklaraci použitého kódování umístit i na druhý řádek. Na prvním řádku se může vyskytovat <abbr>UNIX</abbr>ovský magický příkazový komentář (hash-bang command).

<pre class='nd pp'><code>#!/usr/bin/python3
# -*- coding: windows-1252 -*-</code></pre>

<p>Více informací naleznete v <a href="http://www.python.org/dev/peps/pep-0263/"><abbr>PEP</abbr> 263: Defining Python Source Code Encodings</a>.

<p class=a>&#x2042;

<h2 id=strings-furtherreading>Přečtěte si</h2>

<p>O Unicode v jazyce Python:

<ul>
<li><a href="http://docs.python.org/3.1/howto/unicode.html">Python Unicode HOWTO</a>
<li><a href="http://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit">What’s New In Python 3: Text vs. Data Instead Of Unicode vs. 8-bit</a>
<li><a href="http://www.python.org/dev/peps/pep-0261/"><abbr>PEP 261</abbr></a> vysvětluje, jak Python zachází s astrálními znaky mimo Základní vícejazyčnou rovinu (Basic Multilingual Plane), tj. se znaky s ordinální hodnotou větší než 65535.
</ul>

<p>O Unicode obecně:

<ul>
<li><a href="http://www.joelonsoftware.com/articles/Unicode.html">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a>
<li><a href="http://www.tbray.org/ongoing/When/200x/2003/04/06/Unicode">On the Goodness of Unicode</a>
<li><a href="http://www.tbray.org/ongoing/When/200x/2003/04/13/Strings">On Character Strings</a>
<li><a href="http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF">Characters vs. Bytes</a>
</ul>

<p>O znakovém kódování v jiných formátech:

<ul>
<li><a href="http://feedparser.org/docs/character-encoding.html">Character encoding in XML</a>
<li><a href="http://blog.whatwg.org/the-road-to-html-5-character-encoding">Character encoding in HTML</a>
</ul>

<p>O řetězcích a jejich formátování:

<ul>
<li><a href="http://docs.python.org/3.1/library/string.html"><code>string</code>&nbsp;&mdash;&nbsp;Common string operations</a>
<li><a href="http://docs.python.org/3.1/library/string.html#formatstrings">Format String Syntax</a>
<li><a href="http://docs.python.org/3.1/library/string.html#format-specification-mini-language">Format Specification Mini-Language</a>
<li><a href="http://www.python.org/dev/peps/pep-3101/"><abbr>PEP</abbr> 3101: Advanced String Formatting</a>
</ul>

</div>
<div id=chapter-regular-expressions>
<h1>Regulární výrazy</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> Some people, when confronted with a problem, think “I know, I’ll use regular expressions.” Now they have two problems. <span class="u">&#x275E;</span><br>(Když se někteří lidé setkají s problémem, pomyslí si: „Já vím! Použiji regulární výrazy.“ V tom okamžiku mají problémy dva.)<br>&mdash; <a href="http://www.jwz.org/hacks/marginal.html">Jamie Zawinski</a>
</blockquote>
<p>&nbsp;
<h2 id=regular-expressions-divingin>Ponořme se</h2>
<p class=f>Získávání malých kousků textu z velkých bloků textu představuje výzvu. Pythonovské řetězcové objekty poskytují metody pro vyhledávání a náhrady: <code>index()</code>, <code>find()</code>, <code>split()</code>, <code>count()</code>, <code>replace()</code> atd. Ale použití těchto metod je omezeno na nejjednodušší případy. Tak například metoda <code>index()</code> hledá jediný, pevně zadaný řetězec a vyhledávání je vždy citlivé na velikost písmen. Pokud chceme řetězec <var>s</var> vyhledat bez ohledu na velikost písmen, musíme zavolat <code>s.lower()</code> (převod na malá písmena) nebo <code>s.upper()</code> (převod na velká písmena) a zajistit odpovídající převod prohledávaných řetězců. Metody <code>replace()</code> and <code>split()</code> mají stejná omezení.
<p>Pokud svého cíle můžete dosáhnout metodami řetězcového objektu, měli byste je použít. Jsou rychlé, jednoduché a snadno čitelné. O rychlém, jednoduchém a čitelném kódu bychom se mohli bavit ještě dlouho. Ale pokud se přistihnete, že používáte velké množství různých řetězcových funkcí a příkazů <code>if</code>, abyste zvládli speciální případy, nebo pokud musíte kombinovat volání <code>split()</code> a <code>join()</code>, abyste řetězce rozsekávali na kousky a zase je slepovali, v takových případech může být vhodné přejít k regulárním výrazům.
<p>Regulární výrazy představují mocný a (většinou) standardizovaný způsob vyhledávání, náhrad a rozkladu textu se složitými vzorci znaků. Syntaxe regulárních výrazů je sice obtížná a nepodobná normálnímu kódu, ale výsledek může být nakonec <em>čitelnější</em> než řešení používající mnoho řetězcových funkcí. Existují dokonce způsoby, jak lze do regulárních výrazů vkládat komentáře. To znamená, že jejich součástí může být podrobná dokumentace.
<blockquote class='note compare perl5'>
<p><span class="u">&#x261E;</span>Pokud už jste regulární výrazy používali v jiných jazycích (jako jsou Perl, JavaScript nebo PHP), bude vám pythonovská syntaxe připadat důvěrně známá. Abyste získali přehled o dostupných funkcích a jejich argumentech, přečtěte si shrnutí v dokumentaci <a href="http://docs.python.org/dev/library/re.html#module-contents">modulu <code>re</code></a>.
</blockquote>
<p class=a>&#x2042;

<h2 id=regular-expressions-streetaddresses>Případová studie: Adresa ulice</h2>
<p>Následující série příkladů byla inspirována problémem, který jsem před několika lety řešil v práci. Potřeboval jsem vyčistit a standardizovat adresy ulic, které byly vyexportované z původního systému, ještě před jejich importem do nového systému. (Vidíte? Já si ty věci jen tak nevymýšlím. Ony jsou ve skutečnosti užitečné.) Tento příklad ukazuje, jak jsem na to šel.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>s = '100 NORTH MAIN ROAD'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>s.replace('ROAD', 'RD.')</kbd>                <span class=u>&#x2460;</span></a>
<samp class=pp>'100 NORTH MAIN RD.'</samp>
<samp class=p>>>> </samp><kbd class=pp>s = '100 NORTH BROAD ROAD'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>s.replace('ROAD', 'RD.')</kbd>                <span class=u>&#x2461;</span></a>
<samp class=pp>'100 NORTH BRD. RD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s[:-4] + s[-4:].replace('ROAD', 'RD.')</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>'100 NORTH BROAD RD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>import re</kbd>                               <span class=u>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('ROAD$', 'RD.', s)</kbd>               <span class=u>&#x2464;</span></a>
<samp class=pp>'100 NORTH BROAD RD.'</samp></pre>
<ol>
<li>Mým cílem bylo standardizovat adresu ulice tak, aby se <code>'ROAD'</code> vždycky zkrátilo na <code>'RD.'</code>. Na první pohled jsem si myslel, že je to dost jednoduché, takže prostě použiji řetězcovou metodu <code>replace()</code>. Koneckonců, všechna data už byla převedena na velká písmena, takže problém citlivosti na velikost písmen odpadl. A vyhledávaný řetězec <code>'ROAD'</code> je konstantní. A v tomto klamně jednoduchém případě <code>s.replace()</code> samozřejmě funguje.
<li>Život je ale, naneštěstí, plný protipříkladů a na jeden takový jsem hned narazil. Problém následující adresy spočívá v dvojím výskytu <code>'ROAD'</code>. Jednou jde o část jména ulice <code>'BROAD'</code> a jednou o samostatné slovo. Metoda <code>replace()</code> tyto dva výskyty najde a slepě je oba nahradí. A já jen pozoruji, jak se mé adresy kazí.
<li>Abychom problém adres s více než jedním výskytem podřetězce <code>'ROAD'</code> vyřešili, můžeme se uchýlit k něčemu takovému: hledání a náhradu <code>'ROAD'</code> budeme provádět jen v posledních čtyřech znacích adresy (<code>s[-4:]</code>) a zbytek řetězce ponecháme beze změny (<code>s[:-4]</code>). Ale už sami vidíte, že to začíná být těžkopádné. Například už jen to, že řešení závisí na délce řetězce, který nahrazujeme. (Pokud bychom chtěli nahradit <code>'STREET'</code> zkratkou <code>'ST.'</code>, museli bychom napsat <code>s[:-6]</code> a <code>s[-6:].replace(...)</code>.) Líbilo by se vám, kdybyste se k tomu museli za šest měsíců vrátit a hledat chybu? Jsem si jistý, že ne.
<li>Nastal čas, abychom přešli k regulárním výrazům. Veškerá funkčnost spojená s regulárními výrazy se v Pythonu nachází v modulu <code>re</code>.
<li>Podívejme se na první parametr: <code>'ROAD$'</code>. Jde o jednoduchý regulární výraz, ke kterému <code>'ROAD'</code> pasuje jen v případě, když se vyskytne na konci řetězce. Znak <code>$</code> vyjadřuje „konec řetězce“. (Existuje také odpovídající znak, stříška <code>^</code>, která znamená „začátek řetězce“.) Voláním funkce <code>re.sub()</code> hledáme v řetězci <var>s</var> regulární výraz <code>'ROAD$'</code> a nahradíme jej řetězcem <code>'RD.'</code>. Nalezne se tím <code>ROAD</code> na konci řetězce <var>s</var>, ale <em>nenalezne</em> se podřetězec <code>ROAD</code>, který je součástí slova <code>BROAD</code>. To se totiž nachází uprostřed řetězce <var>s</var>.
</ol>
<aside>^ odpovídá začátku řetězce. $ odpovídá konci řetězce.</aside>
<p>Pokračujme v mém příběhu o čištění adres. Brzy jsem zjistil, že předchozí řešení, kdy <code>'ROAD'</code> lícuje s koncem adresy, není dost dobré. Ne všechny adresy totiž obsahují údaj, že se jedná o ulici. Některé adresy jednoduše končí jménem ulice. Většinou to vyšlo, ale pokud by se ulice jmenovala <code>'BROAD'</code>, pak by regulární výraz pasoval na <code>'ROAD'</code>, které se nachází na konci řetězce, ale je součástí slova <code>'BROAD'</code>. A to není to, co bych potřeboval.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>s = '100 BROAD'</kbd>
<samp class=p>>>> </samp><kbd class=pp>re.sub('ROAD$', 'RD.', s)</kbd>
<samp class=pp>'100 BRD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('\\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2460;</span></a>
<samp class=pp>'100 BROAD'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2461;</span></a>
<samp class=pp>'100 BROAD'</samp>
<samp class=p>>>> </samp><kbd class=pp>s = '100 BROAD ROAD APT. 3'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2462;</span></a>
<samp class=pp>'100 BROAD ROAD APT. 3'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD\b', 'RD.', s)</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>'100 BROAD RD. APT 3'</samp></pre>
<ol>
<li>To, co jsem <em>opravdu</em> chtěl, bylo vyhledání podřetězce <code>'ROAD'</code>, který se nacházel na konci řetězce <em>a navíc tvořil samostatné slovo</em> (a ne část nějakého delšího slova). V regulárním výrazu to vyjádříme zápisem <code>\b</code>, který má význam „hranice slova se musí vyskytnout právě tady“ (b jako boundary). V Pythonu je to komplikované skutečností, že znak <code>'\'</code> musíme v řetězci vyjádřit zvláštním způsobem. (Tento znak se anglicky nazývá též „escape character“ a používá se pro zápis zvláštních posloupností. Má tedy zvláštní význam. Pokud jej chceme použít v prostém významu, musíme jej také zapsat jako „escape“ sekvenci. Prakticky to znamená, že jej musíme zdvojit.) Někdy se to označuje jako mor zpětných lomítek. Je to jeden z důvodů, proč se psaní regulárních výrazů v Perlu jeví snadnější než v jazyce Python. Negativní stránkou Perlu je míchání vlastních regulárních výrazů a odlišností při jejich zápisu. Takže pokud se někde projevuje chyba, dá se někdy obtížně odhadnout, zda je to chyba syntaxe nebo chyba ve vašem regulárním výrazu.
<li>Mor zpětných lomítek můžeme obejít tím, že uvedením písmene <code>r</code> před uvozovacím znakem použijeme to, čemu se říká <i>surový řetězec</i> (ve smyslu přírodní, nezpracovaný; anglicky raw string). Tím Pythonu říkáme, že se v tomto řetězci nepoužívají speciální posloupnosti (escape sequence). Zápis <code>'\t'</code> vyjadřuje tabulační znak, ale <code>r'\t'</code> se opravdu chápe jako znak <code>\</code> následovaný písmenem <code>t</code>. Pokud budete pracovat s regulárními výrazy, doporučuji vám vždy používat surové řetězce. V opačném případě dospějete velmi rychle k velkým zmatkům. (Regulární výrazy jsou už i tak dost matoucí.)
<li><em>Ach jo.</em> Naneštěstí jsem brzy našel případy, které odporovaly mému přístupu. V tomto případě obsahovala adresa slovo <code>'ROAD'</code> jako samostatné slovo, ale to se nenacházelo na konci. Za označením ulice se totiž nacházelo číslo bytu. A protože se <code>'ROAD'</code> nenacházelo na úplném konci řetězce, nepasovalo to s regulárním výrazem, takže celé volání <code>re.sub()</code> neprovedlo vůbec žádnou náhradu a vrátil se původní řetězec, což nebylo to, co jsem chtěl.
<li>Abych tento problém vyřešil, odstranil jsem znak <code>$</code> a přidal jsem další <code>\b</code>. Teď už regulární výraz můžeme číst „vyhledej samostatné slovo <code>'ROAD'</code> kdekoliv v řetězci“, ať už je to na konci, na začátku nebo někde uprostřed.
</ol>
<p class=a>&#x2042;

<h2 id=regular-expressions-romannumerals>Případová studie: Římská čísla</h2>
<p>Římská čísla už jste určitě viděli, i když jste je možná nerozpoznali. Mohli jste je vidět u starých filmů nebo televizních pořadů jako „Copyright <code>MCMXLVI</code>“ místo „Copyright <code>1946</code>“, nebo na stěnách knihoven a univerzit („založeno <code>MDCCCLXXXVIII</code>“ místo „založeno <code>1888</code>“ ). Mohli jste je vidět v různých číslováních a odkazech na literaturu. Jde o systém zápisu čísel, který se opravdu datuje do dob starého římského impéria (proto ten název).
<p>U římských čísel se používá sedm znaků, které se opakují a kombinují různými způsoby, aby vyjádřily číselnou hodnotu.
<ul>
<li><code>I = 1</code>
<li><code>V = 5</code>
<li><code>X = 10</code>
<li><code>L = 50</code>
<li><code>C = 100</code>
<li><code>D = 500</code>
<li><code>M = 1000</code>
</ul>
<p>Následují základní pravidla pro konstrukci římských čísel:
<ul>
<li>V některých případech se znaky sčítají. <code>I</code> je <code>1</code>, <code>II</code> je rovno <code>2</code> a <code>III</code> znamená <code>3</code>. <code>VI</code> se rovná <code>6</code> (doslova „<code>5</code> a <code>1</code>“), <code>VII</code> je <code>7</code> a <code>VIII</code> je <code>8</code>.
<li>Desítkové znaky (<code>I</code>, <code>X</code>, <code>C</code> a <code>M</code>) se mohou opakovat nanejvýš třikrát. Hodnotu <code>4</code> musíme vyjádřit odečtením od dalšího vyššího pětkového znaku. Hodnotu <code>4</code> nemůžeme zapsat jako <code>IIII</code>. Místo toho ji musíme zapsat jako <code>IV</code> („o <code>1</code> méně než <code>5</code>“). <code>40</code> se zapisuje jako <code>XL</code> („o <code>10</code> méně než <code>50</code>“), <code>41</code> jako <code>XLI</code>, <code>42</code> jako <code>XLII</code>, <code>43</code> jako <code>XLIII</code> a následuje <code>44</code> jako <code>XLIV</code> („o <code>10</code> méně než <code>50</code> a k tomu o <code>1</code> méně než <code>5</code>“).
<li>Někdy znaky vyjadřují... opak sčítání. Když některé znaky umístíme před jiné, provádíme odčítání od konečné hodnoty. Například hodnotu <code>9</code> musíme vyjádřit odečtením od dalšího vyššího desítkového znaku: <code>8</code> zapíšeme jako <code>VIII</code>, ale <code>9</code> zapíšeme <code>IX</code> („o <code>1</code> méně než <code>10</code>“) a ne jako <code>VIIII</code> (protože znak <code>I</code> nemůžeme opakovat čtyřikrát). <code>90</code> je <code>XC</code>, <code>900</code> je <code>CM</code>.
<li>Pětkové znaky se nesmí opakovat. <code>10</code> se vždy zapisuje jako <code>X</code> a nikdy jako <code>VV</code>. <code>100</code> je vždy <code>C</code>, nikdy <code>LL</code>.
<li>Římská čísla se čtou zleva doprava, takže na pořadí znaků velmi záleží. <code>DC</code> znamená <code>600</code>, ale <code>CD</code> je úplně jiné číslo (<code>400</code>, „o <code>100</code> méně než <code>500</code>“). <code>CI</code> je <code>101</code>; <code>IC</code> není dokonce vůbec platné římské číslo (protože <code>1</code> nemůžeme přímo odčítat od <code>100</code>; musíme to napsat jako <code>XCIX</code>, „o <code>10</code> méně než <code>100</code> a k tomu o <code>1</code> méně než <code>10</code>“).
</ul>
<h3 id=regular-expressions-thousands>Kontrola tisícovek</h3>
<p>Jak bychom vlastně mohli ověřit, zda je libovolný řetězec platným římským číslem? Podívejme se na to po jednotlivých číslicích. Římské číslice se vždycky píší od největších k nejmenším. Začněme tedy u nejvyšších, na místě tisícovek. U čísel 1000 a vyšších se tisícovky vyjadřují jako řada znaků <code>M</code>.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?$'</kbd>        <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>     <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106FB58></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MM')</kbd>    <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106C290></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMM')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106AA38></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMM')</kbd>  <span class=u>&#x2464;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, '')</kbd>      <span class=u>&#x2465;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106F4A8></samp></pre>
<ol>
<li>Tento vzorek má tři části. Znak <code>^</code> zajistí vazbu další části výrazu na začátek řetězce. Pokud bychom jej nepoužili, pak by vzorek pasoval nezávisle na tom, kde by se znaky <code>M</code> nacházely. A to bychom nechtěli. Chceme si být jistí ním, že pokud se nějaké znaky <code>M</code> najdou, musí se nacházet na začátku řetězce. Zápis <code>M?</code> odpovídá nepovinnému výskytu jednoho znaku <code>M</code>. A protože se opakuje třikrát, odpovídá výraz výskytu žádného až tří znaků <code>M</code> za sebou. Znak <code>$</code> odpovídá konci řetězce. Když to dáme dohromady se znakem <code>^</code> na začátku, znamená to, že vzorek musí odpovídat celému řetězci. Znakům <code>M</code> nemůže žádný jiný znak předcházet a ani za nimi nemůže následovat.
<li>Základem modulu <code>re</code> je funkce <code>search()</code>. Ta přebírá regulární výraz (<var>pattern</var>) a řetězec (<code>'M'</code>) a zkusí, jestli k sobě pasují. Pokud je shoda nalezena, vrátí funkce <code>search()</code> objekt, který nabízí různé metody k popisu výsledku. Pokud ke shodě nedojde, vrací funkce <code>search()</code> hodnotu <code>None</code>, což je pythonovská hodnota null (nil, nic). V tomto okamžiku nás zajímá jen to, zda vzorek pasuje. Abychom mohli odpovědět, stačí se podívat na návratovou hodnotu funkce <code>search()</code>. Řetězec <code>'M'</code> odpovídá regulárnímu výrazu, protože první nepovinný znak <code>M</code> sedí a druhý a třetí nepovinný znak <code>M</code> se ignoruje.
<li>Řetězec <code>'MM'</code> vyhovuje, protože první a druhý nepovinný znak <code>M</code> pasují a třetí <code>M</code> se ignoruje.
<li>Řetězec <code>'MMM'</code> vyhovuje, protože všechny tři znaky <code>M</code> pasují.
<li>Řetězec <code>'MMMM'</code> nevyhovuje. Všechny tři znaky <code>M</code> pasují, ale pak regulární výraz trvá na tom, že řetězec musí skončit (protože je to předepsáno znakem <code>$</code>). Jenže řetězec ještě nekončí (protože následuje čtvrté <code>M</code>). Takže <code>search()</code> vrací <code>None</code>.
<li>Zajímavé je, že prázdný řetězec tomuto regulárnímu výrazu vyhovuje, protože všechny znaky <code>M</code> jsou nepovinné.
</ol>
<h3 id=regular-expressions-hundreds>Kontrola stovek</h3>
<aside>? říká, že vzorek je nepovinný.</aside>
<p>Kontrola stovek je obtížnější než kontrola tisícovek. Je to tím, že v závislosti na hodnotě existuje několik vzájemně se vylučujících způsobů, kterými mohou být stovky vyjádřeny.
<ul>
<li><code>100 = C</code>
<li><code>200 = CC</code>
<li><code>300 = CCC</code>
<li><code>400 = CD</code>
<li><code>500 = D</code>
<li><code>600 = DC</code>
<li><code>700 = DCC</code>
<li><code>800 = DCCC</code>
<li><code>900 = CM</code>
</ul>
<p>Takže tu máme čtyři možné vzory:
<ul>
<li><code>CM</code>
<li><code>CD</code>
<li>Žádný až tři znaky <code>C</code> (nula v případě, kdy má být na místě stovek 0).
<li><code>D</code> následované žádným až třemi znaky <code>C</code>.
</ul>
<p>Poslední dva vzory můžeme zkombinovat:
<ul>
<li>Nepovinné <code>D</code> následované žádným až třemi znaky <code>C</code>.
</ul>
<p>Následující příklad ukazuje, jak můžeme u římských čísel ověřit zápis stovek.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?(CM|CD|D?C?C?C?)$'</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCM')</kbd>             <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 01070390></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MD')</kbd>              <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 01073A50></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMCCC')</kbd>          <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 010748A8></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMC')</kbd>            <span class=u>&#x2464;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, '')</kbd>                <span class=u>&#x2465;</span></a>
<samp>&lt;_sre.SRE_Match object at 01071D98></samp></pre>
<ol>
<li>Tento vzorek začíná stejně jako u předchozího příkladu. Kontrolujeme hranici začátku řetězce (<code>^</code>) a potom místo pro tisícovky (<code>M?M?M?</code>). V závorkách je poté uvedena nová část, která definuje sadu tří vzájemně výlučných vzorků oddělených svislými čarami: <code>CM</code>, <code>CD</code> a <code>D?C?C?C?</code> (což vyjadřuje nepovinné <code>D</code> následované žádným nebo třemi znaky <code>C</code>). Analyzátor (parser) regulárního výrazu kontroluje každý z těchto vzorků v daném pořadí (zleva doprava), zvolí první, který situaci odpovídá, a ostatní ignoruje.
<li>Řetězec <code>'MCM'</code> vyhovuje, protože pasuje první <code>M</code>, druhý a třetí znak <code>M</code> vzorku se ignorují. Následující podřetězec <code>CM</code> odpovídá prvnímu vzorku v závorce (takže části vzorku <code>CD</code> a <code>D?C?C?C?</code> se neuvažují). <code>MCM</code> je římské číslo vyjadřující hodnotu <code>1900</code>.
<li>Řetězec <code>'MD'</code> vyhovuje, protože pasuje první <code>M</code>, druhé a třetí <code>M</code> se ignorují. Vzorek <code>D?C?C?C?</code> pasuje k <code>D</code> (každý z následujících tří znaků <code>C</code> je nepovinný, takže se ignorují). <code>MD</code> je římské číslo vyjadřující <code>1500</code>.
<li>Řetězec <code>'MMMCCC'</code> testem prošel. Všechny tři znaky <code>M</code> pasují. Následující vzorek <code>D?C?C?C?</code> pasuje k podřetězci <code>CCC</code> (znak <code>D</code> je nepovinný a ignoruje se). <code>MMMCCC</code> je římské číslo vyjadřující hodnotu <code>3300</code>.
<li>Řetězec <code>'MCMC'</code> nevyhovuje. První znak <code>M</code> pasuje, druhé a třetí <code>M</code> se ignorují. Následující <code>CM</code> vyhovuje, ale poté vzorek předepisuje znak <code>$</code>, který nesedí, protože ještě nejsme na konci řetězce. (Pořád nám zbývá nezpracovaný znak <code>C</code>.) Poslední znak <code>C</code> <em>nelze napasovat</em> ani na část vzorku <code>D?C?C?C?</code>, protože ta se vzájemně vylučuje s částí vzorku <code>CM</code>, která se již použila.
<li>Zajímavé je, že tomuto vzorku vyhovuje prázdný řetězec, protože všechny znaky <code>M</code> jsou nepovinné a ignorují se. Prázdný řetězec dále vyhovuje i části vzorku <code>D?C?C?C?</code>, protože všechny znaky jsou nepovinné a ignorují se.
</ol>
<p>Uffff! Vidíte, jak se mohou regulární výrazy rychle stát nechutnými? A to jsme zatím vyřešili části římských čísel jen pro tisíce a stovky. Ale pokud jste zatím vše sledovali, budou pro vás desítky a jednotky jednoduché, protože u nich použijeme naprosto stejný přístup. Ale podívejme se ještě na další možnost vyjádření vzorku.
<p class=a>&#x2042;

<h2 id=regular-expressions-nmsyntax>Využití syntaxe <code>{n,m}</code></h2>
<aside>Zápis {1,4} vyjadřuje 1 až 4 výskyty vzorku.</aside>
<p>V předcházející podkapitole jsme pracovali se vzorkem, ve kterém se mohly stejné znaky opakovat až třikrát. V regulárních výrazech existuje ještě jiný způsob, jak to vyjádřit. Někteří lidé jej považují za čitelnější. Podívejme se nejdříve na způsoby, které jsme použili v předcházejícím příkladu.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>     <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MM')</kbd>    <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp>>>> </samp><kbd class=pp>re.search(pattern, 'MMM')</kbd>   <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp>>>> </samp><kbd class=pp>re.search(pattern, 'MMMM')</kbd>  <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Zde dochází ke shodě se začátkem řetězce a s prvním nepovinným <code>M</code>, ale ne s druhým a s třetím <code>M</code> (což je v pořádku, protože jsou nepovinná). Potom následuje konec řetězce.
<li>Zde dochází ke shodě se začátkem řetězce a s prvním a druhým nepovinným <code>M</code>, ale ne s třetím <code>M</code> (ale to je v pořádku, protože je nepovinné). Poté pasuje i konec řetězce.
<li>Zde dochází ke shodě se začátkem řetězce, se všemi třemi nepovinnými <code>M</code> a s koncem řetězce.
<li>Zde dochází ke shodě se začátkem řetězce a se všemi třemi nepovinnými <code>M</code>, ale poté nenásleduje předepsaný konec řetězce (protože tu máme ještě jedno nepasující <code>M</code>). To znamená, že vzorek nesedí a vrací se <code>None</code>.
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>pattern = '^M{0,3}$'</kbd>        <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>     <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MM')</kbd>    <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMM')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEDA8></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMM')</kbd>  <span class=u>&#x2464;</span></a>
<samp>>>> </samp></pre>
<ol>
<li>Tento vzorek říká: „Zde musí být začátek řetězce, potom následují nula až tři znaky <code>M</code> a pak musí být konec řetězce.“ Na místě 0 a 3 mohou být uvedena libovolná čísla. Pokud chceme předepsat „nejméně jeden, ale ne víc než tři znaky <code>M</code>“, můžeme napsat <code>M{1,3}</code>.
<li>Zde dochází ke shodě se začátkem řetězce a pak s jedním ze tří možných <code>M</code> a s koncem řetězce.
<li>Zde dochází ke shodě se začátkem řetězce a pak s dvěma ze tří možných <code>M</code> a s koncem řetězce.
<li>Zde dochází ke shodě se začátkem řetězce a pak s třemi ze tří možných <code>M</code> a s koncem řetězce.
<li>Zde dochází ke shodě se začátkem řetězce a pak s třemi ze tří možných <code>M</code>, ale poté <em>nedochází ke shodě s předpisem</em> pro konec řetězce. Tento regulární výraz předepisuje maximálně tři znaky <code>M</code> následované koncem řetězce, ale řetězec obsahuje čtyři, takže vzorek nepasuje a vrací se <code>None</code>.
</ol>
<h3 id=regular-expressions-tensandones>Kontrola desítek a jednotek</h3>
<p>Rozšiřme tedy regulární výraz pro kontrolu římských čísel o kontrolu na místě desítek a jednotek. Následující příklad ukazuje, jak můžeme kontrolovat desítky.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMXL')</kbd>     <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCML')</kbd>      <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLX')</kbd>     <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLXXX')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLXXXX')</kbd>  <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Tento řetězec pasuje k předepsanému začátku řetězce, pak k prvnímu nepovinnému <code>M</code>, následuje shoda s <code>CM</code>, poté s <code>XL</code> a s předpisem pro konec řetězce. Připomeňme si, že syntaxe <code>(A|B|C)</code> vyjadřuje „odpovídá právě jednomu z A, B nebo C“. Došlo ke shodě s <code>XL</code>, takže se ignorují možnosti <code>XC</code> a <code>L?X?X?X?</code>. Poté byl nalezen konec řetězce. <code>MCMXL</code> je římské číslo vyjadřující hodnotu <code>1940</code>.
<li>Tento řetězec vyhovuje předepsanému začátku řetězce, pak prvnímu nepovinnému <code>M</code>, následuje shoda s <code>CM</code> a pak s <code>L?X?X?X?</code>. Co se týká části <code>L?X?X?X?</code>, vyhovuje jí <code>L</code> a přeskakují se všechny tři nepovinné znaky <code>X</code>. Poté se dostáváme ke konci řetězce. <code>MCML</code> je římské číslo vyjadřující hodnotu <code>1950</code>.
<li>Tento řetězec pasuje k předepsanému začátku řetězce, pak k prvnímu nepovinnému <code>M</code>, následuje shoda s <code>CM</code>, poté s nepovinným <code>L</code>, s prvním nepovinným <code>X</code>, pak se přeskočí druhé a třetí nepovinné <code>X</code> a následuje očekávaný konec řetězce. <code>MCMLX</code> je římské číslo vyjadřující hodnotu <code>1960</code>.
<li>Tento řetězec vyhovuje předepsanému začátku řetězce, pak prvnímu nepovinnému <code>M</code>, potom <code>CM</code>, pak následuje nepovinné <code>L</code> a všechna tři nepovinná <code>X</code> a vyžadovaný konec řetězce. <code>MCMLXXX</code> je římské číslo vyjadřující hodnotu <code>1980</code>.
<li>Tento případ vyhovuje předepsanému začátku řetězce, pak prvnímu nepovinnému <code>M</code>, potom <code>CM</code>, pak tu máme nepovinné <code>L</code> a všechna tři nepovinná <code>X</code>, ale poté <em>dochází k selhání předpokladu</em> konce řetězce, protože nám zbývá ještě jedno <code>X</code>, se kterým jsme nepočítali. Takže celý regulární výraz selhává (nepasuje) a vrací se <code>None</code>. <code>MCMLXXXX</code> není platné římské číslo.
</ol>
<aside>(A|B) předepisuje buď shodu se vzorkem A nebo se vzorkem B, ale ne s oběma najednou.</aside>
<p>Výraz pro test jednotek vytvoříme stejným způsobem. Ušetřím vás detailů a ukážu vám jen konečný výsledek.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$'</kbd>
</pre><p>So what does that look like using this alternate <code>{n,m}</code> syntax?  This example shows the new syntax.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MDLV')</kbd>              <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMDCLXVI')</kbd>          <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMDCCCLXXXVIII')</kbd>   <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'I')</kbd>                 <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp></pre>
<ol>
<li>Zde dochází ke shodě se začátkem řetězce, pak s jedním ze tří možných znaků <code>M</code> a následně s předpisem <code>D?C{0,3}</code>. U posledního podvýrazu dochází ke shodě s nepovinným <code>D</code> a s nulou ze tří možných znaků <code>C</code>. Posuňme se dál. Zde pasuje podvýraz <code>L?X{0,3}</code>, protože vyhoví nepovinné <code>L</code> a nula ze tří možných znaků <code>X</code>. Další kousek řetězce vyhovuje podvýrazu <code>V?I{0,3}</code>, protože je nalezeno nepovinné <code>V</code> a nula ze tří možných znaků <code>I</code>. A na závěr nastává očekávaný konec řetězce. <code>MDLV</code> je římské číslo vyjadřující hodnotu <code>1555</code>.
<li>Zde dochází ke shodě se začátkem řetězce a pak s dvěma ze tří možných znaků <code>M</code>, pak s <code>D?C{0,3}</code> s jedním <code>D</code> a s jedním ze tří možných znaků <code>C</code>. Pokračujeme <code>L?X{0,3}</code> s jedním <code>L</code> a jedním ze tří možných znaků <code>X</code>. A dále tu máme <code>V?I{0,3}</code> s jedním <code>V</code> a jedním ze tří možných znaků <code>I</code>. Pasuje i očekávaný konec řetězce. <code>MMDCLXVI</code> je římské číslo vyjadřující hodnotu <code>2666</code>.
<li>Zde dochází ke shodě se začátkem řetězce a pak s třemi ze tří možných znaků <code>M</code>, pak je tu <code>D?C{0,3}</code> s jedním <code>D</code> a s třemi ze tří možných znaků <code>C</code>. Pokračujeme <code>L?X{0,3}</code> s jedním <code>L</code> a s třemi ze tří možných znaků <code>X</code>. A dále se uplatní <code>V?I{0,3}</code> s jedním <code>V</code> a s třemi ze tří možných znaků <code>I</code>. A očekávaný konec řetězce. <code>MMMDCCCLXXXVIII</code> je římské číslo vyjadřující hodnotu <code>3888</code>. Současně je to největší římské číslo, které můžete napsat bez použití rozšířené syntaxe.
<li>A teď se pozorně dívejte. (Připadám si jako kouzelník. „Děti, pozorně se dívejte. Teď ze svého klobouku vytáhnu králíka.“) Tady nám pasuje začátek řetězce, pak následuje nula ze tří možných znaků <code>M</code>, pak pasuje <code>D?C{0,3}</code> &mdash; přeskočení nepovinného <code>D</code> a absence znaku <code>C</code> (nula až tři možné výskyty). Pokračujeme shodou s podvýrazem <code>L?X{0,3}</code> přeskočením nepovinného <code>L</code> a přípustnou absencí znaku <code>X</code> (nula až tři možné výskyty). A dále se uplatní <code>V?I{0,3}</code> přeskočením nepovinného <code>V</code> a shodou jednoho ze tří možných znaků <code>I</code>. A pak je tu konec řetězce. No páni.
</ol>
<p>Pokud jste to všechno stihli sledovat a rozuměli jste tomu napoprvé, jde vám to líp, než to šlo mně. Teď si představte, že se snažíte porozumět regulárnímu výrazu, který napsal někdo jiný a který se nachází uprostřed kritické funkce rozsáhlého programu. Nebo si představte, že se po několika měsících vracíte ke svému vlastnímu regulárnímu výrazu. Už se mi to stalo a není to pěkný pohled.
<p>Podívejme se na alternativní syntaxi, která nám pomůže zapsat regulární výraz tak, aby se dal udržovat.
<p class=a>&#x2042;

<h2 id=regular-expressions-verbosere>Víceslovné regulární výrazy</h2>
<p>Zatím jsme se zabývali tím, čemu budu říkat „kompaktní“ regulární výrazy. Jak jste sami viděli, obtížně se čtou. Dokonce i když přijdete na to, co nějaký z nich dělá, není tu žádná záruka, že mu budete rozumět o šest měsíců později. To, co opravdu potřebujeme, je dokumentace připisovaná k danému místu.
<p>V Pythonu toho lze dosáhnout u takzvaných <i>víceslovných regulárních výrazů</i> (verbose regular expressions). Víceslovný regulární výraz se od kompaktního regulárního výrazu liší ve dvou směrech:
<ul>
<li>Bílé znaky se ignorují. Mezery, tabulátory a přechody na nový řádek se nesnaží napasovat na mezery, tabulátory a přechody na nový řádek. Nepasují vůbec k ničemu. (Pokud chcete ve víceslovném regulárním výrazu předepsat shodu s mezerou, musíte před ni napsat zpětné lomítko &mdash; speciální znak (escape) uvozující sekvenci.)
<li>Komentáře se ignorují. Komentáře uvnitř víceslovných regulárních výrazů mají podobu běžných pythonovských komentářů: začínají znakem <code>#</code> a pokračují do konce řádku. V tomto případě jde o komentář uvnitř víceřádkového řetězce a ne uvnitř zdrojového souboru. Ale funguje stejně.
</ul>
<p>Z dalšího příkladu to bude jasnější. Revidujme kompaktní regulární výraz, s kterým jsme pracovali před chvílí, a převeďme jej na víceslovný regulární výraz. Příklad nám ukáže, jak na to.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pattern = '''
    ^                   # začátek řetězce
    M{0,3}              # tisíce - 0 až 3 M
    (CM|CD|D?C{0,3})    # stovky - 900 (CM), 400 (CD), 0-300 (0 až 3 C),
                        #        nebo 500-800 (D následované 0 až 3 C)
    (XC|XL|L?X{0,3})    # desítky - 90 (XC), 40 (XL), 0-30 (0 až 3 X),
                        #        nebo 50-80 (L následované 0 až 3 X)
    (IX|IV|V?I{0,3})    # jednotky - 9 (IX), 4 (IV), 0-3 (0 až 3 I),
                        #        nebo 5-8 (V následované 0 až 3 I)
    $                   # konec řetězce
    '''</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M', re.VERBOSE)</kbd>                 <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLXXXIX', re.VERBOSE)</kbd>         <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMDCCCLXXXVIII', re.VERBOSE)</kbd>   <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>                             <span class=u>&#x2463;</span></a></pre>
<ol>
<li>Nejdůležitější věcí při práci s víceslovnými regulárními výrazy je to, abychom nezapomněli předat jeden argument navíc: v modulu <code>re</code> je definována konstanta <code>re.VERBOSE</code>, kterou dáváme najevo, že vzorek se má brát jako víceslovný regulární výraz. Jak vidíte, v tomto vzorku se nachází docela hodně bílých znaků (všechny se ignorují) a několik komentářů (opět se všechny ignorují). Pokud budete ignorovat bílé znaky a komentáře, dostanete naprosto stejný regulární výraz, jaký jsme si ukázali v minulé podkapitole. Ale je mnohem čitelnější.
<li>Zde dochází ke shodě se začátkem řetězce a pak s třemi <code>M</code>, pak s <code>CM</code>, následuje <code>L</code> a tři ze tří možných <code>X</code>, pak <code>IX</code> a konec řetězce.
<li>Tady pasuje začátek řetězce, pak tři z možných tří <code>M</code>, následuje <code>D</code> a tři ze tří možných <code>C</code>, pak <code>L</code> a tři ze tří možných <code>X</code>, pak <code>V</code> a tři ze tří možných <code>I</code> a konec řetězce.
<li>Shoda nebyla nalezena. Proč? Protože jsme neuvedli příznak <code>re.VERBOSE</code>. Takže funkce <code>re.search</code> považuje vzorek za kompaktní regulární výraz, ve kterém hrají roli všechny bílé znaky i znaky #. Python nemůže rozpoznávat automaticky, zda je regulární výraz víceslovný nebo ne. Python považuje každý regulární výraz za kompaktní &mdash; pokud explicitně neřekneme, že je víceslovný.
</ol>
<p class=a>&#x2042;

<h2 id=regular-expressions-phonenumbers>Případová studie: Analýza telefonních čísel</h2>
<aside>\d vyjadřuje libovolnou číslici (0&ndash;9). \D vyjadřuje vše kromě číslice.</aside>
<p>Prozatím jsme se soustředili na shodu celých vzorků. Vzorek buď pasuje, nebo ne. Ale regulární výrazy jsou ještě mnohem mocnější. Pokud regulární výraz <em>pasuje</em>, můžeme z řetězce vybrat specifické úseky. Můžeme zjistit, jaká část a kde pasovala.
<p>Následující příklad přinesl opět reálný život. Setkal jsem se s ním o jeden pracovní den dříve než s tím předchozím. Problém: rozklad amerického telefonního čísla. Klient požadoval, aby se číslo dalo zadávat ve volném tvaru (v jednom poli formuláře), ale pak je chtěl mít ve firemní databázi rozdělené na kód oblasti, hlavní linku, číslo a případně klapku. Proštrachal jsem web a našel jsem spoustu příkladů regulárních výrazů, které byly pro tento účel vytvořeny. Ale žádný z nich nebyl dost benevolentní.
<p>Tady máme pár telefonních čísel, která měla být přijata:
<ul>
<li><code>800-555-1212</code>
<li><code>800 555 1212</code>
<li><code>800.555.1212</code>
<li><code>(800) 555-1212</code>
<li><code>1-800-555-1212</code>
<li><code>800-555-1212-1234</code>
<li><code>800-555-1212x1234</code>
<li><code>800-555-1212 ext. 1234</code>
<li><code>work 1-(800) 555.1212 #1234</code>
</ul>
<p>Docela široký záběr, že? V každém z těchto případů jsem potřeboval zjistit, že číslo oblasti bylo <code>800</code>, číslo hlavní linky bylo <code>555</code> a zbytek telefonního čísla byl <code>1212</code>. U čísel s klapkou (extension, ext.) jsem potřeboval zjistit, že klapka byla <code>1234</code>.
<p>Takže si projděme vývoj řešení pro analýzu telefonního čísla. Následující příklad ukazuje první krok.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})-(\d{3})-(\d{4})$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>             <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234')</kbd>                 <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234').groups()</kbd>        <span class=u>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AttributeError: 'NoneType' object has no attribute 'groups'</samp></pre>
<ol>
<li>Regulární výraz čteme vždy zleva doprava. Tento odpovídá začátku řetězce a pak následuje <code>(\d{3})</code>. Co to je <code>\d{3}</code>? No, <code>\d</code> vyjadřuje „libovolnou číslici (<code>0</code> až <code>9</code>). Společně s <code>{3}</code> znamená „přesně tři číslice“. Jde o variaci na <a href=#regular-expressions-nmsyntax><code>syntaxi {n,m}</code></a>, kterou jsme si ukazovali dříve. Když to vše obalíme do závorek, znamená to „napasuj se přesně na tři číslice <em>a potom si je zapamatuj jako skupinu, kterou si můžeme vyžádat později</em>“. Pak musí následovat pomlčka. Pak má následovat skupina zase přesně tří číslic. A pak další pomlčka. A další skupina tentokrát čtyř číslic. A poté se očekává konec řetězce.
<li>Ke skupinám, které se zapamatovaly během analýzy předepsané regulárním výrazem, můžeme přistupovat metodou <code>groups()</code> objektu, který vrátila metoda <code>search()</code>. Vrací tolikačlennou n-tici, kolik skupin bylo v regulárním výrazu definováno. V našem případě jsme definovali tři skupiny: jednu s třemi číslicemi, další s třemi číslicemi a poslední se čtyřmi číslicemi.
<li>Tento regulární výraz ale není hotový, protože nezvládne telefonní čísla s klapkou na konci. Pro tento účel musíme regulární výraz rozšířit.
<li>Tento případ ilustruje, proč bychom ve skutečně používaném kódu neměli nikdy „řetězit“ použití metod <code>search()</code> a <code>groups()</code>. Pokud metoda <code>search()</code> nevrátí žádnou shodu, vrací <a href=#native-datatypes-none><code>None</code></a> a nikoliv objekt vyjadřující shodu s regulárním výrazem (MatchObject). Volání <code>None.groups()</code> vyvolá naprosto zřejmou výjimku. <code>None</code> totiž žádnou metodu <code>groups()</code> nemá. (Je to samozřejmě méně zjevné v situaci, kdy se taková výjimka vynoří někde z hloubky našeho kódu. Ano, tady mluvím z vlastní zkušenosti.)
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})-(\d{3})-(\d{4})-(\d+)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234').groups()</kbd>              <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800 555 1212 1234')</kbd>                       <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212')</kbd>                            <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Tento regulární výraz se s předchozím téměř shoduje. Také nejdříve předepisuje začátek řetězce, pak se pamatuje skupina tří číslic, pomlčka, pak se pamatuje skupina tří číslic, pomlčka a nakonec se pamatuje skupina čtyř číslic. Nové je tady to, že se očekává další pomlčka, pak se pamatuje skupina jedné nebo více číslic a teprve potom má nastat konec řetězce.
<li>Metoda <code>groups()</code> teď vrací n-tici se čtyřmi prvky, protože regulární výraz nyní definuje čtyři pamatované skupiny.
<li>Tento regulární výraz ale, bohužel, také není konečnou odpovědí, protože předpokládá, že jednotlivé části telefonního čísla jsou odděleny pomlčkou. Co kdyby je někdo oddělil mezerami, čárkami nebo tečkami? Potřebujeme obecnější řešení, které by akceptovalo více typů oddělovačů.
<li>Ouha! Tenhle regulární výraz nejen že nedělá vše, co si přejeme. Je to ve skutečnosti krok zpět, protože teď nejsme schopni analyzovat číslo <em>bez klapky</em>. To vůbec není to, co jsme chtěli. Pokud tam klapka je, pak chceme vědět jaká. Pokud tam klapka není, pak chceme znát, jaké byly části hlavního čísla.
</ol>
<p>Následující příklad ukazuje regulární výraz, který si poradí s různými oddělovači mezi částmi telefonního čísla.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})\D+(\d{3})\D+(\d{4})\D+(\d+)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800 555 1212 1234').groups()</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234').groups()</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('80055512121234')</kbd>              <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212')</kbd>                <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Držte si klobouky, jedeme z kopce! Očekáváme začátek řetězce, potom skupinu tří číslic, pak <code>\D+</code>. A co je zase tohle? Zápis <code>\D</code> vyjadřuje libovolný znak <em>s výjimkou</em> číslice a <code>+</code> znamená „1 nebo víckrát“. Takže <code>\D+</code> pasuje na jeden nebo více znaků, které nejsou číslicemi. A to je právě to, co použijeme místo přímo zapsané pomlčky a co nám bude pasovat s různými oddělovači.
<li>Protože používáme <code>\D+</code> místo <code>-</code>, bude nám regulární výraz pasovat i na telefonní čísla, kde jsou jednotlivé části odděleny mezerami.
<li>Ale čísla oddělená pomlčkami budou fungovat také.
<li>Stále to ale ještě, bohužel, není konečná odpověď, protože tam nějaký oddělovač je. Co když někdo zadá telefonní číslo úplně bez mezer nebo jiných oddělovačů?
<li>Jejda! Pořád ještě není vyřešeno to, že se požaduje zadání klapky. Takže teď máme dva problémy, ale můžeme je oba vyřešit stejnou technikou.
</ol>
<p>Následující příklad ukazuje regulární výraz pro telefonní čísla <em>bez</em> oddělovačů.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('80055512121234').groups()</kbd>      <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800.555.1212 x1234').groups()</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>        <span class=u>&#x2463;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('(800)5551212 x1234')</kbd>           <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Jediná věc, kterou jsme od minulého kroku udělali, byla záměna <code>+</code> za <code>*</code>. Mezi částmi telefonního čísla nyní místo <code>\D+</code> předepisujeme <code>\D*</code>. Pamatujete si ještě, že <code>+</code> znamená „jednou nebo víckrát“? Fajn. Takže <code>*</code> znamená „nula nebo více výskytů“. Takže teď bychom měli být schopni zpracovat čísla, která neobsahují vůbec žádný oddělovací znak.
<li>No podívejme, ono to opravdu funguje! Jak to? Napasovali jsme se na začátek řetězce, pak jsme si zapamatovali skupinu tří číslic (<code>800</code>), potom nula nenumerických znaků, pak následuje zapamatovaná skupina tří číslic (<code>555</code>), pak nula nenumerických znaků, pak zapamatovaná skupina čtyř číslic (<code>1212</code>), pak nula nenumerických znaků, pak zapamatovaná skupina libovolného počtu číslic (<code>1234</code>) a konec řetězce.
<li>Ostatní obměny teď fungují také: tečky místo pomlček i kombinace mezer a <code>x</code> před klapkou.
<li>Nakonec se nám podařilo vyřešit i dlouho odolávající problém: klapka už je opět nepovinná. Metoda <code>groups()</code> vrací n-tici se čtyřmi prvky i tehdy, když nebyla nalezena klapka. V takovém případě se ale na místě čtvrtého prvku vrací prázdný řetězec.
<li>Nechci být poslem špatných zpráv, ale pořád ještě nejsme hotovi. Co je tady špatně? Před kódem oblasti máme znak navíc, ale regulární výraz předpokládá, že na začátku řetězce se má jako první nacházet kód oblasti. Žádný problém. Úvodní znaky před kódem oblasti můžeme přeskočit již dříve představenou technikou „nula nebo více nečíselných znaků“.
</ol>
<p>Další příklad ukazuje, jak bychom si měli počínat.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^\D*(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('(800)5551212 ext. 1234').groups()</kbd>                  <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>                            <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('work 1-(800) 555.1212 #1234')</kbd>                      <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Tady je to stejné jako v předchozím příkladu &mdash; s tou výjimkou, že před první pamatovanou skupinou znaků (před číslem oblasti) předepisuje <code>\D*</code> nula nebo více nenumerických znaků. Všimněte si, že si tyto nenumerické znaky nepamatujeme (předpis není uzavřen v závorkách). Pokud jsou nějaké nalezeny, jednoduše je přeskočíme a teprve pak si zapamatujeme nalezené číslo oblasti.
<li>Telefonní číslo se nám podaří úspěšně rozložit i v případě, kdy je před číslem oblasti uvedena levá závorka. (Pravá závorka za číslem oblasti se už zpracovává. Bere se jako nenumerický oddělovač a napasuje se na předpis <code>\D*</code> nacházející se za první pamatovanou skupinou.)
<li>Proveďme ještě test funkčnosti (sanity check), abychom se ujistili, že se nepokazilo nic, co dříve fungovalo. Úvodní znaky jsou zcela nepovinné, takže po začátku řetězce se našlo nula nenumerických znaků, pak pamatovaná skupina tří číslic (<code>800</code>), pak jeden nenumerický znak (pomlčka), zapamatovaná skupina tří číslic (<code>555</code>), pak jeden nenumerický znak (pomlčka), poté zapamatovaná skupina čtyř číslic (<code>1212</code>), pak nula nenumerických znaků, pak zapamatovaná skupina nula číslic a na závěr konec řetězce.
<li>Tak toto je případ, kdy mám v souvislosti s regulárními výrazy chuť vydloubnout si oči tupým předmětem. Proč tohle telefonní číslo nepasuje? Protože se před kódem oblasti vyskytuje <code>1</code>, ale my jsme předpokládali, že všechny znaky před kódem oblasti budou nenumerické (<code>\D*</code>). Grrrrr.
</ol>
<p>Podívejme se na to znovu. Zatím se všechny regulární výrazy chytaly na začátek řetězce. Ale teď vidíme, že se na začátku řetězce může vyskytnout obsah neurčité délky, který bychom chtěli ignorovat. Mohli bychom se sice pokusit o vytvoření předpisu, kterým bychom ten začátek přeskočili, ale zkusme k tomu přistoupit jinak. Nebudeme se vůbec snažit o to, abychom se napasovali na začátek řetězce. Zmíněný přístup je použit v následujícím příkladu.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('work 1-(800) 555.1212 #1234').groups()</kbd>         <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>                        <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('80055512121234').groups()</kbd>                      <span class=u>&#x2463;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp></pre>
<ol>
<li>Všimněte si, že v regulárním výrazu chybí <code>^</code>. Už se nesnažíme ukotvit na začátek řetězce. Nikde není řečeno, že by se náš regulární výraz měl napasovat na celý vstupní řetězec. Mechanismus, který regulární výraz vyhodnocuje, už si dá tu práci, aby zjistil, od jakého místa vstupního řetězce dochází ke shodě s předpisem, a bude pokračovat odtud.
<li>Teď už jsme úspěšně rozložili telefonní číslo, které obsahuje úvodní znaky i s nechtěnými čísly a které odděluje skupiny chtěných čísel libovolným počtem libovolných oddělovačů.
<li>Test funkčnosti (sanity check). Funguje to správně.
<li>A tohle taky funguje.
</ol>
<p>Vidíte, jak se může regulární výraz rychle vymknout kontrole? Letmo mrkněte na libovolný z předchozích pokusů. Poznáte snadno rozdíl mezi ním a po něm následujícím?
<p>Takže dokud ještě rozumíme konečnému řešení (a tohle opravdu je konečné řešení; pokud jste objevili případ, který by to nezvládlo, nechci o něm vědět), zapišme ho jako víceslovný regulární výraz. Mohli bychom brzy zapomenout, proč jsme něco zapsali právě takto.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'''
                # nevázat se na začátek řetězce, číslo může začít kdekoliv
    (\d{3})     # číslo oblasti má 3 číslice (např. '800')
    \D*         # nepovinný oddělovač - libovolný počet nenumerických znaků
    (\d{3})     # číslo hlavní linky má 3 číslice (např. '555')
    \D*         # nepovinný oddělovač
    (\d{4})     # zbytek čísla má 4 číslice (např. '1212')
    \D*         # nepovinný oddělovač
    (\d*)       # nepovinná klapka - libovolný počet číslic
    $           # konec řetězce
    ''', re.VERBOSE)</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('work 1-(800) 555.1212 #1234').groups()</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212')</kbd>                          <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp></pre>
<ol>
<li>Jediným rozdílem proti regulárnímu výrazu z minulého kroku je to, že je vše rozepsáno na více řádcích. Proto není žádným překvapením, že zpracovává vstupy stejným způsobem.
<li>Konečný test funkčnosti (sanity check). Ano, tohle pořád funguje. Jsme hotovi.
</ol>
<p class=a>&#x2042;

<h2 id=regular-expressions-summary>Shrnutí</h2>
<p>Zatím jsme viděli pouhou špičku ledovce z toho, co regulární výrazy zvládnou. Jinými slovy, ačkoliv jimi můžete být momentálně zcela ohromeni, zatím jste neviděli nic. To mi věřte.
<p>Následující věci už by vám neměly být cizí:
<ul>
<li><code>^</code> odpovídá začátku řetězce.
<li><code>$</code> vyjadřuje konec řetězce.
<li><code>\b</code> odpovídá hranici slova (word boundary).
<li><code>\d</code> odpovídá číslici.
<li><code>\D</code> odpovídá znaku jinému než číslice.
<li><code>x?</code> odpovídá nepovinnému znaku <code>x</code> (jinými slovy vyjadřuje žádný nebo jeden výskyt <code>x</code>).
<li><code>x*</code> vyjadřuje nula nebo více výskytů <code>x</code>.
<li><code>x+</code> odpovídá <code>x</code> jedenkrát nebo víckrát.
<li><code>x{n,m}</code> vyjadřuje znak <code>x</code> opakovaný nejméně <code>n</code>-krát, ale ne více než <code>m</code>-krát.
<li><code>(a|b|c)</code> odpovídá přesně jedné z možností <code>a</code>, <code>b</code> nebo <code>c</code>.
<li><code>(x)</code> vyjadřuje obecně <em>zapamatovanou skupinu</em>. Hodnotu zapamatované skupiny můžeme získat voláním metody <code>groups()</code> objektu, který byl vrácen voláním <code>re.search</code>.
</ul>
<p>Regulární výrazy jsou velmi mocné, ale jejich použití není správným řešením pro každý problém. Měli byste se o nich naučit tolik, abyste věděli, kdy je jejich použití vhodné, kdy vám pomohou problém vyřešit a kdy naopak způsobí víc problémů, než vyřeší.
</div>
<div id=chapter-generators>
<h1>Uzávěry a generátory</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> My spelling is Wobbly. It’s good spelling but it Wobbles, and the letters get in the wrong places. <span class="u">&#x275E;</span><br>(Mé jméno je Houpavý. Hláskuji to správně, ale Houpe se to a písmenka se dostávají na špatná místa.)<br>&mdash; Medvídek Pú
</blockquote>
<p>&nbsp;
<h2 id=generators-divingin>Ponořme se</h2>
<p class=f>Vyrůstal jsem jako syn knihovnice, která vystudovala angličtinu, a vždycky mě fascinovaly jazyky. Nemyslím programovací jazyky. Tedy ano, i programovací jazyky, ale také přirozené jazyky. Dejme tomu angličtina. Angličtina je schizofrenní jazyk, který si slova půjčuje z němčiny, francouzštiny, španělštiny a latiny (když už mám pár vyjmenovat). Slova „půjčuje si“ ve skutečnosti nejsou ta pravá, „vykrádá“ je přiléhavější. Nebo si je možná „asimiluje“&nbsp;&mdash;&nbsp;jako Borg. Jo, to se mi líbí.
<p class=c><code>My jsme Borg. Zvláštnosti vašeho jazyka a původu slov budou přidány do našeho vlastního. Odpor je marný.</code>
<p>V této kapitole se naučíte něco o anglických podstatných jménech v množném čísle. A také o funkcích, které vracejí jiné funkce, o regulárních výrazech pro pokročilé a o generátorech. Ale nejdříve si řekněme něco o tom, jak se tvoří podstatná jména v množném čísle. (Pokud jste nečetli <a href=#chapter-regular-expressions>kapitolu o regulárních výrazech</a>, tak je na to vhodná doba právě teď. V této kapitole se předpokládá, že základům regulárních výrazů už rozumíte, protože se rychle dostaneme k látce pro pokročilé.)
<p>Pokud jste vyrostli v anglicky mluvící zemi nebo pokud jste se angličtinu učili ve školních lavicích, pak pravděpodobně základní pravidla znáte:
<ul>
<li>Pokud slovo končí na S, X nebo Z, přidáme ES. Z <i>bass</i> se stává <i>basses</i>, z <i>fax</i> se stává <i>faxes</i> a <i>waltz</i> se mění na <i>waltzes</i>.
<li>Pokud slovo končí hlasitým H, přidáme ES. Pokud končí tichým H, přidáme jen S. Co to je hlasité H? Když H zkombinujeme s jinými písmeny, vydá zvuk, který slyšíme. Takže <i>coach</i> [kouč] se změní na <i>coaches</i> a z <i>rash</i> [reš] se stane <i>rashes</i>, protože při vyslování slyšíme zvuky pro CH [č] a SH [š]. Ale z <i>cheetah</i> [číta] se stane <i>cheetahs</i>, protože H je zde tiché.
<li>Pokud slovo končí písmenem Y, které zní jako I, změníme Y na IES. Pokud se Y kombinuje se samohláskou tak, že zní jako něco jiného, pak pouze přidáme S. <i>Vacancy</i> se proto změní na <i>vacancies</i>, ale z <i>day</i> se stane <i>days</i>.
<li>Pokud všechno selhalo, přidáme S a doufáme, že to projde.
</ul>
<p>(No ano, existuje spousta výjimek. Z <i>man</i> se stává <i>men</i> a z <i>woman</i> zase <i>women</i>, ale <i>human</i> se mění na <i>humans</i>. <i>Mouse</i> přechází v <i>mice</i> a z <i>louse</i> je zase <i>lice</i>, ale <i>house</i> se mění v <i>houses</i>. <i>Knife</i> přechází v <i>knives</i> a z <i>wife</i> se stávají <i>wives</i>, ale <i>lowlife</i> se mění v <i>lowlifes</i>. A nechtějte, abych začal o slovech, která jsou sama svým množným číslem (tj. pomnožná), jako jsou <i>sheep</i>, <i>deer</i> a <i>haiku</i>.)
<p>V jiných jazycích je to, samozřejmě, úplně jiné.
<p>Pojďme si navrhnout pythonovskou knihovnu, která automaticky převádí anglická podstatná jména do množného čísla. Začneme s uvedenými čtyřmi pravidly. Ale myslete na to, že budeme nevyhnutelně muset přidávat další.
<p class=a>&#x2042;

<h2 id=generators-i-know>Já vím jak na to! Použijeme regulární výrazy!</h2>
<p>Takže se díváme na slova, což znamená (přinejmenším v angličtině), že se díváme na řetězce znaků. Pak tady máme pravidla, která nám říkají, že potřebujeme najít různé kombinace znaků a podle nich něco udělat. Vypadá to jako práce pro regulární výrazy!
<p class=d>[<a href="examples/plural1.py">stáhnout <code>plural1.py</code></a>]
<pre class=pp><code>import re

def plural(noun):
<a>    if re.search('[sxz]$', noun):             <span class=u>&#x2460;</span></a>
<a>        return re.sub('$', 'es', noun)        <span class=u>&#x2461;</span></a>
    elif re.search('[^aeioudgkprt]h$', noun):
        return re.sub('$', 'es', noun)
    elif re.search('[^aeiou]y$', noun):
        return re.sub('y$', 'ies', noun)
    else:
        return noun + 's'</code></pre>
<ol>
<li>Jde o regulární výraz, ale používá syntaxi, se kterou jste se v kapitole <a href=#chapter-regular-expressions><i>Regulární výrazy</i></a> nesetkali. Hranaté závorky znamenají „napasuj se přesně na jeden z těchto znaků“. Takže <code>[sxz]</code> znamená „<code>s</code> nebo <code>x</code> nebo <code>z</code>“, ale jenom jeden z nich. Znak <code>$</code> by vám měl být povědomý. Vyjadřuje shodu s koncem řetězce. Když to dáme dohromady, pak tento regulární výraz testuje, zda <var>noun</var> (podstatné jméno) končí znakem <code>s</code>, <code>x</code> nebo <code>z</code>.
<li>Funkce <code>re.sub()</code> provádí náhrady v řetězci, které jsou založeny na použití regulárního výrazu.
</ol>

<p>Podívejme se na náhrady předepsané regulárním výrazem podrobněji.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search('[abc]', 'Mark')</kbd>    <span class=u>&#x2460;</span></a>
&lt;_sre.SRE_Match object at 0x001C1FA8>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('[abc]', 'o', 'Mark')</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'Mork'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('[abc]', 'o', 'rock')</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>'rook'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('[abc]', 'o', 'caps')</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>'oops'</samp></pre>
<ol>
<li>Obsahuje řetězec <code>Mark</code> znak <code>a</code>, <code>b</code> nebo <code>c</code>? Ano, obsahuje <code>a</code>.
<li>Fajn. Teď najdi <code>a</code>, <code>b</code> nebo <code>c</code> a nahraď ho znakem <code>o</code>. Z <code>Mark</code> se stane <code>Mork</code>.
<li>Stejná funkce změní <code>rock</code> na <code>rook</code>.
<li>Mohli byste si myslet, že stejná funkce změní <code>caps</code> na <code>oaps</code>, ale není tomu tak. Funkce <code>re.sub</code> nahrazuje <em>všechny</em> shody s regulárním výrazem, nejenom první z nich. Takže tento regulární výraz změní <code>caps</code> na <code>oops</code>, protože jak <code>c</code>, tak <code>a</code> se změní na <code>o</code>.
</ol>

<p>A teď zpět k funkci <code>plural()</code> (množné číslo)&hellip;

<pre class=pp><code>def plural(noun):
    if re.search('[sxz]$', noun):
<a>        return re.sub('$', 'es', noun)         <span class=u>&#x2460;</span></a>
<a>    elif re.search('[^aeioudgkprt]h$', noun):  <span class=u>&#x2461;</span></a>
        return re.sub('$', 'es', noun)
<a>    elif re.search('[^aeiou]y$', noun):        <span class=u>&#x2462;</span></a>
        return re.sub('y$', 'ies', noun)
    else:
        return noun + 's'</code></pre>
<ol>
<li>Zde nahrazujeme konec řetězce (shoda s předpisem <code>$</code>) řetězcem <code>es</code>. Jinými slovy, přidáváme <code>es</code> na konec řetězce. Stejného efektu byste mohli dosáhnout konkatenací řetězců (spojením), například použitím <code>noun + 'es'</code>. Ale z důvodu, které budou jasnější později, jsem se rozhodl každé pravidlo realizovat pomocí regulárního výrazu.
<li>Teď se pořádně podívejte na následující novinku. Znak <code>^</code> uvedený v hranatých závorkách na začátku má speciální význam &mdash; negaci. Zápis <code>[^abc]</code> znamená „libovolný znak <em>s výjimkou</em> <code>a</code>, <code>b</code> nebo <code>c</code>“. Takže <code>[^aeioudgkprt]</code> znamená libovolný znak s výjimkou <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>d</code>, <code>g</code>, <code>k</code>, <code>p</code>, <code>r</code> nebo <code>t</code>. Tento znak musí být následován znakem <code>h</code> a koncem řetězce. Hledáme slova, která končí písmenem H a ve kterých je H slyšet.
<li>Stejně postupujeme v tomto případě: napasuj se na slova, která končí písmenem Y, kde předcházejícím znakem <em>není</em> <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code> nebo <code>u</code>. Hledáme slova, která končí písmenem Y, které zní jako I.
</ol>

<p>Podívejme se na regulární výrazy s negací podrobněji.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search('[^aeiou]y$', 'vacancy')</kbd>  <span class=u>&#x2460;</span></a>
&lt;_sre.SRE_Match object at 0x001C1FA8>
<a><samp class=p>>>> </samp><kbd class=pp>re.search('[^aeiou]y$', 'boy')</kbd>      <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp>
<samp class=p>>>> </samp><kbd class=pp>re.search('[^aeiou]y$', 'day')</kbd>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search('[^aeiou]y$', 'pita')</kbd>     <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li><code>vacancy</code> tomuto regulárnímu výrazu vyhovuje, protože končí na <code>cy</code> a <code>c</code> nepatří mezi <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code> nebo <code>u</code>.
<li><code>boy</code> k regulárnímu výrazu nepasuje, protože končí <code>oy</code> a regulárním výrazem jsme přímo řekli, že před znakem <code>y</code> nemůže být <code>o</code>. Nepasuje ani <code>day</code>, protože končí na <code>ay</code>.
<li><code>pita</code> nevyhovuje také, protože nekončí <code>y</code>.
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('y$', 'ies', 'vacancy')</kbd>               <span class=u>&#x2460;</span></a>
<samp class=pp>'vacancies'</samp>
<samp class=p>>>> </samp><kbd class=pp>re.sub('y$', 'ies', 'agency')</kbd>
<samp class=pp>'agencies'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('([^aeiou])y$', r'\1ies', 'vacancy')</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'vacancies'</samp></pre>
<ol>
<li>Tento regulární výraz mění <code>vacancy</code> na <code>vacancies</code> a <code>agency</code> na <code>agencies</code>, což jsme chtěli. Všimněte si, že by změnil také <code>boy</code> na <code>boies</code>, ale k tomu uvnitř funkce nikdy nedojde, protože provedení <code>re.sub</code> je podmíněno výsledkem předchozího <code>re.search</code>.
<li>Když už jsme u toho, chtěl bych upozornit, že uvedené dva regulární výrazy (jeden, který rozhoduje o uplatnění pravidla, a druhý, který ho realizuje) můžeme zkombinovat do jednoho. Vypadalo by to nějak takto. S většinou výrazu už byste neměli mít problém. Používáme zapamatovanou skupinu, o které jsme si povídali v případové studii zabývající se <a href=#regular-expressions-phonenumbers>analýzou telefonních čísel</a>. Skupina se používá k zapamatování si znaku, který se nachází před písmenem <code>y</code>. V řetězci s náhradou se pak používá nový syntaktický prvek <code>\1</code>, který znamená: „Máš tu první zapamatovanou skupinu? Vlož ji sem.“ V tomto případě se před <code>y</code> zapamatovalo <code>c</code>. V okamžiku substituce se na místo <code>c</code> vloží <code>c</code> a <code>y</code> se nahradí <code>ies</code>. (Pokud pracujete s více než jednou zapamatovanou skupinou, můžete použít <code>\2</code> a <code>\3</code> a tak dále.)
</ol>
<p>Náhrady pomocí regulárních výrazů jsou velmi mocné a syntaxe <code>\1</code> je činí ještě mocnějšími. Ale zkombinování celé operace do jednoho regulárního výrazu snižuje čitelnost a navíc toto řešení nevyjadřuje přímočaře způsob popisu pravidla pro vytváření množného čísla. Původně jsme pravidlo vyjádřili ve stylu „pokud slovo končí S, X nebo Z, pak přidáme ES“. Když se podíváte na zápis funkce, vidíte dva řádky kódu, které říkají „jestliže slovo končí S, X nebo Z, pak přidej ES“. Přímočařeji už to snad ani vyjádřit nejde.

<p class=a>&#x2042;

<h2 id=generators-a-list-of-functions>Seznam funkcí</h2>

<p>Teď přidáme úroveň abstrakce. Začali jsme definicí seznamu pravidel: Jestliže platí tohle, udělej tamto, v opačném případě přejdi k dalšímu pravidlu. Dočasně zkomplikujeme jednu část programu, abychom mohli zjednodušit jinou.

<p class=d>[<a href="examples/plural2.py">download <code>plural2.py</code></a>]
<pre class=pp><code>import re

def match_sxz(noun):
    return re.search('[sxz]$', noun)

def apply_sxz(noun):
    return re.sub('$', 'es', noun)

def match_h(noun):
    return re.search('[^aeioudgkprt]h$', noun)

def apply_h(noun):
    return re.sub('$', 'es', noun)

<a>def match_y(noun):                             <span class=u>&#x2460;</span></a>
    return re.search('[^aeiou]y$', noun)

<a>def apply_y(noun):                             <span class=u>&#x2461;</span></a>
    return re.sub('y$', 'ies', noun)

def match_default(noun):
    return True

def apply_default(noun):
    return noun + 's'

<a>rules = ((match_sxz, apply_sxz),               <span class=u>&#x2462;</span></a>
         (match_h, apply_h),
         (match_y, apply_y),
         (match_default, apply_default)
         )

def plural(noun):
<a>    for matches_rule, apply_rule in rules:       <span class=u>&#x2463;</span></a>
        if matches_rule(noun):
            return apply_rule(noun)</code></pre>
<ol>
<li>V tomto okamžiku má každé rozhodovací (match) pravidlo svou vlastní funkci, která vrací výsledek volání funkce <code>re.search()</code>.
<li>Každé aplikační pravidlo má také svou vlastní funkci, která volá funkci <code>re.sub()</code> realizující příslušný způsob vytvoření množného čísla.
<li>Místo jedné funkce (<code>plural()</code>) s mnoha pravidly teď máme datovou strukturu <code>rules</code> (pravidla), která je posloupností dvojic funkcí.
<li>A protože pravidla byla rozbita do podoby oddělené datové struktury, může být nová funkce <code>plural()</code> zredukována na pár řádků kódu. V cyklu <code>for</code> můžeme z datové struktury <var>rules</var> po dvojicích vybírat rozhodovací a aplikační pravidla (jedno rozhodovací a jedno aplikační). Při prvním průchodu cyklem <code>for</code> nabude <var>matches_rule</var> hodnoty <code>match_sxz</code> a <var>apply_rule</var> hodnoty <code>apply_sxz</code>. Při druhém průchodu (za předpokladu, že se tak daleko dostaneme) bude proměnné <var>matches_rule</var> přiřazena <code>match_h</code> a proměnné <var>apply_rule</var> bude přiřazena <code>apply_h</code>. Je zaručeno, že funkce nakonec něco vrátí, protože poslední rozhodovací funkce (<code>match_default</code>) vrací prostě <code>True</code>. To znamená, že se provede odpovídající aplikační pravidlo (<code>apply_default</code>).
</ol>

<aside>Proměnná „rules“ je posloupností dvojic funkcí.</aside>
<p>Funkčnost této techniky je zaručena tím, že <a href=#your-first-python-program-everythingisanobject>v Pythonu je objektem všechno</a>, včetně funkcí. Datová struktura <var>rules</var> obsahuje funkce&nbsp;&mdash;&nbsp;nikoliv jména funkcí, ale skutečné objekty funkcí. Když v cyklu <code>for</code> dojde k jejich přiřazení, stanou se z proměnných <var>matches_rule</var> a <var>apply_rule</var> skutečné funkce, které můžeme volat. Při prvním průchodu cyklu <code>for</code> je to stejné, jako kdyby se volala funkce <code>matches_sxz(noun)</code>. A pokud by vrátila objekt odpovídající shodě, zavolala by se funkce <code>apply_sxz(noun)</code>.

<p>Pokud se vám přidaná úroveň abstrakce jeví jako matoucí, zkuste si cyklus uvnitř funkce rozepsat a shodu rozpoznáte snadněji. Celý cyklus <code>for</code> je ekvivalentní následujícímu zápisu:

<pre class='nd pp'><code>
def plural(noun):
    if match_sxz(noun):
        return apply_sxz(noun)
    if match_h(noun):
        return apply_h(noun)
    if match_y(noun):
        return apply_y(noun)
    if match_default(noun):
        return apply_default(noun)</code></pre>

<p>Výhodou je, že funkce <code>plural()</code> se zjednodušila. Přebírá sadu pravidel, která mohla být definována kdekoliv, a prochází jimi zobecněným způsobem.

<ol>
<li>Získej rozhodovací pravidlo (match rule).
<li>Došlo ke shodě? Tak volej aplikační pravidlo a vrať výsledek.
<li>Nedošlo ke shodě? Přejdi ke kroku 1.
</ol>

<p>Pravidla mohou být definována kdekoliv, jakýmkoliv způsobem. Funkci <code>plural()</code> je to jedno.

<p>Dobrá, ale bylo vůbec přidání úrovně abstrakce k něčemu dobré? No, zatím ne. Zvažme, co to znamená, když k funkci chceme přidat nové pravidlo. V prvním příkladu by to znamenalo přidat do funkce <code>plural()</code> příkaz <code>if</code>. V tomto druhém příkladu by to vyžadovalo přidání dalších dvou funkcí <code>match_foo()</code> a <code>apply_foo()</code>. Pak bychom museli určit, do kterého místa posloupnosti <var>rules</var> má být dvojice s rozhodovací a aplikační funkcí zařazena (poloha vůči ostatním pravidlům).

<p>Ale to jsme již jen krůček od následující podkapitoly. Pojďme na to...

<p class=a>&#x2042;

<h2 id=generators-a-list-of-patterns>Seznam vzorků</h2>

<p>Ono ve skutečnosti není nezbytné, abychom pro každé rozhodovací a aplikační pravidlo definovali samostatné pojmenované funkce. Nikdy je nevoláme přímo. Přidáváme je do posloupnosti <var>rules</var> a voláme je přes tuto strukturu. Každá z těchto funkcí navíc odpovídá jednomu ze dvou vzorů. Všechny rozhodovací funkce volají <code>re.search()</code> a všechny aplikační funkce volají <code>re.sub()</code>. Rozložme tyto vzory tak, abychom si usnadnili budování nových pravidel.

<p class=d>[<a href="examples/plural3.py">download <code>plural3.py</code></a>]
<pre class=pp><code>import re

def build_match_and_apply_functions(pattern, search, replace):
<a>    def matches_rule(word):                                     <span class=u>&#x2460;</span></a>
        return re.search(pattern, word)
<a>    def apply_rule(word):                                       <span class=u>&#x2461;</span></a>
        return re.sub(search, replace, word)
<a>    return (matches_rule, apply_rule)                           <span class=u>&#x2462;</span></a></code></pre>
<ol>
<li><code>build_match_and_apply_functions()</code> je funkce, která vytváří další funkce dynamicky. Přebírá argumenty <var>pattern</var>, <var>search</var> a <var>replace</var>. Pak definuje rozhodovací funkci <code>matches_rule()</code>, která volá <code>re.search()</code> s vzorkem <var>pattern</var>, který byl předán funkci <code>build_match_and_apply_functions()</code>, a se slovem <var>word</var>, které se předává právě budované funkci <code>matches_rule()</code>. Ty jo!
<li>Aplikační funkce se vytváří stejným způsobem. Aplikační funkce přebírá jeden parametr a volá <code>re.sub()</code> s argumenty <var>search</var> a <var>replace</var>, které byly předány funkci <code>build_match_and_apply_functions()</code>, a s parametrem <var>word</var>, který se předává právě budované funkci <code>apply_rule()</code>. Této technice, kdy se uvnitř dynamicky budované funkce použijí vnější hodnoty, se říká <em>uzávěr</em> (closure). Uvnitř budované aplikační funkce v podstatě definujeme konstanty. Funkce přebírá jeden parametr (<var>word</var>), potom se chová podle něj, ale také podle dalších dvou hodnot (<var>search</var> a <var>replace</var>), které platily v době definice aplikační funkce.
<li>Nakonec funkce <code>build_match_and_apply_functions()</code> vrátila dvojici hodnot &mdash; dvě funkce, které jsme právě vytvořili. Konstanty, které jsme uvnitř těchto funkcí definovali (<var>pattern</var> uvnitř funkce <code>matches_rule()</code> a <var>search</var> a <var>replace</var> uvnitř funkce <code>apply_rule()</code>), v nich zůstávají uzavřené dokonce i po návratu z funkce <code>build_match_and_apply_functions()</code>. To je prostě špica!
</ol>

<p>Pokud se vám to zdá neuvěřitelně matoucí (a to by mělo, protože to je fakt ujeté), může se to vyjasnit, když uvidíte, jak se to používá.

<pre class=pp><code><a>patterns = \                                                        <span class=u>&#x2460;</span></a>
  (
    ('[sxz]$',           '$',  'es'),
    ('[^aeioudgkprt]h$', '$',  'es'),
    ('(qu|[^aeiou])y$',  'y$', 'ies'),
<a>    ('$',                '$',  's')                                 <span class=u>&#x2461;</span></a>
  )
<a>rules = [build_match_and_apply_functions(pattern, search, replace)  <span class=u>&#x2462;</span></a>
         for (pattern, search, replace) in patterns]</code></pre>
<ol>
<li>Naše pravidla (rules) pro tvorbu množného čísla jsou nyní definována jako n-tice trojic <em>řetězců</em> (ne funkcí). Prvním řetězcem v každé skupině je regulární výraz, který se bude používat v <code>re.search()</code> pro rozhodování, zda se toto pravidlo uplatňuje. Druhý a třetí řetězec ve skupině jsou výrazy pro vyhledání a náhradu, které se použijí v <code>re.sub()</code> pro aplikaci pravidla, které sloveso převede do množného čísla.
<li>U záložního pravidla došlo k drobné změně. Pokud v předchozím příkladu nebylo nalezeno žádné ze specifičtějších pravidel, vracela funkce <code>match_default()</code> hodnotu <code>True</code>, což znamenalo, že se na konec slova jednoduše přidá <code>s</code>. Tento dosahuje stejné funkčnosti trochu jinak. Poslední regulární výraz zjišťuje, jestli slovo končí (<code>$</code> odpovídá konci řetězce). A samozřejmě, každý řetězec končí (dokonce i prázdný řetězec), takže shoda s tímto výrazem je nalezena vždy. Tento přístup tedy plní stejný účel jako funkce <code>match_default()</code>, která vždycky vracela <code>True</code>. Pokud nepasuje žádné specifičtější pravidlo, zajistí přidání <code>s</code> na konec daného slova.
<li>Tento řádek je magický. Přebírá řetězce z posloupnosti <var>patterns</var> a mění je na posloupnost funkcí. Jak to dělá? „Zobrazením“ řetězců prostřednictvím funkce <code>build_match_and_apply_functions()</code>. To znamená, že se vezme každá trojice řetězců a ty se předají jako argumenty funkci <code>build_match_and_apply_functions()</code>. Funkce <code>build_match_and_apply_functions()</code> vrátí dvojici funkcí. To znamená, že struktura <var>rules</var> získá funkčně shodnou podobu jako v předchozím příkladu &mdash; seznam dvojic, kde každá obsahuje dvě funkce. První funkce je rozhodovací (match; pasovat) a volá <code>re.search()</code>, druhá funkce je aplikační a volá <code>re.sub()</code>.
</ol>

<p>Skript zakončíme hlavním vstupním bodem, funkcí <code>plural()</code>.

<pre class=pp><code>def plural(noun):
<a>    for matches_rule, apply_rule in rules:  <span class=u>&#x2460;</span></a>
        if matches_rule(noun):
            return apply_rule(noun)</code></pre>
<ol>
<li>A protože je seznam <var>rules</var> stejný jako v předchozím příkladu (a to opravdu je), nemělo by být žádným překvapením, že se funkce <code>plural()</code> vůbec nezměnila. Je zcela obecná. Přebírá seznam funkcí realizujících pravidla a volá je v uvedeném pořadí. Nestará se o to, jak jsou pravidla definována. V předcházejícím příkladu byla definována jako pojmenované funkce. Teď jsou funkce pravidel budovány dynamicky zobrazením řetězců ze vstupního seznamu voláním funkce <code>build_match_and_apply_functions()</code>. Na tom ale vůbec nezáleží. Funkce <code>plural()</code> pracuje stále stejným způsobem.
</ol>

<p class=a>&#x2042;

<h2 id=generators-a-file-of-patterns>Soubor vzorků</h2>

<p>Jsme v situaci, kdy už jsme rozpoznali veškeré duplicity v kódu a přešli jsme na dostatečnou úroveň abstrakce. To nám umožnilo definovat pravidla pro vytváření množného čísla v podobě seznamu řetězců. Další logický krok spočívá v uložení těchto řetězců v odděleném souboru. Pravidla (v podobě řetězců) pak mohou být udržována odděleně od kódu, který je používá.

<p>Nejdříve vytvořme textový soubor, který obsahuje požadovaná pravidla. Nebudeme používat žádné efektní datové struktury. Stačí nám tři sloupce řetězců oddělené bílými znaky (whitespace; zde mezery nebo tabulátory). Soubor nazveme <code>plural4-rules.txt</code>.

<p class=d>[<a href="examples/plural4-rules.txt">stáhnout <code>plural4-rules.txt</code></a>]
<pre class='nd pp'><code>[sxz]$               $    es
[^aeioudgkprt]h$     $    es
[^aeiou]y$          y$    ies
$                    $    s</code></pre>

<p>Teď se podívejme na to, jak můžeme soubor s pravidly použít.

<p class=d>[<a href="examples/plural4.py">stáhnout <code>plural4.py</code></a>]
<pre class=pp><code>import re

<a>def build_match_and_apply_functions(pattern, search, replace):  <span class=u>&#x2460;</span></a>
    def matches_rule(word):
        return re.search(pattern, word)
    def apply_rule(word):
        return re.sub(search, replace, word)
    return (matches_rule, apply_rule)

rules = []
<a>with open('plural4-rules.txt', encoding='utf-8') as pattern_file:  <span class=u>&#x2461;</span></a>
<a>    for line in pattern_file:                                      <span class=u>&#x2462;</span></a>
<a>        pattern, search, replace = line.split(None, 3)             <span class=u>&#x2463;</span></a>
<a>        rules.append(build_match_and_apply_functions(              <span class=u>&#x2464;</span></a>
                pattern, search, replace))</code></pre>
<ol>
<li>Funkce <code>build_match_and_apply_functions()</code> se nezměnila. Pro dynamické vytvoření funkcí, které používají proměnné definované vnější funkcí, pořád používáme uzávěry.
<li>Globální funkce <code>open()</code> otvírá soubor a vrací souborový objekt. V tomto případě otvíráme soubor, který obsahuje vzorky řetězců pro převádění podstatných jmen do množného čísla. Příkaz <code>with</code> vytváří takzvaný <i>kontext</i>. Jakmile blok příkazu <code>with</code> skončí, Python soubor automaticky uzavře, a to i v případě, kdyby byla uvnitř bloku <code>with</code> vyvolána výjimka. O blocích <code>with</code> a o souborových objektech se dozvíte více v kapitole <a href=#chapter-files>Soubory</a>.
<li>Obrat <code>for line in &lt;souborový_objekt&gt;</code> čte data z otevřeného souborového objektu řádek po řádku a přiřazuje text do proměnné <var>line</var> (řádek). O čtení ze souboru se dozvíte více v kapitole <a href=#chapter-files>Soubory</a>.
<li>Každý řádek souboru obsahuje tři hodnoty, ale jsou oddělené bílými znaky (tabulátory nebo mezerami, na tom nezáleží). Rozdělíme je použitím řetězcové metody <code>split()</code>. Prvním argumentem metody <code>split()</code> je <code>None</code>, což vyjadřuje požadavek „rozdělit v místech posloupností bílých znaků (tabulátorů nebo mezer, na tom nezáleží)“. Druhým argumentem je hodnota <code>3</code>, což znamená „rozdělit na místě bílých znaků maximálně 3krát a zbytek řádku ponechat beze změny“. Například řádek <code>[sxz]$ $ es</code> bude rozložen na seznam <code>['[sxz]$', '$', 'es']</code>. To znamená, že proměnná <var>pattern</var> získá hodnotu <code>'[sxz]$'</code>, proměnná <var>search</var> hodnotu <code>'$'</code> a proměnná <var>replace</var> hodnotu <code>'es'</code>. V tak krátkém řádku kódu se skrývá docela hodně síly.
<li>Nakonec předáme <code>pattern</code>, <code>search</code> a <code>replace</code> funkci <code>build_match_and_apply_functions()</code>, která vrátí dvojici funkcí. Tuto dvojici připojíme na konec seznamu pravidel, takže nakonec bude <var>rules</var> uchovávat seznam rozhodovacích a aplikačních funkcí, které potřebuje funkce <code>plural()</code>.
</ol>

<p>Zdokonalení spočívá v tom, že jsme pravidla pro vytváření množného čísla podstatných jmen oddělili do vnějšího souboru, který může být udržován odděleně od kódu, který pravidla využívá. Kód se stal kódem, z dat jsou data a život je krásnější.

<p class=a>&#x2042;

<h2 id=generators-generators>Generátory</h2>

<p>Nebylo by skvělé, kdybychom měli obecnou funkci <code>plural()</code>, která si umí sama zpracovat soubor s pravidly? Získala by pravidla, zkontrolovala by, které se má uplatnit, provedla by příslušné transformace, přešla by k dalšímu pravidlu. To je to, co bychom po funkci <code>plural()</code> chtěli. A to je to, co by funkce <code>plural()</code> měla dělat.

<p class=d>[<a href="examples/plural5.py">stáhnout <code>plural5.py</code></a>]
<pre class='nd pp'><code>def rules(rules_filename):
    with open(rules_filename, encoding='utf-8') as pattern_file:
        for line in pattern_file:
            pattern, search, replace = line.split(None, 3)
            yield build_match_and_apply_functions(pattern, search, replace)

def plural(noun, rules_filename='plural5-rules.txt'):
    for matches_rule, apply_rule in rules(rules_filename):
        if matches_rule(noun):
            return apply_rule(noun)
    raise ValueError('no matching rule for {0}'.format(noun))</code></pre>

<p>Jak sakra funguje <em>tohle</em>? Podívejme se nejdříve na interaktivní příklad.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>def make_counter(x):</kbd>
<samp class=p>... </samp><kbd class=pp>    print('entering make_counter')</kbd>
<samp class=p>... </samp><kbd class=pp>    while True:</kbd>
<a><samp class=p>... </samp><kbd class=pp>        yield x</kbd>                    <span class=u>&#x2460;</span></a>
<samp class=p>... </samp><kbd class=pp>        print('incrementing x')</kbd>
<samp class=p>... </samp><kbd class=pp>        x = x + 1</kbd>
<samp class=p>... </samp>
<a><samp class=p>>>> </samp><kbd class=pp>counter = make_counter(2)</kbd>          <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>counter</kbd>                            <span class=u>&#x2462;</span></a>
&lt;generator object at 0x001C9C10>
<a><samp class=p>>>> </samp><kbd class=pp>next(counter)</kbd>                      <span class=u>&#x2463;</span></a>
<samp>entering make_counter
2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>next(counter)</kbd>                      <span class=u>&#x2464;</span></a>
<samp>incrementing x
3</samp>
<a><samp class=p>>>> </samp><kbd class=pp>next(counter)</kbd>                      <span class=u>&#x2465;</span></a>
<samp>incrementing x
4</samp></pre>
<ol>
<li>Přítomnost klíčového slova <code>yield</code> v <code>make_counter</code> znamená, že nejde o obyčejnou funkci. Jde o speciální druh funkce, která generuje hodnoty jednu po druhé. Můžeme si ji představit jako funkci, která umí při dalším volání pokračovat v činnosti. Když ji zavoláme, vrátí nám <i>generátor</i>, který můžeme použít pro generování posloupnosti hodnot <var>x</var>.
<li>Instanci generátoru <code>make_counter</code> vytvoříme tím, že ji zavoláme jako každou jinou funkci. Poznamenejme, že tím ve skutečnosti nedojde k provedení kódu funkce. Jde to poznat i podle toho, že se na prvním řádku funkce <code>make_counter()</code> volá <code>print()</code>, ale nic se zatím nevytisklo.
<li>Funkce <code>make_counter()</code> vrátila objekt generátoru.
<li>Funkce <code>next()</code> přebírá objekt generátoru a vrací jeho další hodnotu. Při prvním volání funkce <code>next()</code> pro generátor <var>counter</var> se provede kód z <code>make_counter()</code> až do prvního příkazu <code>yield</code> a vrátí se vyprodukovaná hodnota. V našem případě to bude <code>2</code>, protože jsme generátor vytvořili voláním <code>make_counter(2)</code>.
<li>Při opakovaném volání funkce <code>next()</code> pro stejný generátorový objekt se dostáváme přesně do místa, kde jsme minule skončili, a pokračujeme až do místa, kdy znovu narazíme na příkaz <code>yield</code>. Při provedení <code>yield</code> jsou všechny proměnné, lokální stav a další věci uloženy a při dalším volání <code>next()</code> jsou obnoveny. Další řádek kódu, který čeká na provedení, volá funkci <code>print()</code>, která vytiskne <samp>incrementing x</samp> (zvyšuji hodnotu x). Poté je proveden příkaz <code>x = x + 1</code>. Pak se provede další obrátka cyklu <code>while</code> a hned se narazí na příkaz <code>yield x</code>. Ten uloží stav všeho možného a vrátí aktuální hodnotu proměnné <var>x</var> (v tomto okamžiku <code>3</code>).
<li>Při druhém volání <code>next(counter)</code> se vše opakuje, ale tentokrát má <var>x</var> hodnotu <code>4</code>.
</ol>

<p>Protože <code>make_counter</code> definuje nekonečný cyklus, mohli bychom pokračovat teoreticky do nekonečna a docházelo by k neustálému zvyšování proměnné <var>x</var> a vracení její hodnoty. Místo toho se ale podívejme na užitečnější použití generátorů.

<h3 id=generators-a-fibonacci-generator>Generátor Fibonacciho posloupnosti</h3>

<aside>„yield“ funkci zastaví. „next()“ pokračuje od místa zastavení.</aside>

<p class=d>[<a href="examples/fibonacci.py">stáhnout <code>fibonacci.py</code></a>]
<pre class=pp><code>def fib(max):
<a>    a, b = 0, 1          <span class=u>&#x2460;</span></a>
    while a &lt; max:
<a>        yield a          <span class=u>&#x2461;</span></a>
<a>        a, b = b, a + b  <span class=u>&#x2462;</span></a></code></pre>
<ol>
<li>Fibonacciho posloupnost je řada čísel, kde každé další číslo je součtem dvou předchozích. Začíná hodnotami <code>0</code> a <code>1</code>, zpočátku roste pomalu a pak rychleji a rychleji. Na začátku potřebujeme dvě proměnné: <var>a</var> s počáteční hodnotou <code>0</code> a <var>b</var> s počáteční hodnotou <code>1</code>.
<li>Proměnná <var>a</var> obsahuje aktuální číslo posloupnosti, takže hodnotu vyprodukujeme (yield).
<li>Proměnná <var>b</var> představuje další číslo v posloupnosti, takže je přiřadíme do <var>a</var>, ale současně vypočteme další hodnotu (<code>a + b</code>) a přiřadíme ji do <var>b</var> pro pozdější použití. Poznamenejme, že se to děje paralelně. Pokud má <var>a</var> hodnotu <code>3</code> a <var>b</var> hodnotu <code>5</code>, pak <code>a, b = b, a + b</code> nastaví <var>a</var> na <code>5</code> (předchozí hodnota <var>b</var>) a <var>b</var> na <code>8</code> (součet předchozí hodnoty <var>a</var> a <var>b</var>).
</ol>

<p>Dostali jsme funkci, která postupně chrlí Fibonacciho čísla. Mohli byste to popsat i rekurzivním řešením, ale tento způsob je čitelnější. A navíc dobře funguje při použití v cyklech <code>for</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>from fibonacci import fib</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>for n in fib(1000):</kbd>      <span class=u>&#x2460;</span></a>
<a><samp class=p>... </samp><kbd class=pp>    print(n, end=' ')</kbd>    <span class=u>&#x2461;</span></a>
<samp class=pp>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(fib(1000))</kbd>          <span class=u>&#x2462;</span></a>
<samp class=pp>[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]</samp></pre>
<ol>
<li>Generátor jako <code>fib()</code> můžete v cyklu <code>for</code> použít přímo. Cyklus <code>for</code> automaticky získává hodnoty generátoru <code>fib()</code> voláním funkce <code>next()</code> a přiřazuje je do proměnné cyklu <var>n</var>.
<li>Při každé obrátce cyklu <code>for</code> získává proměnná <var>n</var> novou hodnotu, která je uvnitř <code>fib()</code> produkována příkazem <code>yield</code>. Stačí ji jen vytisknout. Jakmile <code>fib()</code> dojdou čísla (<var>a</var> nabude hodnoty větší než <var>max</var>, což je v našem případě <code>1000</code>), cyklus <code>for</code> elegantně skončí.
<li>Toto je užitečný obrat. Funkci <code>list()</code> předáme generátor. Funkce projde (iteruje přes) všechny jeho hodnoty (stejně jako tomu bylo v předchozím příkladu u cyklu <code>for</code>) a vrátí seznam všech generovaných hodnot.
</ol>

<h3 id=generators-a-plural-rule-generator>Generátor pravidel pro množné číslo</h3>

<p>Vraťme se k <code>plural5.py</code> a podívejme se, jak tato verze funkce <code>plural()</code> pracuje.

<pre class=pp><code>def rules(rules_filename):
    with open(rules_filename, encoding='utf-8') as pattern_file:
        for line in pattern_file:
<a>            pattern, search, replace = line.split(None, 3)                   <span class=u>&#x2460;</span></a>
<a>            yield build_match_and_apply_functions(pattern, search, replace)  <span class=u>&#x2461;</span></a>

def plural(noun, rules_filename='plural5-rules.txt'):
<a>    for matches_rule, apply_rule in rules(rules_filename):                   <span class=u>&#x2462;</span></a>
        if matches_rule(noun):
            return apply_rule(noun)
    raise ValueError('no matching rule for {0}'.format(noun))</code></pre>
<ol>
<li>Není v tom žádná magie. Vzpomeňte si, že řádky souboru s pravidly obsahují vždy tři hodnoty oddělené bílými znaky. Takže použijeme <code>line.split(None, 3)</code> k získání tří „sloupců“ a jejich hodnoty přiřadíme do tří lokálních proměnných.
<li><em>A pak vyprodukujeme výsledek (yield).</em> Jaký výsledek? Dvojici funkcí, které byly dynamicky vytvořeny naší starou známou funkcí <code>build_match_and_apply_functions()</code> (je stejná jako v předchozích příkladech). Řečeno jinak, <code>rules()</code> je generátor, který <em>na požádání</em> produkuje rozhodovací a aplikační funkce.
<li>Protože <code>rules()</code> je generátor, můžeme jej přímo použít v cyklu <code>for</code>. Při první obrátce cyklu <code>for</code> zavoláme funkci <code>rules()</code>, která otevře soubor se vzorky, načte první řádek, na základě vzorků uvedených na řádku dynamicky vybuduje rozhodovací funkci a aplikační funkci a tyto funkce vrátí (yield). Ale během druhé obrátky cyklu <code>for</code> se dostáváme přesně do místa, kde jsme kód <code>rules()</code> opustili (což je uprostřed cyklu <code>for line in pattern_file</code>). První věcí, která se provede, bude načtení řádku souboru (který je pořád otevřen). Na základě vzorků z tohoto řádku souboru se dynamicky vytvoří další rozhodovací a aplikační funkce a tato dvojice se vrátí (yield).
</ol>

<p>Co jsme vlastně proti verzi 4 získali navíc? Startovací čas. Ve verzi 4 se při importu modulu <code>plural4</code> &mdash; než jsme mohli vůbec uvažovat o volání funkce <code>plural()</code> &mdash; načítal celý soubor vzorků a budoval se seznam všech možných pravidel. Při použití generátorů můžeme vše dělat na poslední chvíli. Přečteme si první pravidlo, vytvoříme funkce a vyzkoušíme je. Pokud to funguje, nemusíme číst zbytek souboru nebo vytvářet další funkce.

<p>A co jsme ztratili? Výkonnost! Generátor <code>rules()</code> startuje znovu od začátku pokaždé, když voláme funkci <code>plural()</code>. To znamená, že soubor se vzorky musí být znovu otevřen a musíme číst od začátku, jeden řádek po druhém.

<p>Chtělo by to nějak získat to nejlepší z obou řešení: minimální čas při startu (žádné provádění kódu při <code>import</code>) a maximální výkonnost (žádné opakované vytváření funkcí). Ale pokud nebudeme muset číst stejné řádky dvakrát, bylo by dobré, aby pravidla mohla zůstat v odděleném souboru (protože kód je kód a data jsou data).

<p>Abychom toho dosáhli, budeme muset vytvořit svůj vlastní iterátor. Ale předtím se musíme naučit něco o pythonovských třídách.

<p class=a>&#x2042;

<h2 id=generators-furtherreading>Přečtěte si</h2>
<ul>
<li><a href="http://www.python.org/dev/peps/pep-0255/">PEP 255: Simple Generators</a>
<li><a href="http://effbot.org/zone/python-with-statement.htm">Understanding Python’s “with” statement</a>
<li><a href="http://ynniv.com/blog/2007/08/closures-in-python.html">Closures in Python</a>
<li><a href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers</a>
<li><a href="http://www2.gsu.edu/~wwwesl/egw/crump.htm">English Irregular Plural Nouns</a>
</ul>

</div>
<div id=chapter-iterators>
<h1>Třídy a iterátory</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> East is East, and West is West, and never the twain shall meet. <span class="u">&#x275E;</span><br>(Východ je východ, západ je západ a ta dvojice se nikdy nesetká.)<br>&mdash; <a href="http://en.wikiquote.org/wiki/Rudyard_Kipling">Rudyard Kipling</a>
</blockquote>
<p>&nbsp;
<h2 id=iterators-divingin>Ponořme se</h2>
<p class=f>Iterátory jsou „tajnou omáčkou“ Pythonu 3. Jsou všude, vše je na nich založeno, vždy zůstávají v pozadí, neviditelné. <a href=#chapter-comprehensions>Generátorové notace</a> jsou jednoduchou formou <i>iterátorů</i>. Generátory jsou jednoduchou formou <i>iterátorů</i>. Funkce, která produkuje hodnoty příkazem <code>yield</code>, je ukázkou pěkného a kompaktního způsobu vytvoření iterátoru, aniž bychom museli iterátor tvořit. Ukážu vám, co tím míním.

<p>Vzpomínáte si na <a href=#generators-a-fibonacci-generator>Fibonacciho generátor</a>? Tady ho máme v podobě iterátoru vytvořeného od základu:

<p class=d>[<a href="examples/fibonacci2.py">stáhnout <code>fibonacci2.py</code></a>]
<pre class=pp><code>class Fib:
    '''iterator that yields numbers in the Fibonacci sequence'''

    def __init__(self, max):
        self.max = max

    def __iter__(self):
        self.a = 0
        self.b = 1
        return self

    def __next__(self):
        fib = self.a
        if fib > self.max:
            raise StopIteration
        self.a, self.b = self.b, self.a + self.b
        return fib</code></pre>

<p>Proberme si jeho kód řádek po řádku.

<pre class='nd pp'><code>class Fib:</code></pre>

<p><code>class</code>? Česky se tomu říká <em>třída</em>. Ale co to je?

<p class=a>&#x2042;

<h2 id=iterators-defining-classes>Definice tříd</h2>

<p>Python je plně objektově orientovaný. Můžete definovat své vlastní třídy, dědit ze svých vlastních nebo ze zabudovaných tříd a z definovaných tříd můžete vytvářet instance.

<p>Třídu definujeme v Pythonu jednoduše. Nepoužívá se zde oddělená definice rozhraní &mdash; je to jako u funkcí. Prostě definujeme třídu a začneme psát její kód. Pythonovská třída začíná vyhrazeným slovem <code>class</code>, za kterým následuje jméno třídy. Z technického pohledu je to vše, co se vyžaduje, protože třída nemusí dědit z žádné jiné třídy.

<pre class=pp><code><a>class PapayaWhip:  <span class=u>&#x2460;</span></a>
<a>    pass           <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>Jméno této třídy je <code>PapayaWhip</code>. Není odvozena od žádné jiné třídy. Jména tříd se obvykle zapisují s velkými písmeny u slov názvu, <code>KazdeSlovoNazvuTakto</code>. Ale je to jen konvence, není to závazné.
<li>Asi už jste odhadli, že vše uvnitř třídy je odsazené &mdash; podobně jako kód uvnitř funkce, v příkazu <code>if</code>, u cyklu <code>for</code> nebo v případě jakéhokoliv jiného bloku kódu. Řádek, který není odsazen, už do třídy nepatří.
</ol>

<p>Třída <code>PapayaWhip</code> nedefinuje žádnou metodu ani atributy, ale ze syntaktických důvodů v definici něco být musí. Proto jsme zde použili příkaz <code>pass</code>. V Pythonu je toto slovo vyhrazeno a znamená „pokračuj dál, tady není nic k vidění“. Je to příkaz, který nic nedělá. Hodí se nám právě v případech, kdy potřebujeme napsat funkci nebo třídu, která existuje, ale nic nedělá.

<blockquote class='note compare java'>
<p><span class="u">&#x261E;</span>Příkaz <code>pass</code> znamená v Pythonu totéž co prázdné složené závorky (<code>{}</code>) v jazycích Java nebo C.
</blockquote>

<p>Mnohé třídy dědí z jiných tříd, ale to není náš případ. Mnohé třídy definují metody, ale tato ne. Pythonovská třída nemusí mít nic, jen jméno. Obzvláště programátorům v C++ může přijít divné, že pythonovské třídy nemají explicitní konstruktory a destruktory. Ačkoliv se to nevyžaduje, pythonovské třídy <em>mohou</em> mít něco, co se konstruktoru podobá. Je to metoda <code>__init__()</code>.

<h3 id=iterators-init-method>Metoda <code>__init__()</code></h3>

<p>Následující příklad ukazuje inicializaci třídy <code>Fib</code> s využitím metody <code>__init__</code>.

<pre class=pp><code>class Fib:
<a>    '''iterator that yields numbers in the Fibonacci sequence'''  <span class=u>&#x2460;</span></a>

<a>    def __init__(self, max):                                      <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>Třídy mohou (a měly by) mít své dokumentační řetězce &mdash; stejně jako moduly a funkce.
<li>Metoda <code>__init__()</code> je zavolána bezprostředně po vytvoření instance třídy. Svádí nás to, abychom ji nazývali „konstruktorem“ třídy, ale z technického hlediska to není pravda. Svádí nás to, protože vypadá jako C++ konstruktor (konvence říká, že by metoda <code>__init__()</code> měla být v definici třídy uvedena jako první), chová se jako konstruktor (je to první kousek kódu, který se v nově vytvořené instanci třídy provádí) a vůbec. Chyba! V době volání metody <code>__init__()</code> už byl objekt zkonstruován (už existoval) a na novou instanci třídy už máme platný odkaz.
</ol>

<p>Prvním argumentem metody třídy je vždy odkaz na aktuální instanci třídy a platí to i pro metodu <code>__init__()</code>. Podle konvence je tento argument pojmenován <var>self</var>. Plní roli vyhrazeného slova, jakým je <code>this</code> v jazycích <abbr>C++</abbr> nebo Java, ale v Pythonu není <var>self</var> vyhrazeným slovem. Je to jen konvenční pojmenování. Přesto jej, prosím vás, nenazývejte nikdy jinak než <var>self</var>. Jde o velmi silnou konvenci.

<p>U všech metod třídy odkazuje argument <var>self</var> na instanci třídy, jejíž metoda byla zavolána. Ale konkrétně v případě metody <code>__init__()</code> je tato instance (jejíž metoda byla zavolána) nově vytvořeným objektem. V okamžiku definice metody musíme uvést <var>self</var> explicitně. Ale v okamžiku volání metody už tento argument <em>neuvádíme</em>. Python ho přidá za nás automaticky.

<p class=a>&#x2042;

<h2 id=iterators-instantiating-classes>Vytváření instancí tříd</h2>

<p>Vytváření instancí tříd je v Pythonu přímočaré. Jednoduše zavoláme třídu, jako kdyby to byla funkce, a předáme jí argumenty, které vyžaduje metoda <code>__init__()</code>. Vrátí se nám nově vytvořený objekt.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import fibonacci2</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>fib = fibonacci2.Fib(100)</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>fib</kbd>                        <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;fibonacci2.Fib object at 0x00DB8810></samp>
<a><samp class=p>>>> </samp><kbd class=pp>fib.__class__</kbd>              <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;class 'fibonacci2.Fib'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>fib.__doc__</kbd>                <span class=u>&#x2463;</span></a>
<samp class=pp>'iterator that yields numbers in the Fibonacci sequence'</samp></pre>
<ol>
<li>Vytváříme instanci třídy <code>Fib</code> (definované v modulu <code>fibonacci2</code>) a nově vytvořenou instanci přiřazujeme do proměnné <var>fib</var>. Předáváme jeden parametr (<code>100</code>), který se při volání metody <code>__init__()</code> třídy <code>Fib</code> stane jejím argumentem <var>max</var>.
<li><var>fib</var> je nyní instancí třídy <code>Fib</code>.
<li>Každá instance třídy má zabudovaný atribut <code>__class__</code>, který odkazuje na třídu objektu. Programátoři v Javě možná znají třídu <code>Class</code>. Ta poskytuje metody jako <code>getName()</code> a <code>getSuperclass()</code>, které nám zpřístupňují metainformace o objektu. V Pythonu je tento druh metadat přístupný prostřednictvím atributů, ale základní myšlenka je stejná.
<li>Dokumentační řetězec instance můžeme zpřístupnit stejně jako u funkce nebo u modulu. Všechny instance třídy sdílejí stejný <code>docstring</code>.
</ol>

<blockquote class='note compare java'>
<p><span class="u">&#x261E;</span>Novou instanci třídy v Pythonu vytvoříme jednoduše zavoláním třídy, jako kdyby to byla funkce. Nenajdeme zde žádný explicitní operátor <code>new</code>, jako je tomu u jazyků <abbr>C++</abbr> nebo Java.
</blockquote>

<p class=a>&#x2042;

<h2 id=iterators-instance-variables>Členské proměnné</h2>

<p>Pokračujeme k dalšímu řádku:

<pre class=pp><code>class Fib:
    def __init__(self, max):
<a>        self.max = max        <span class=u>&#x2460;</span></a></code></pre>
<ol>
<li>Co to je <var>self.max</var>? Jde o členskou proměnnou (nebo také instanční proměnnou nebo proměnnou instance). Je to něco zcela jiného než argument <var>max</var>, který byl předán metodě <code>__init__()</code>. <var>self.max</var> je „globální“ v rámci instance. To znamená, že k této proměnné můžeme přistupovat z jiných metod.
</ol>

<pre class=pp><code>class Fib:
    def __init__(self, max):
<a>        self.max = max        <span class=u>&#x2460;</span></a>
    .
    .
    .
    def __next__(self):
        fib = self.a
<a>        if fib > self.max:    <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li><var>self.max</var> je definována metodou <code>__init__()</code>&hellip;
<li>&hellip; a odkazujeme se na ni v metodě <code>__next__()</code>.
</ol>

<p>Členské proměnné jsou pro každou instanci třídy specifické. Pokud například vytvoříme dvě instance třídy <code>Fib</code> s různými hodnotami maxima, bude si každá z nich pamatovat svou vlastní hodnotu.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import fibonacci2</kbd>
<samp class=p>>>> </samp><kbd class=pp>fib1 = fibonacci2.Fib(100)</kbd>
<samp class=p>>>> </samp><kbd class=pp>fib2 = fibonacci2.Fib(200)</kbd>
<samp class=p>>>> </samp><kbd class=pp>fib1.max</kbd>
<samp class=pp>100</samp>
<samp class=p>>>> </samp><kbd class=pp>fib2.max</kbd>
<samp class=pp>200</samp></pre>

<p class=a>&#x2042;

<h2 id=iterators-a-fibonacci-iterator>Fibonacciho iterátor</h2>

<p><em>Až teď</em> jsme připraveni se naučit, jak se vytváří interátor. Iterátor je jednoduše třída, která definuje metodu <code>__iter__()</code>.

<aside class=ots>
Všechny tři z uvedených metod třídy, <code>__init__</code>, <code>__iter__</code> a <code>__next__</code>, začínají a končí dvojicí znaků podtržení (<code>_</code>). Proč zrovna takhle? Není v tom nic magického, ale obvykle to naznačuje, že jde o „<dfn>speciální metody</dfn>“. Jedinou „speciální“ věcí je na těchto speciálních metodách to, že se nevolají přímo. Python je volá, když použijete nějaký jiný syntaktický obrat pro třídu nebo pro instanci třídy. <a href=#chapter-special-method-names>Více o speciálních metodách&hellip;</a>.
</aside>

<p class=d>[<a href="examples/fibonacci2.py">stáhnout <code>fibonacci2.py</code></a>]
<pre class=pp><code><a>class Fib:                                        <span class=u>&#x2460;</span></a>
<a>    def __init__(self, max):                      <span class=u>&#x2461;</span></a>
        self.max = max

<a>    def __iter__(self):                           <span class=u>&#x2462;</span></a>
        self.a = 0
        self.b = 1
        return self

<a>    def __next__(self):                           <span class=u>&#x2463;</span></a>
        fib = self.a
        if fib > self.max:
<a>            raise StopIteration                   <span class=u>&#x2464;</span></a>
        self.a, self.b = self.b, self.a + self.b
<a>        return fib                                <span class=u>&#x2465;</span></a></code></pre>
<ol>
<li>Abychom vybudovali iterátor od základů, musíme z <code>Fib</code> udělat třídu, a ne funkci.
<li>„Volání“ <code>Fib(max)</code> ve skutečnosti znamená vytvoření instance této třídy a zavolání její metody <code>__init__()</code> s argumentem <var>max</var>. Metoda <code>__init__()</code> uloží maximální hodnotu do členské proměnné, takže se na ni mohou později odkazovat ostatní metody.
<li>Metoda <code>__iter__()</code> se volá, kdykoliv někdo zavolá <code>iter(fib)</code>. (Jak uvidíme za minutku, cyklus <code>for</code> ji volá automaticky. Ale vy sami ji můžete volat také, ručně.) Po provedení inicializace na začátku iterace (v tomto případě jde o nastavení počátečního stavu dvou počítadel <code>self.a</code> a <code>self.b</code>) může metoda <code>__iter__()</code> vrátit libovolný objekt, který implementuje metodu <code>__next__()</code>. V našem případě (a ve většině případů) metoda <code>__iter__()</code> vrátí jednoduše <var>self</var>, protože tato třída implementuje svou vlastní metodu <code>__next__()</code>.
<li>Metoda <code>__next__()</code> se volá vždy, když někdo zavolá funkci <code>next()</code> s iterátorem instance třídy. Za minutku to bude dávat větší smysl.
<li>Když metoda <code>__next__()</code> vyvolá výjimku <code>StopIteration</code>, signalizuje tím volajícímu, že iterace skončila. Na rozdíl od většiny jiných výjimek se zde nesignalizuje chyba. Jde o běžnou situaci, která prostě znamená, že iterátor už nemá žádná data, která by generoval. Pokud je volajícím cyklus <code>for</code>, bude výjimka <code>StopIteration</code> zachycena a cyklus bude bezproblémově ukončen. (Jinými slovy, cyklus výjimku spolkne.) Toto malé kouzlo je ve skutečnosti klíčem k použití iterátorů v cyklech <code>for</code>.
<li>Vyprodukování další hodnoty provede iterátor tak, že metoda <code>__next__()</code> hodnotu jednoduše vrátí příkazem <code>return</code>. Nepoužívejte zde příkaz <code>yield</code>. Ten je pouze syntaktickým cukrátkem a má význam pouze v souvislosti s generátory. Zde vytváříme od základů svůj vlastní iterátor, proto budeme používat <code>return</code>.
</ol>

<p>Už jste úplně zmatení? Výborně. Podívejme se, jak budeme iterátor volat:

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>from fibonacci2 import Fib</kbd>
<samp class=p>>>> </samp><kbd class=pp>for n in Fib(1000):</kbd>
<samp class=p>... </samp><kbd class=pp>    print(n, end=' ')</kbd>
<samp class=pp>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</samp></pre>

<p>Cože? Vždyť je to úplně stejné! V každém bajtu se to shoduje s voláním <a href=#generators-a-fibonacci-generator>generátoru Fibonacciho posloupnosti</a> (až na rozdíl jednoho velkého písmene). Ale jak je to možné?

<p>Cykly <code>for</code> v sobě skrývají trochu magie. Odehrává se v nich následující:

<ul>
<li>Cyklus <code>for</code> volá <code>Fib(1000)</code>, jak je vidět z kódu. Vrací se instance třídy <code>Fib</code>. Říkejme jí třeba <var>fib_inst</var>.
<li>Cyklus <code>for</code> potají a docela chytře volá funkci <code>iter(fib_inst)</code>, která vrátí objekt iterátoru. Říkejme mu třeba <var>fib_iter</var>. V našem případě platí <var>fib_iter</var> == <var>fib_inst</var>, protože metoda <code>__iter__()</code> vrací <var>self</var>. Ale o tom cyklus <code>for</code> neví (a je mu to jedno).
<li>Za účelem „průchodu hodnotami“ iterátoru volá cyklus <code>for</code> funkci <code>next(fib_iter)</code>, která zase volá metodu <code>__next__()</code> objektu <code>fib_iter</code>. Ta provede výpočet dalšího Fibonacciho čísla a vrací hodnotu. Cyklus <code>for</code> hodnotu převezme, přiřadí ji do proměnné <var>n</var> a s touto hodnotou v <var>n</var> provede tělo cyklu.
<li>Jak cyklus <code>for</code> ví, kdy má skončit? To jsem rád, že jste se zeptali! Když <code>next(fib_iter)</code> vyvolá výjimku <code>StopIteration</code>, cyklus <code>for</code> ji spolkne a spořádaně se ukončí. (Jakákoliv jiná výjimka se propustí a projeví se obvyklým způsobem.) A kde jsme zahlédli výjimku <code>StopIteration</code>? No přece v metodě <code>__next__()</code>!
</ul>

<p class=a>&#x2042;

<h2 id=iterators-a-plural-rule-iterator>Iterátor pro pravidla množného čísla</h2>

<aside>iter(f) volá f.__iter__<br>next(f) volá f.__next__</aside>
<p>Přišel čas na finále. Přepišme <a href=#chapter-generators>generátor pravidel pro množné číslo</a> do podoby iterátoru.

<p class=d>[<a href="examples/plural6.py">stáhnout <code>plural6.py</code></a>]
<pre class=pp><code>class LazyRules:
    rules_filename = 'plural6-rules.txt'

    def __init__(self):
        self.pattern_file = open(self.rules_filename, encoding='utf-8')
        self.cache = []

    def __iter__(self):
        self.cache_index = 0
        return self

    def __next__(self):
        self.cache_index += 1
        if len(self.cache) >= self.cache_index:
            return self.cache[self.cache_index - 1]

        if self.pattern_file.closed:
            raise StopIteration

        line = self.pattern_file.readline()
        if not line:
            self.pattern_file.close()
            raise StopIteration

        pattern, search, replace = line.split(None, 3)
        funcs = build_match_and_apply_functions(
            pattern, search, replace)
        self.cache.append(funcs)
        return funcs

rules = LazyRules()</code></pre>

<p>Tohle je tedy třída, která implementuje metody <code>__iter__()</code> a <code>__next__()</code>, takže ji můžeme použít jako iterátor. Za koncem její definice se vytvoří instance třídy a přiřadí se do <var>rules</var>. To se stane jen jednou, při importu.

<p>Proberme si zmíněnou třídu po kouscích.

<pre class=pp><code>class LazyRules:
    rules_filename = 'plural6-rules.txt'

    def __init__(self):
<a>        self.pattern_file = open(self.rules_filename, encoding='utf-8')  <span class=u>&#x2460;</span></a>
<a>        self.cache = []                                                  <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>Když vytvoříme instanci třídy <code>LazyRules</code> (líná pravidla), otevře se soubor s definicemi vzorků, ale nic se z něj nečte. (K tomu dojde později.)
<li>Po otevření souboru se inicializuje vyrovnávací paměť (cache). Budeme ji používat později, během čtení řádků ze souboru vzorků (v metodě <code>__next__()</code>).
</ol>

<p>Než budeme pokračovat, podívejme se podrobněji na <var>rules_filename</var>. Tato proměnná není definována uvnitř metody <code>__init__()</code>. Ve skutečnosti není definována uvnitř <em>žádné</em> metody. Je definována na úrovni třídy. Jde o <i>proměnnou třídy</i>. Ačkoliv k ní můžeme přistupovat stejným způsobem jako k nějaké členské proměnné (<var>self.rules_filename</var>), sdílí ji všechny instance třídy <code>LazyRules</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import plural6</kbd>
<samp class=p>>>> </samp><kbd class=pp>r1 = plural6.LazyRules()</kbd>
<samp class=p>>>> </samp><kbd class=pp>r2 = plural6.LazyRules()</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>r1.rules_filename</kbd>                               <span class=u>&#x2460;</span></a>
<samp class=pp>'plural6-rules.txt'</samp>
<samp class=p>>>> </samp><kbd class=pp>r2.rules_filename</kbd>
<samp class=pp>'plural6-rules.txt'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>r2.rules_filename = 'r2-override.txt'</kbd>           <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>r2.rules_filename</kbd>
<samp class=pp>'r2-override.txt'</samp>
<samp class=p>>>> </samp><kbd class=pp>r1.rules_filename</kbd>
<samp class=pp>'plural6-rules.txt'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>r2.__class__.rules_filename</kbd>                     <span class=u>&#x2462;</span></a>
<samp class=pp>'plural6-rules.txt'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>r2.__class__.rules_filename = 'papayawhip.txt'</kbd>  <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>r1.rules_filename</kbd>
<samp class=pp>'papayawhip.txt'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>r2.rules_filename</kbd>                               <span class=u>&#x2464;</span></a>
<samp class=pp>'r2-overridetxt'</samp></pre>
<ol>
<li>Každá instance třídy dědí atribut <var>rules_filename</var> s hodnotou definovanou na úrovni třídy.
<li>Když změníme hodnotu tohoto atributu v jedné instanci, neovlivníme tím ostatní instance&hellip;
<li>&hellip;a ani neovlivníme atribut třídy. K atributu třídy (v protikladu k atributu jednotlivých instancí) můžeme přistupovat prostřednictvím speciálního atributu <code>__class__</code>, který zpřístupňuje třídu jako takovou.
<li>Pokud změníte hodnotu atributu třídy, pak to ovlivní všechny instance, které tuto hodnotu dosud dědí (zde <var>r1</var>).
<li>Instance, které tento atribut přepsaly (zde <var>r2</var>), ovlivněny nebudou.
</ol>

<p>Ale zpět k naší ukázce.

<pre class=pp><code><a>    def __iter__(self):       <span class=u>&#x2460;</span></a>
        self.cache_index = 0
<a>        return self           <span class=u>&#x2461;</span></a>
</code></pre>
<ol>
<li>Metoda <code>__iter__()</code> bude volána pokaždé, když někdo (dejme tomu cyklus <code>for</code>) zavolá <code>iter(rules)</code>.
<li>Jednou z věcí, kterou musí každá metoda <code>__iter__()</code> udělat, je vrácení iterátoru. V tomto případě se vrací <var>self</var>, čímž dáváme najevo, že tato třída definuje nějakou metodu <code>__next__()</code>, která se postará o vracení hodnot během iterace.
</ol>

<pre class=pp><code><a>    def __next__(self):                                 <span class=u>&#x2460;</span></a>
        .
        .
        .
        pattern, search, replace = line.split(None, 3)
<a>        funcs = build_match_and_apply_functions(        <span class=u>&#x2461;</span></a>
            pattern, search, replace)
<a>        self.cache.append(funcs)                        <span class=u>&#x2462;</span></a>
        return funcs</code></pre>
<ol>
<li>Metoda <code>__next__()</code> bude volána pokaždé, když někdo (dejme tomu cyklus <code>for</code>) zavolá <code>next(rules)</code>. Smysl této metody pochopíme, když začneme od jejího konce a půjdeme pozpátku. Takže pojďme na to.
<li>Poslední část této funkce by vám měla být přinejmenším povědomá. Funkce <code>build_match_and_apply_functions()</code> se nezměnila. Je pořád stejná, jako vždycky byla.
<li>Jediný rozdíl spočívá v tom, že před vrácením rozhodovací a aplikační funkce (jsou uloženy v dvojici <var>funcs</var>) je nejdříve uložíme do <code>self.cache</code>.
</ol>

<p>Posuňme se zpět&hellip;

<pre class=pp><code>    def __next__(self):
        .
        .
        .
<a>        line = self.pattern_file.readline()  <span class=u>&#x2460;</span></a>
<a>        if not line:                         <span class=u>&#x2461;</span></a>
            self.pattern_file.close()
<a>            raise StopIteration              <span class=u>&#x2462;</span></a>
        .
        .
        .</code></pre>
<ol>
<li>Tady použijeme fintu se souborem pro trošku pokročilejší. Metoda <code>readline()</code> (poznámka: jednotné číslo, nikoliv množné <code>readlines()</code>) přečte z otevřeného souboru přesně jeden řádek. Přesněji řečeno, přečte další řádek. (<em>Souborové objekty jsou také iterátory! Iterátory jsou všude, až po základy&hellip;</em>)
<li>Pokud mohla <code>readline()</code> přečíst řádek do proměnné <var>line</var>, bude to neprázdný řetězec. Dokonce i kdyby soubor obsahoval prázdný řádek, skončí <var>line</var> jako jednoznakový řetězec <code>'\n'</code> (znak konce řádku). Pokud se v proměnné <var>line</var> opravdu nachází prázdný řetězec, znamená to, že soubor už neobsahuje žádné další řádky ke čtení.
<li>Když dosáhneme konce souboru, měli bychom soubor zavřít a vyvolat magickou výjimku <code>StopIteration</code>. Připomeňme si, že do tohoto bodu jsme se dostali, protože jsme potřebovali rozhodovací a aplikační funkci pro další pravidlo. Další pravidlo je definované dalším řádkem souboru&hellip; Ale další řádek už nemáme! Takže už nemáme co vrátit. Iterace skončila. (The iteration is over. <a href="http://www.youtube.com/watch?v=YV5ynRFzrIM"><span class="u">&#x266B;</span> The party’s over&hellip; <span class="u">&#x266B;</span></a>)
</ol>

<p>A jdeme pozpátku až k začátku metody <code>__next__()</code>&hellip;

<pre class=pp><code>    def __next__(self):
        self.cache_index += 1
        if len(self.cache) >= self.cache_index:
<a>            return self.cache[self.cache_index - 1]     <span class=u>&#x2460;</span></a>

        if self.pattern_file.closed:
<a>            raise StopIteration                         <span class=u>&#x2461;</span></a>
        .
        .
        .</code></pre>
<ol>
<li><code>self.cache</code> bude mít podobu seznamu funkcí, které potřebujeme pro rozhodování a aplikaci jednotlivých pravidel. (Přinejmenším <em>tohle</em> by vám mělo být povědomé!) V <code>self.cache_index</code> se pamatuje, která další (už zapamatovaná) položka se má vrátit příště. Pokud jsme dosud nevyčerpali prostor se zapamatovanými položkami (tj. pokud je délka <code>self.cache</code> větší než <code>self.cache_index</code>), pak jsme ji našli (cache hit)! Hurá! Rozhodovací a aplikační funkci můžeme vrátit z vyrovnávací paměti a nemusíme je budovat znovu.
<li>Na druhou stranu, pokud jsme na položku ve vyrovnávací paměti nenarazili <em>a zároveň</em> je souborový objekt už uzavřen (což se níže v kódu metody může stát &mdash; jak jsme viděli v předcházející ukázce), pak už nemůžeme nic víc dělat. Pokud je soubor uzavřen, znamená to, že jsme jeho obsah vyčerpali. Už jsme přečetli každý jeho řádek a vybudovali jsme funkce pro rozhodování a pro aplikaci pro každý vzorek a uložili jsme je do vyrovnávací paměti. Soubor je vyčerpaný, vyrovnávací paměť je vyčerpaná, já jsem vyčerpaný. Počkat! Co? „Выдержай пионер“ [vyděržaj pijaněr], už je to skoro hotové.
</ol>

<p>Když to dáme všechno dohromady, provádí se následující:

<ul>
<li>V okamžiku importu modulu se vytvoří jediná instance třídy <code>LazyRules</code>, která je nazvaná <var>rules</var> (pravidla). Tato instance otevřela soubor se vzorky, ale nečetla z něj.
<li>V okamžiku, kdy se požaduje první dvojice funkcí pro rozhodování a pro aplikaci, dojde ke kontrole vyrovnávací paměti, ale zjistí se, že je prázdná. Takže se ze souboru přečte jeden řádek se vzorky, vybudují se podle něj funkce pro rozhodování a pro aplikaci a uloží se do vyrovnávací paměti.
<li>Dejme tomu, že vyhovělo úplně první pravidlo. Pokud tomu tak je, žádné další funkce pro rozhodování a aplikaci se nevytvářejí a ze souboru se nečtou žádné další řádky.
<li>Dále dejme tomu, že volající zavolá funkci <code>plural()</code> <em>znovu</em>, protože chce převést do množného čísla jiné slovo. Cyklus <code>for</code> ve funkci <code>plural()</code> zavolá <code>iter(rules)</code>, což vede k nastavení indexu vyrovnávací paměti na začátek, ale nedojde k resetování otevřeného souborového objektu.
<li>Při prvním průchodu požádá cyklus <code>for</code> o hodnotu ze struktury <var>rules</var>, což vede k zavolání jeho metody <code>__next__()</code>. Ale v tomto okamžiku už vyrovnávací paměť obsahuje jediný pár funkcí pro rozhodování a pro aplikaci &mdash; odpovídají vzorkům z prvního řádku souboru. Protože už byly vytvořeny a uloženy do vyrovnávací paměti při zpracování minulého slova, jsou z ní vybrány. Index do vyrovnávací paměti se zvýší a otevřený soubor zůstane nedotčen.
<li>Dejme tomu, že první pravidlo tentokrát <em>nevyhovělo</em>. Cyklus <code>for</code> udělá další obrátku a zeptá se na další hodnotu ze seznamu <var>rules</var>. Tím se podruhé aktivuje metoda <code>__next__()</code>. Tentokrát je ale vyrovnávací paměť vyčerpána, protože obsahovala jen jednu položku a my jsme požádali o druhou. Takže metoda <code>__next__()</code> pokračuje v činnosti. Z otevřeného souboru přečte další řádek, vybuduje podle něj rozhodovací a aplikační funkci a dvojici uloží do vyrovnávací paměti.
<li>Pokud pravidla budovaná z načítaných řádků souboru pro zadané slovo nevyhovují, pokračuje proces fázemi „přečti, vybuduj, ulož“ dál. Jakmile se nalezne vhodné pravidlo před koncem souboru, jednoduše se použije a další načítání se zastaví. Soubor zůstane otevřený. Ukazatel do souboru zůstane tam, kde jsme přestali číst, a bude se čekat na další příkaz <code>readline()</code>. Ve vyrovnávací paměti se teď nachází více položek. Pokud znovu zahájíme vytváření množného čísla pro nové slovo, vyzkoušíme před případným čtením dalšího řádku souboru nejdříve všechny položky z vyrovnávací paměti.
</ul>

<p>Dosáhli jsme „množnočíselné“ nirvány.

<ol>
<li><strong>Minimální startovací čas.</strong> Jediné činnosti, které se při příkazu <code>import</code> provedou, jsou vytvoření jediné instance třídy a otevření souboru (ale nečte se z něj).
<li><strong>Maximální výkonnost.</strong> U předcházejícího příkladu bychom četli ze souboru a dynamicky budovali funkce pokaždé, když bychom chtěli vytvořit množné číslo zadaného slova. V této verzi dochází hned po vybudování funkcí k jejich uložení do vyrovnávací paměti a v nejhorším případě dojde k přečtení celého souboru jednou &mdash; nezávisle na tom, z kolika slov tvoříme množné číslo.
<li><strong>Oddělení kódu a dat.</strong> Všechny vzorky jsou uložené v odděleném souboru. Kód je kód, data jsou data a ta dvojice se nikdy nesetká.
</ol>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Je to opravdu nirvána? Inu, ano i ne. U příkladu s <code>LazyRules</code> musíme počítat s následujícím: soubor se vzorky se otevře (během <code>__init__()</code>) a zůstane otevřen, dokud nebude dosaženo posledního pravidla. Soubor se nakonec uzavře při ukončení Pythonu nebo po zrušení poslední instance třídy <code>LazyRules</code>, ale může to trvat <em>velmi dlouho</em>. Pokud je tato třída součástí dlouho běžícího procesu, nemusí interpret Pythonu skončit nikdy a také objekt třídy <code>LazyRules</code> nemusí být nikdy zrušen.
<p>Dá se to obejít různými způsoby. Místo toho, aby byl soubor otevřen během <code>__init__()</code> a ponechán v otevřeném stavu pro čtení po jednom řádku, můžeme soubor otevřít, přečíst všechny řádky a soubor hned zavřít. Nebo můžeme soubor otevřít, přečíst jeden řádek s pravidlem, uložit pozici v souboru zjištěnou <a href=#files-read>metodou <code>tell()</code></a> a soubor uzavřít. Později jej znovu otevřeme, použijeme <a href=#files-read>metodu <code>seek()</code></a> a pokračujeme ve čtení tam, kde jsme skončili. A nebo si s tím nebudeme dělat těžkou hlavu a prostě necháme soubor otevřený, jako to dělá tento příklad. Programování úzce souvisí s návrhem a návrh je založen na kompromisech a omezeních. Pokud bude soubor ponechán v otevřeném stavu příliš dlouho, může to vést k problému. Pokud místo toho vytvoříte komplikovanější kód, může to také vést k problému. Který z těchto problémů je větší, záleží na vašem vývojovém týmu, na vaší aplikaci a na provozním prostředí.
</blockquote>

<p class=a>&#x2042;

<h2 id=iterators-furtherreading>Přečtěte si</h2>
<ul>
<li><a href="http://docs.python.org/3.1/library/stdtypes.html#iterator-types">Iterator types</a>
<li><a href="http://www.python.org/dev/peps/pep-0234/">PEP 234: Iterators</a>
<li><a href="http://www.python.org/dev/peps/pep-0255/">PEP 255: Simple Generators</a>
<li><a href="http://www.dabeaz.com/generators/">Generator Tricks for Systems Programmers</a>
</ul>

</div>
<div id=chapter-advanced-iterators>
<h1>Iterátory pro pokročilé</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Great fleas have little fleas upon their backs to bite &#8217;em,<br>And little fleas have lesser fleas, and so ad infinitum. <span class=u>&#x275E;</span><br>(Veliké blechy maj malé své blechy, aby je kousaly do jejich zad,<br>Hle, malé si nesou své o něco menší; konce to nemá &mdash; podivný řád.)<br>&mdash; Augustus De Morgan
</blockquote>
<p>&nbsp;
<h2 id=advanced-iterators-divingin>Ponořme se</h2>
<p class=f>Jestliže přirovnáme <a href=#chapter-regular-expressions>regulární výrazy</a> ke steroidům pro <a href=#chapter-strings>řetězce</a>, pak modul <code>itertools</code> představuje steroidy pro <a href=#chapter-iterators>iterátory</a>. Ale nejdříve si ukážeme jednu klasickou hádanku.

<pre class=nd><code>HAWAII + IDAHO + IOWA + OHIO == STATES
510199 + 98153 + 9301 + 3593 == 621246

H = 5
A = 1
W = 0
I = 9
D = 8
O = 3
S = 6
T = 2
E = 4</code></pre>

<p>Hádankám tohoto typu se říká <i>algebrogramy</i> (anglicky <i>cryptarithms</i> nebo <i>alphametics</i>). Písmena jsou složena do skutečných slov, ale pokud každé z nich nahradíte číslicí <code>0&ndash;9</code>, pak tvoří aritmetickou rovnici. Úkol spočívá v nalezení dvojic písmeno/číslice. Všechny výskyty stejného písmene se musí dát nahradit stejnou číslicí. Žádná číslice se nesmí opakovat a žádné „slovo“ nesmí začínat číslicí 0.

<aside>Nejznámějším algebrogramem je <code>SEND + MORE = MONEY</code>.</aside>

<p>V této kapitole se ponoříme do neuvěřitelného pythonovského programu, který původně napsal Raymond Hettinger. Program řeší algebrogramy <em>na pouhých 14 řádcích kódu</em>.

<p class=d>[<a href="examples/alphametics.py">stáhnout <code>alphametics.py</code></a>]
<pre class=pp><code>import re
import itertools

def solve(puzzle):
    words = re.findall('[A-Z]+', puzzle.upper())
    unique_characters = set(''.join(words))
    assert len(unique_characters) &lt;= 10, 'Too many letters'
    first_letters = {word[0] for word in words}
    n = len(first_letters)
    sorted_characters = ''.join(first_letters) + \
        ''.join(unique_characters - first_letters)
    characters = tuple(ord(c) for c in sorted_characters)
    digits = tuple(ord(c) for c in '0123456789')
    zero = digits[0]
    for guess in itertools.permutations(digits, len(characters)):
        if zero not in guess[:n]:
            equation = puzzle.translate(dict(zip(characters, guess)))
            if eval(equation):
                return equation

if __name__ == '__main__':
    import sys
    for puzzle in sys.argv[1:]:
        print(puzzle)
        solution = solve(puzzle)
        if solution:
            print(solution)</code></pre>

<p>Program můžeme spustit z příkazového řádku. Pod Linuxem to bude vypadat nějak takto. (V závislosti na rychlosti vašeho počítače to může zabrat nějaký čas a není zde žádný indikátor průběhu výpočtu. Buďte trpěliví.)

<pre class='nd screen cmdline'>
<samp class="p">you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "HAWAII + IDAHO + IOWA + OHIO == STATES"</kbd>
<samp>HAWAII + IDAHO + IOWA + OHIO = STATES
510199 + 98153 + 9301 + 3593 == 621246</samp>
<samp class="p">you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "I + LOVE + YOU == DORA"</kbd>
<samp>I + LOVE + YOU == DORA
1 + 2784 + 975 == 3760</samp>
<samp class="p">you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "SEND + MORE == MONEY"</kbd>
<samp>SEND + MORE == MONEY
9567 + 1085 == 10652</samp></pre>

<p class=a>&#x2042;

<h2 id=advanced-iterators-re-findall>Nalezení všech výskytů vzorku</h2>

<p>Program pro řešení algebrogramu v něm ze všeho nejdřív hledá písmena (A&ndash;Z).

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.findall('[0-9]+', '16 2-by-4s in rows of 8')</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>['16', '2', '4', '8']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.findall('[A-Z]+', 'SEND + MORE == MONEY')</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>['SEND', 'MORE', 'MONEY']</samp></pre>
<ol>
<li>Modul <code>re</code> implementuje v Pythonu <a href=#chapter-regular-expressions>regulární výrazy</a>. Najdeme v něm i šikovnou funkci nazvanou <code>findall()</code>, které zadáváme vzorek pro regulární výraz a řetězec. Funkce v zadaném řetězci nalezne všechny výskyty vzorku. V tomto případě vzorek pasuje na posloupnosti číslic. Funkce <code>findall()</code> vrací seznam všech podřetězců, které vzorku vyhovují.
<li>Zde regulární výraz popisuje posloupnosti písmen. Návratovou hodnotou je opět seznam, jehož prvky jsou řetězce, které pasovaly k regulárnímu výrazu.
</ol>

<p>Následuje další příklad, který vám trochu procvičí mozek.

<pre class='nd screen'>
<samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">re.findall(' s.*? s', "The sixth sick sheikh's sixth sheep's sick.")</kbd>
<samp class="pp">[' sixth s', " sheikh's s", " sheep's s"]</samp></pre>

<aside>Tohle je <a href="http://en.wikipedia.org/wiki/Tongue-twister">nejtěžší jazykolam</a>, který v anglickém jazyce najdete.</aside>

<p>Překvapeni? Regulární výraz hledá mezeru, znak <code>s</code>, pak nejkratší možnou posloupnost libovolných znaků (<code>.*?</code>), pak mezeru a další <code>s</code>. Když se tak dívám na vstupní řetězec, vidím pět pasujících podřetězců:

<ol>
<li><code>The<mark> sixth s</mark>ick sheikh's sixth sheep's sick.</code>
<li><code>The sixth<mark> sick s</mark>heikh's sixth sheep's sick.</code>
<li><code>The sixth sick<mark> sheikh's s</mark>ixth sheep's sick.</code>
<li><code>The sixth sick sheikh's<mark> sixth s</mark>heep's sick.</code>
<li><code>The sixth sick sheikh's sixth<mark> sheep's s</mark>ick.</code>
</ol>

<p>Ale funkce <code>re.findall()</code> vrátila jen tři shody. Konkrétně vrátila jen první, třetí a pátou. Proč jen tři? Protože <em>nevrací překrývající se shody se vzorkem</em>. První shoda se překrývá s druhou, takže první se vrací a druhá se přeskakuje. Pak se třetí shoda překrývá se čtvrtou, takže třetí se vrací a čtvrtá se přeskakuje. A nakonec je tu pátá shoda, která se vrací. Najdou se tedy tři výskyty a ne pět.

<p>Tahle poznámka neměla s řešením algebrogramu nic společného. Prostě mi to připadlo zajímavé.

<p class=a>&#x2042;

<h2 id=advanced-iterators-unique-items>Nalezení jedinečných prvků posloupnosti</h2>

<p>Jedinečné hodnoty z posloupnosti můžeme snadno najít pomocí <a href=#native-datatypes-sets>množin</a> (set).

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['The', 'sixth', 'sick', "sheik's", 'sixth', "sheep's", 'sick']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>set(a_list)</kbd>                      <span class=u>&#x2460;</span></a>
<samp class=pp>{'sixth', 'The', "sheep's", 'sick', "sheik's"}</samp>
<samp class=p>>>> </samp><kbd class=pp>a_string = 'EAST IS EAST'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>set(a_string)</kbd>                    <span class=u>&#x2461;</span></a>
<samp class=pp>{'A', ' ', 'E', 'I', 'S', 'T'}</samp>
<samp class=p>>>> </samp><kbd class=pp>words = ['SEND', 'MORE', 'MONEY']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>''.join(words)</kbd>                   <span class=u>&#x2462;</span></a>
<samp class=pp>'SENDMOREMONEY'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>set(''.join(words))</kbd>              <span class=u>&#x2463;</span></a>
<samp class=pp>{'E', 'D', 'M', 'O', 'N', 'S', 'R', 'Y'}</samp></pre>
<ol>
<li>Pokud máme seznam s několika řetězci, pak nám z něj funkce <code>set()</code> vytvoří množinu jedinečných řetězců. Dá se to snadno pochopit, když si to představíte jako cyklus <code>for</code>. Vezmeme první položku ze seznamu a vložíme ji do množiny. Pak druhou. A třetí. Čtvrtou. Pátou... Počkat! Ta už v množině je, takže se bude vypisovat jen jednou, protože množiny v Pythonu neumožňují existenci duplicit. A šestou. Sedmou&nbsp;&mdash;&nbsp;a znovu duplicita, takže se pak objeví jen jednou. A jaký je konečný výsledek? Z původního seznamu zbyly jen jedinečné položky bez duplicit. Původní seznam ani nemusíme předem seřadit.
<li>Stejná technika funguje i pro řetězce, protože řetězce jsou posloupnostmi znaků.
<li>Pokud máme seznam řetězců, pak <code>''.join(<var>a_list</var>)</code> spojí všechny řetězce do jednoho.
<li>Takže pokud máme seznam řetězců, tento řádek kódu vrátí jedinečné znaky nacházející se ve všech řetězcích. Bez duplicit.
</ol>

<p>Program pro řešení algebrogramů tuto techniku používá pro vytvoření množiny všech jedinečných znaků v zadání.

<pre class='nd pp'><code>unique_characters = set(''.join(words))</code></pre>

<p>Program postupně prochází všemi možnými řešeními a tuto množinu používá pro přiřazení číslic jednotlivým znakům.

<p class=a>&#x2042;

<h2 id=advanced-iterators-assert>Činíme předpoklady</h2>

<p>V Pythonu, stejně jako v mnoha jiných programovacích jazycích, najdeme příkaz <code>assert</code>. Funguje následovně.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>assert 1 + 1 == 2</kbd>                                     <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>assert 1 + 1 == 3</kbd>                                     <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AssertionError</samp>
<a><samp class=p>>>> </samp><kbd class=pp>assert 2 + 2 == 5, "Only for very large values of 2"</kbd>  <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AssertionError: Only for very large values of 2</samp></pre>
<ol>
<li>Za příkaz <code>assert</code> uvedeme libovolný platný pythonovský výraz. V tomto případě se výraz <code>1 + 1 == 2</code> vyhodnotí jako <code>True</code>, takže příkaz <code>assert</code> nedělá nic.
<li>Pokud se ale pythonovský výraz vyhodnotí jako <code>False</code>, vyvolá příkaz <code>assert</code> výjimku <code>AssertionError</code>.
<li>Za výraz můžeme uvést také lidsky čitelnou zprávu, která se v případě vyvolání výjimky <code>AssertionError</code> zobrazí.
</ol>

<p>Takže následující řádek kódu:

<pre class='nd pp'><code>assert len(unique_characters) &lt;= 10, 'Too many letters'</code></pre>

<p>&hellip; je ekvivalentem zápisu:

<pre class='nd pp'><code>if len(unique_characters) > 10:
    raise AssertionError('Too many letters')</code></pre>

<p>Program řešící algebrogram používá přesně takový příkaz <code>assert</code> k předčasnému ukončení činnosti v případě, kdy hádanka obsahuje víc než deset jedinečných znaků. Protože každému písmenu přiřazujeme jedinečnou číslici a číslic máme jen deset, hádanka s více než deseti jedinečnými znaky nemůže mít řešení.

<p class=a>&#x2042;

<h2 id=advanced-iterators-generator-expressions>Generátorové výrazy</h2>

<p>Generátorový výraz se podobá <a href=#chapter-generators>generátorové funkci</a>, ale funkce to není.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>unique_characters = {'E', 'D', 'M', 'O', 'N', 'S', 'R', 'Y'}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>gen = (ord(c) for c in unique_characters)</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>gen</kbd>                                        <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;generator object &lt;genexpr> at 0x00BADC10></samp>
<a><samp class=p>>>> </samp><kbd class=pp>next(gen)</kbd>                                  <span class=u>&#x2462;</span></a>
<samp class=pp>69</samp>
<samp class=p>>>> </samp><kbd class=pp>next(gen)</kbd>
<samp class=pp>68</samp>
<a><samp class=p>>>> </samp><kbd class=pp>tuple(ord(c) for c in unique_characters)</kbd>   <span class=u>&#x2463;</span></a>
<samp class=pp>(69, 68, 77, 79, 78, 83, 82, 89)</samp></pre>
<ol>
<li>Generátorový výraz se chová jako anonymní funkce, která produkuje hodnoty. Výraz samotný se podobá <a href=#comprehensions-listcomprehension>generátorové notaci seznamu (list comprehension)</a>, ale místo do hranatých závorek je uzavřen v kulatých závorkách.
<li>Generátorový výraz vrací&hellip; iterátor.
<li>Při volání <code>next(<var>gen</var>)</code> se nám vrací další hodnota iterátoru.
<li>Pokud chcete, můžete iterovat přes všechny hodnoty a vrátit n-tici, seznam nebo množinu tím, že generátorový výraz použijete v roli argumentu <code>tuple()</code>, <code>list()</code> nebo <code>set()</code>. V takovém případě nemusíte používat sadu kulatých závorek navíc. Funkci <code>tuple()</code> stačí předat „holý“ výraz <code>ord(c) for c in unique_characters</code> a Python už pozná, že jde o generátorový výraz.
</ol>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Když místo generátorové notace seznamu použijete generátorový výraz, ušetříte jak <abbr>CPU</abbr>, tak <abbr>RAM</abbr>. Pokud konstruujete seznam jen proto, abyste ho zase zahodili (tj. když ho například chcete předat do <code>tuple()</code> nebo <code>set()</code>), použijte raději generátorový výraz!
</blockquote>

<p>Následující ukázka dosahuje stejného efektu s použitím <a href=#chapter-generators>generátorové funkce</a>:

<pre class='nd pp'><code>def ord_map(a_string):
    for c in a_string:
        yield ord(c)

gen = ord_map(unique_characters)</code></pre>

<p>Generátorový výraz je kompaktnější, ale funguje stejně.

<p class=a>&#x2042;

<h2 id=advanced-iterators-permutations>Výpočet permutací (pro lenochy)</h2>

<p>Ze všeho nejdříve se podívejme, co to vlastně jsou permutace? Permutace jsou matematický koncept. (Ve skutečnosti existuje několik definicí v závislosti na tom, jakým druhem matematiky se zabýváte. Zde se dotkneme kombinatoriky. Ale pokud vám to nic neříká, nedělejte si s tím starosti. Tak jako vždy, <a href="http://cs.wikipedia.org/wiki/Permutace">vaším kamarádem je Wikipedie</a>.)

<p>Základní myšlenka spočívá v tom, že vezmeme seznam věcí (mohou to být čísla, písmenka nebo tancující medvídci) a najdeme všechny možné způsoby, jak z něj udělat menší seznamy. (Poznámka překladatele: V našich školách se pro označení tohoto úkonu používá pojem <a>variace k-té třídy z n prvků bez opakování</a>. Pojem <a href="http://cs.wikipedia.org/wiki/Permutace#Permutace_bez_opakov.C3.A1n.C3.AD">permutace bez opakování</a> se u nás používá jen pro speciální případ, kdy k je rovno n. V dalším textu zůstanu u chápání pojmu z originální publikace také z důvodu pojmenování příslušné funkce.) Všechny menší seznamy mají mít stejnou velikost, která může být od 1 až po celkový počet prvků. A nic se nesmí opakovat. Matematici by řekli „najděme permutace dvojic z tří různých prvků“ (u nás „najděte variace druhé třídy z tří prvků bez opakování“). To znamená, že máme posloupnost tří prvků a chceme nalézt všechny možné uspořádané dvojice.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>                              <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>perms = itertools.permutations([1, 2, 3], 2)</kbd>  <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>                                   <span class=u>&#x2462;</span></a>
<samp class=pp>(1, 2)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(1, 3)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<a><samp class=pp>(2, 1)</samp>                                            <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(2, 3)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(3, 1)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(3, 2)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>                                   <span class=u>&#x2464;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
StopIteration</samp></pre>
<ol>
<li>Modul <code>itertools</code> obsahuje celou řadu zábavných věcí, včetně funkce <code>permutations()</code>, která nás při hledání permutací zbaví veškeré námahy.
<li>Funkce <code>permutations()</code> přebírá posloupnost (zde jde o seznam tří čísel) a požadovaný počet prvků v menších skupinách. Funkce vrací iterátor, který můžeme použít v cyklu <code>for</code> nebo na jakémkoliv starém známém místě, ve kterém se iteruje (tj. prochází všemi prvky). Zde budeme provádět kroky iterátoru ručně, abychom si všechny hodnoty ukázali.
<li>První permutací ze seznamu <code>[1, 2, 3]</code> je dvojice <code>(1, 2)</code>.
<li>Poznamenejme, že permutace jsou uspořádané: <code>(2, 1)</code> je něco jiného než <code>(1, 2)</code>. <li>Tak to jsou ony! Tohle jsou permutace všech dvojic z <code>[1, 2, 3]</code>. Dvojice jako <code>(1, 1)</code> nebo <code>(2, 2)</code> zde nikdy neuvidíte, protože obsahují opakující se prvky. Takže nejde o platné permutace. Pokud už více permutací neexistuje, iterátor vyvolá výjimku <code>StopIteration</code>.
</ol>

<aside>Modul <code>itertools</code> obsahuje všemožné zábavné věci.</aside>

<p>Funkci <code>permutations()</code> nemusíme předávat jen seznam. Může přebírat jakoukoliv posloupnost, dokonce i řetězec.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>perms = itertools.permutations('ABC', 3)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<a><samp class=pp>('A', 'B', 'C')</samp>                               <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('A', 'C', 'B')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('B', 'A', 'C')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('B', 'C', 'A')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('C', 'A', 'B')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('C', 'B', 'A')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
StopIteration</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.permutations('ABC', 3))</kbd>    <span class=u>&#x2462;</span></a>
<samp class=pp>[('A', 'B', 'C'), ('A', 'C', 'B'),
 ('B', 'A', 'C'), ('B', 'C', 'A'),
 ('C', 'A', 'B'), ('C', 'B', 'A')]</samp></pre>
<ol>
<li>Řetězec je jen posloupností znaků. Takže pro účely hledání permutací je řetězec <code>'ABC'</code> ekvivalentem k seznamu <code>['A', 'B', 'C']</code>.
<li>První permutací trojic z tří prvků <code>['A', 'B', 'C']</code> je <code>('A', 'B', 'C')</code>. Pro stejné znaky existuje pět dalších myslitelných uspořádání, tedy permutací.
<li>Funkce <code>permutations()</code> vrací vždy iterátor. Snadný způsob zviditelnění všech permutací při ladění spočívá ve vytvoření jejich seznamu předáním iterátoru do zabudované funkce <code>list()</code>.
</ol>

<p class=a>&#x2042;

<h2 id=advanced-iterators-more-itertools>Další legrácky v modulu <code>itertools</code></h2>

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.product('ABC', '123'))</kbd>   <span class=u>&#x2460;</span></a>
<samp class=pp>[('A', '1'), ('A', '2'), ('A', '3'),
 ('B', '1'), ('B', '2'), ('B', '3'),
 ('C', '1'), ('C', '2'), ('C', '3')]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.combinations('ABC', 2))</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>[('A', 'B'), ('A', 'C'), ('B', 'C')]</samp></pre>
<ol>
<li>Funkce <code>itertools.product()</code> vrací iterátor, který vytváří kartézský součin dvou posloupností.
<li>Funkce <code>itertools.combinations()</code> vrací iterátor, který vytváří všechny možné kombinace dané délky z dané posloupnosti. Podobá se funkci <code>itertools.permutations()</code> s tou výjimkou, že kombinace nezahrnují výsledky, které vzniknou pouhou změnou uspořádání položek jiného výsledku. Takže <code>itertools.permutations('ABC', 2)</code> vrátí jak <code>('A', 'B')</code>, tak <code>('B', 'A')</code> (mimo jiné), ale <code>itertools.combinations('ABC', 2)</code> nevrátí <code>('B', 'A')</code>, protože jde o duplicitu vytvořenou změnou pořadí položek <code>('A', 'B')</code>.
</ol>

<p class=d>[<a href="examples/favorite-people.txt">stáhnout <code>favorite-people.txt</code></a>]
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>names = list(open('examples/favorite-people.txt', encoding='utf-8'))</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Dora\n', 'Ethan\n', 'Wesley\n', 'John\n', 'Anne\n',
'Mike\n', 'Chris\n', 'Sarah\n', 'Alex\n', 'Lizzie\n']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = [name.rstrip() for name in names]</kbd>                             <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Dora', 'Ethan', 'Wesley', 'John', 'Anne',
'Mike', 'Chris', 'Sarah', 'Alex', 'Lizzie']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = sorted(names)</kbd>                                                 <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Alex', 'Anne', 'Chris', 'Dora', 'Ethan',
'John', 'Lizzie', 'Mike', 'Sarah', 'Wesley']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = sorted(names, key=len)</kbd>                                        <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Alex', 'Anne', 'Dora', 'John', 'Mike',
'Chris', 'Ethan', 'Sarah', 'Lizzie', 'Wesley']</samp></pre>
<ol>
<li>Tento obrat vrací seznam všech řádků v textovém souboru.
<li>Naneštěstí (pro tento příklad) obrat <code>list(open(<var>filename</var>))</code> vrací na konci každého řádku i znak konce řádku. V této generátorové notaci seznamu použijeme metodu řetězce <code>rstrip()</code>, která z konce každého řádku odstraní koncové bílé znaky. (Řetězce definují též metodu <code>lstrip()</code>, která odstraňuje úvodní bílé znaky, a metodu <code>strip()</code>, která odstraňuje bílé znaky z obou konců.)
<li>Funkce <code>sorted()</code> přebírá seznam a vrací nový, seřazený. Neřekneme-li jinak, řadí se podle abecedy.
<li>Ale funkci <code>sorted()</code> můžeme parametrem <var>key</var> předat funkci a pak se provede řazení podle jejích výsledků. V tomto případě byla předána funkce <code>len()</code>, takže řazení probíhá podle výsledků funkce <code>len(<var>položka</var>)</code>. Nejkratší jména se dostanou na začátek, pak budou následovat delší a delší.
</ol>

<p>A co to má společného s modulem <code>itertools</code>? To jsem rád, že se ptáte.

<pre class=screen>
&hellip;pokračování v předchozí práci s interaktivním shellem&hellip;
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>groups = itertools.groupby(names, len)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>groups</kbd>
<samp class=pp>&lt;itertools.groupby object at 0x00BB20C0></samp>
<samp class=p>>>> </samp><kbd class=pp>list(groups)</kbd>
<samp class=pp>[(4, &lt;itertools._grouper object at 0x00BA8BF0>),
 (5, &lt;itertools._grouper object at 0x00BB4050>),
 (6, &lt;itertools._grouper object at 0x00BB4030>)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>groups = itertools.groupby(names, len)</kbd>   <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>for name_length, name_iter in groups:</kbd>    <span class=u>&#x2462;</span></a>
<samp class=p>... </samp><kbd class=pp>    print('Names with {0:d} letters:'.format(name_length))</kbd>
<samp class=p>... </samp><kbd class=pp>    for name in name_iter:</kbd>
<samp class=p>... </samp><kbd class=pp>        print(name)</kbd>
<samp class=p>... </samp>
<samp>Names with 4 letters:
Alex
Anne
Dora
John
Mike
Names with 5 letters:
Chris
Ethan
Sarah
Names with 6 letters:
Lizzie
Wesley</samp></pre>
<ol>
<li>Fukce <code>itertools.groupby()</code> přebírá posloupnost a funkci klíče. Vrací iterátor, který vytváří dvojice. Každá dvojice obsahuje jednak výsledek <code>funkce_klic(<var>každá položka</var>)</code> a jednak další iterátor, který prochází všemi položkami se stejným výsledkem funkce klíče.
<li>Voláním funkce <code>list()</code> jsme iterátor „vyčerpali“. To znamená, že jsme při vytváření seznamu vygenerovali každou položku iterátoru. Iterátor nemá žádné tlačítko „reset“. Jakmile jsme posloupnost jednou vyčerpali, nemůžeme začít znovu. Pokud chceme hodnoty projít znovu (dejme tomu v dalším cyklu <code>for</code>), musíme znovu zavolat <code>itertools.groupby()</code> a vytvořit nový iterátor.
<li>Za předpokladu, že už máme seznam jmen <em>seřazený podle jejich délek</em>, přidělí <code>itertools.groupby(names, len)</code> všem jménům délky 4 jeden iterátor, všem jménům délky 5 druhý iterátor atd. Funkce <code>groupby()</code> je zcela obecná. Řetězce můžeme seskupit podle prvního písmene, čísla podle počtu jejich prvočinitelů nebo podle jakékoliv myslitelné funkce klíče.
</ol>
<!-- YO DAWG, WE HEARD YOU LIKE LOOPING, SO WE PUT AN ITERATOR IN YOUR ITERATOR SO YOU CAN LOOP WHILE YOU LOOP. -->

<blockquote class=note>
<p><span class="u">&#x261E;</span>Funkce <code>itertools.groupby()</code> funguje jen v případě, kdy je vstupní posloupnost již seřazená podle sdružovací funkce. Ve výše uvedeném příkladu jsme seznam jmen seskupili podle funkce <code>len()</code>. Fungovalo to jen díky tomu, že byl vstupní seznam již seřazen podle délky položek.
</blockquote>

<p>Díváte se pozorně?
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>list(range(0, 3))</kbd>
<samp class=pp>[0, 1, 2]</samp>
<samp class=p>>>> </samp><kbd class=pp>list(range(10, 13))</kbd>
<samp class=pp>[10, 11, 12]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.chain(range(0, 3), range(10, 13)))</kbd>        <span class=u>&#x2460;</span></a>
<samp class=pp>[0, 1, 2, 10, 11, 12]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(zip(range(0, 3), range(10, 13)))</kbd>                    <span class=u>&#x2461;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(zip(range(0, 3), range(10, 14)))</kbd>                    <span class=u>&#x2462;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.zip_longest(range(0, 3), range(10, 14)))</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12), (None, 13)]</samp></pre>
<ol>
<li>Funkce <code>itertools.chain()</code> přebírá dva iterátory a vrací iterátor, který vytváří posloupnost všech položek nejdříve z prvního iterátoru a pak všech položek z druhého iterátoru. (Ve skutečnosti můžeme předat libovolný počet iterátorů a tato funkce zřetězí všechny jejich hodnoty v pořadí, v jakém jsme je funkci předali.)
<li>Funkce <code>zip()</code> dělá něco docela obyčejného, ale ukazuje se, že je velmi užitečná. Přebírá libovolný počet posloupností a vrací iterátor, který vytváří n-tice z prvních položek každé posloupnosti, pak z druhých položek, pak z třetích atd.
<li>Funkce <code>zip()</code> zastaví na konci nejkratší posloupnosti. Funkce <code>range(10, 14)</code> produkuje 4 položky (10, 11, 12 a 13), ale <code>range(0, 3)</code> jen 3. Takže funkce <code>zip()</code> vrátí iterátor produkující 3 položky.
<li>Naopak funkce <code>itertools.zip_longest()</code> zastaví až na konci <em>nejdelší</em> posloupnosti. Místo chybějících položek kratších posloupností doplní hodnoty <code>None</code>.
</ol>

<p id=advanced-iterators-dict-zip>No dobrá, tohle všechno je sice velmi zajímavé, ale jak se to vztahuje k programu na řešení algebrogramů? Takto:

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>characters = ('S', 'M', 'E', 'D', 'O', 'N', 'R', 'Y')</kbd>
<samp class=p>>>> </samp><kbd class=pp>guess = ('1', '2', '0', '3', '4', '5', '6', '7')</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>tuple(zip(characters, guess))</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>(('S', '1'), ('M', '2'), ('E', '0'), ('D', '3'),
 ('O', '4'), ('N', '5'), ('R', '6'), ('Y', '7'))</samp>
<a><samp class=p>>>> </samp><kbd class=pp>dict(zip(characters, guess))</kbd>   <span class=u>&#x2461;</span></a>
<samp class=pp>{'E': '0', 'D': '3', 'M': '2', 'O': '4',
 'N': '5', 'S': '1', 'R': '6', 'Y': '7'}</samp></pre>
<ol>
<li>Máme-li dán seznam písmen a seznam číslic (každá z nich je v něm reprezentována jako jednoznakový řetězec), pak nám funkce <code>zip</code> spáruje písmena a číslice v uvedeném pořadí.
<li>A proč by to mělo být nějak zvlášť výhodné? Protože shodou okolností je taková datová struktura přesně tou správnou datovou strukturou, kterou můžeme předat funkci <code>dict()</code>, aby vytvořila slovník, který používá písmena jako klíče a k nim přidružené číslice jako hodnoty. (Není to, samozřejmě, jediný způsob, jak toho můžeme dosáhnout. Slovník bychom mohli vytvořit přímo, pomocí <a href=#comprehensions-dictionarycomprehension>generátorové notace</a>.) Ačkoliv textová reprezentace obsahu slovníku zobrazuje dvojice v jiném pořadí (slovníky samy o sobě nedefinují „pořadí“), vidíme, že každé písmeno má k sobě číslici přidruženou na základě původních posloupností <var>characters</var> a <var>guess</var>.
</ol>

<p id=advanced-iterators-guess>Program pro řešení algebrogramů tuto techniku používá pro vytvoření slovníku, který převádí písmena z hádanky na čísla v řešení &mdash; pro každé možné řešení.

<pre class='nd pp'><code>characters = tuple(ord(c) for c in sorted_characters)
digits = tuple(ord(c) for c in '0123456789')
...
for guess in itertools.permutations(digits, len(characters)):
    ...
<mark>    equation = puzzle.translate(dict(zip(characters, guess)))</mark></code></pre>

<p>Ale co je za metodu ta <code>translate()</code>? Teď se dostáváme k <em>opravdu</em> zábavné části.

<p class=a>&#x2042;

<h2 id=advanced-iterators-string-translate>Nový způsob úpravy řetězce</h2>

<p>Pythonovské řetězce definují mnoho metod. O některých z nich jsme se učili <a href=#chapter-strings>v kapitole Řetězce</a>: <code>lower()</code>, <code>count()</code> a <code>format()</code>. Teď si představíme mocnou, ale málo známou techniku pro manipulaci s řetězcem. Jde o metodu <code>translate()</code>.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table = {ord('A'): ord('O')}</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table</kbd>                         <span class=u>&#x2461;</span></a>
<samp class=pp>{65: 79}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'MARK'.translate(translation_table)</kbd>       <span class=u>&#x2462;</span></a>
<samp class=pp>'MORK'</samp></pre>
<ol>
<li>Překlad řetězce začíná naplněním překladové tabulky, což je prostě slovník, který zobrazuje jeden znak na jiný. Pojem „znak“ je zde vlastně uveden chybně. Překladová tabulka ve skutečnosti zobrazuje <em>bajty</em> na jiné bajty.
<li>Připomeňme si, že bajty jsou v Pythonu 3 celá čísla. Funkce <code>ord()</code> vrací <abbr>ASCII</abbr> hodnotu daného znaku. V případě znaků A&ndash;Z to budou vždy bajty od 65 do 90.
<li>Metoda řetězcového objektu <code>translate()</code> přebírá překladovou tabulku a obsah řetězce přes ni propasíruje. To znamená, že nahradí všechny výskyty klíčů z překladové tabulky odpovídajícími hodnotami. V tomto případě se <code>MARK</code> „přeloží“ na <code>MORK</code>.
</ol>

<aside>Teď se dostáváme k <em>opravdu</em> zábavné části.</aside>

<p>Ale co to má společného s řešením algebrogramů? Jak se ukáže za chvíli, všechno.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>characters = tuple(ord(c) for c in 'SMEDONRY')</kbd>       <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>characters</kbd>
<samp class=pp>(83, 77, 69, 68, 79, 78, 82, 89)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>guess = tuple(ord(c) for c in '91570682')</kbd>            <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>guess</kbd>
<samp class=pp>(57, 49, 53, 55, 48, 54, 56, 50)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table = dict(zip(characters, guess))</kbd>     <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>translation_table</kbd>
<samp class=pp>{68: 55, 69: 53, 77: 49, 78: 54, 79: 48, 82: 56, 83: 57, 89: 50}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'SEND + MORE == MONEY'.translate(translation_table)</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>'9567 + 1085 == 10652'</samp></pre>
<ol>
<li>Prostřednictvím <a href=#advanced-iterators-generator-expressions>generátorového výrazu</a> pro každý znak řetězce rychle vypočteme hodnotu odpovídajícího bajtu. Obsah proměnné <var>characters</var> je příkladem obsahu proměnné <var>sorted_characters</var> z funkce <code>alphametics.solve()</code>.
<li>Pomocí dalšího generátorového výrazu rychle vypočítáme hodnoty bajtů reprezentujících každou číslici řetězce. Výsledek v proměnné <var>guess</var> (tj. odhad) má podobu <a href=#advanced-iterators-guess>vrácenou funkcí <code>itertools.permutations()</code></a> &mdash; viz funkce <code>alphametics.solve()</code>
<li>Překladová tabulka se generuje <a href=#advanced-iterators-dict-zip>zipováním posloupností <var>characters</var> a <var>guess</var> dohromady</a> a použitím výsledné posloupnosti dvojic pro vybudování slovníku. Přesně tohle dělá funkce <code>alphametics.solve()</code> uvnitř cyklu <code>for</code>.
<li>Nakonec překladovou tabulku předáme metodě <code>translate()</code> původního řetězce hádanky. Tím se každý znak řetězce přeloží na odpovídající číslici (podle písmen v <var>characters</var> a číslic v <var>guess</var>). Výsledkem je platný pythonovský výraz v řetězcové podobě.
</ol>

<p>To je docela efektní. Ale co můžeme dělat s řetězcem, který shodou okolností zachycuje platný pythonovský výraz?

<p class=a>&#x2042;

<h2 id=advanced-iterators-eval>Vyhodnocování libovolných řetězců zachycujících pythonovské výrazy</h2>

<p>Tohle je poslední kousek skládanky (nebo spíše poslední kousek programu pro řešení hádanky). Po všech těch efektních manipulacích s řetězci jsme skončili u řetězce, jako je <code>'9567 + 1085 == 10652'</code>. Ale je to jen řetězec. A k čemu je nám řetězec dobrý? Seznamte se s <code>eval()</code>, s univerzálním pythonovským vyhodnocovacím nástrojem.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>eval('1 + 1 == 2')</kbd>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('1 + 1 == 3')</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('9567 + 1085 == 10652')</kbd>
<samp class=pp>True</samp></pre>

<p>Ale počkejte! Je toho ještě víc! Funkce <code>eval()</code> se neomezuje jen na booleovské výrazy. Zvládne <em>libovolný</em> pythonovský výraz a vrací <em>libovolný</em> datový typ.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>eval('"A" + "B"')</kbd>
<samp class=pp>'AB'</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('"MARK".translate({65: 79})')</kbd>
<samp class=pp>'MORK'</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('"AAAAA".count("A")')</kbd>
<samp class=pp>5</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('["*"] * 5')</kbd>
<samp class=pp>['*', '*', '*', '*', '*']</samp></pre>

<p>Ale počkejte, to ještě není vše!

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>x = 5</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5")</kbd>         <span class=u>&#x2460;</span></a>
<samp class=pp>25</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("pow(x, 2)")</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>25</samp>
<samp class=p>>>> </samp><kbd class=pp>import math</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("math.sqrt(x)")</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>2.2360679774997898</samp></pre>
<ol>
<li>Výraz předávaný funkci <code>eval()</code> se může odkazovat na globální proměnné definované vně <code>eval()</code>. A pokud se volá uvnitř funkce, může se odkazovat i na lokální proměnné.
<li>A funkce.
<li>A moduly.
</ol>

<p>Hej, zastav na minutku&hellip;

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import subprocess</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("subprocess.getoutput('ls ~')")</kbd>                  <span class=u>&#x2460;</span></a>
<samp class=pp>'Desktop         Library         Pictures \
 Documents       Movies          Public   \
 Music           Sites'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("subprocess.getoutput('rm /some/random/file')")</kbd>  <span class=u>&#x2461;</span></a></pre>
<ol>
<li>Modul <code>subprocess</code> vám dovolí spustit libovolný shellovský příkaz a získat výsledek v podobě pythonovského řetězce.
<li>Jenže libovolný shellovský příkaz může vést k trvalým následkům.
</ol>

<p>A je to dokonce ještě horší, protože existuje globální funkce <code>__import__()</code>, která přebírá jméno modulu v řetězcové podobě, importuje ho a vrací na něj odkaz. Když to zkombinujeme se silou funkce <code>eval()</code>, můžeme vytvořit výraz, který smaže všechny vaše soubory:

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm /some/random/file')")</kbd>  <span class=u>&#x2460;</span></a></pre>
<ol>
<li>A teď si představte výstup příkazu <code>'rm -rf ~'</code>. Ve skutečnosti žádný výstup neuvidíte. Ale neuvidíte už ani své soubory.
</ol>

<p class=xxxl>eval() is EVIL

<p>(tj. <code>eval()</code> je zlý, špatný, zlověstný). Tou zlou stránkou je vyhodnocování libovolných výrazů pocházejících z nedůvěryhodných zdrojů. Funkci <code>eval()</code> byste měli používat výhradně pro vstup z důvěryhodných zdrojů. Problém je v tom, jak určit, co je „důvěryhodný“ zdroj. Ale něco vím určitě. Určitě byste <b>NEMĚLI</b> vzít tento program pro řešení algebrogramů a zveřejnit jej na internetu v podobě malé webovské služby. A nemyslete si: „Vždyť ta funkce dělá tolik řetězcových operací, než se vůbec dostane k vyhodnocení. <em>Nedovedu si představit</em>, jak by toho někdo mohl zneužít.“ Někdo <b>přijde</b> na to, jak propašovat nějaký nebezpečný kód všemi těmi řetězcovými manipulacemi (<a href="http://www.securityfocus.com/blogs/746">už se staly divnější věci</a>). A pak už můžete svému serveru poslat jen polibek na rozloučenou.

<p>Ale existuje vůbec <em>nějaký</em> způsob, jak výrazy vyhodnotit bezpečně? Lze nějak <code>eval()</code> umístit na pískoviště, odkud nemá přístup k okolnímu světu a nemůže mu škodit? Hmm, ano i ne.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>x = 5</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5", {}, {})</kbd>               <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name 'x' is not defined</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5", {"x": x}, {})</kbd>         <span class=u>&#x2461;</span></a>
<samp class=p>25</samp>
<samp class=p>>>> </samp><kbd class=pp>import math</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("math.sqrt(x)", {"x": x}, {})</kbd>  <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name 'math' is not defined</samp></pre>
<ol>
<li>Druhý a třetí parametr předávaný funkci <code>eval()</code> se chovají jako globální a lokální prostor jmen. Tyto prostory se používají při vyhodnocování výrazu. V tomto případě jsou oba prázdné. To znamená, že při vyhodnocování řetězce <code>"x * 5"</code> neexistuje žádný odkaz na <var>x</var> ani v globálním ani v lokálním prostoru jmen. Takže <code>eval()</code> vyvolá výjimku.
<li>Do globálního prostoru jmen můžeme vložit výběr určitých hodnot tím, že je jednotlivě vyjmenujeme. Během vyhodnocování pak budou k dispozici tyto a jen tyto proměnné.
<li>Ačkoliv jste zrovna importovali modul <code>math</code>, nevložili jsme jej do prostoru jmen, který předáváme funkci <code>eval()</code>. V důsledku toho vyhodnocení selhalo.
</ol>

<p>Tý jo. Tak to bylo jednoduché. Teď si udělám webovskou službu pro
řešení algebrogramů!

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>eval("pow(5, 2)", {}, {})</kbd>                   <span class=u>&#x2460;</span></a>
<samp class=pp>25</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("__import__('math').sqrt(5)", {}, {})</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>2.2360679774997898</samp></pre>
<ol>
<li>Ačkoliv jste v roli globálního a lokálního prostoru jmen předali prázdné slovníky, během vyhodnocování jsou stále dostupné všechny zabudované pythonovské funkce. Takže <code>pow(5, 2)</code> funguje, protože <code>5</code> a <code>2</code> jsou literály a <code>pow()</code> je zabudovaná funkce.
<li>Naneštěstí (a pokud netušíte, proč naneštěstí, čtěte dál) je funkce <code>__import__()</code> také zabudovanou funkcí, takže také funguje.
</ol>

<p>Ano, to znamená, že můžete pořád dělat odporné věci, i když jste při volání <code>eval()</code> pro globální a lokální prostor jmen explicitně nastavili prázdné slovníky:

<pre class='nd screen'><samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm /some/random/file')", {}, {})</kbd></pre>

<p>A do prčic! To jsem rád, že jsem pro řešení algebrogramů nevytvořil webovou službu. Je zde vůbec <em>nějaký</em> způsob, kterým bychom mohli <code>eval()</code> používat bezpečně? Ano i ne.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>eval("__import__('math').sqrt(5)",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name '__import__' is not defined</samp>
<samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm -rf /')",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name '__import__' is not defined</samp></pre>
<ol>
<li>Abyste mohli výrazy z nedůvěryhodných zdrojů vyhodnocovat bezpečně, musíte definovat slovník pro globální prostor jmen, který mapuje <code>"__builtins__"</code> na <code>None</code>, tedy na pythonovskou hodnotu null (nic, nil). „Zabudované“ funkce jsou totiž vnitřně uzavřeny do pseudomodulu nazvaného <code>"__builtins__"</code>. Tento pseudomodul (tj. množina zabudovaných funkcí) je vyhodnocovaným výrazům zpřístupněn &mdash; pokud jej explicitně nepotlačíte.
<li>Ujistěte se, že předefinováváte <code>__builtins__</code>. Žádné <code>__builtin__</code>, <code>__built-ins__</code> nebo nějakou podobnou variantu. Ono by to fungovalo bez problémů, ale vystavilo by vás to riziku katastrofy.
</ol>

<p>Takhle už je <code>eval()</code> bezpečný? Nu, ano i ne.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>eval("2 ** 2147483647",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2460;</span></a>
</pre>
<ol>
<li>I bez přístupu k <code>__builtins__</code> můžete stále spustit útok typu odmítnutí služby. Pokud se například pokusíte o umocnění <code>2</code> na <code>2147483647</code>, využití procesoru vašeho serveru stoupne na 100 % na pěkně dlouhou dobu. (Pokud to zkoušíte v interaktivním shellu, můžete ho přerušit, když několikrát stisknete <kbd>Ctrl-C</kbd>.) Technicky vzato, tento výraz <em>nakonec vrátí</em> nějakou hodnotu, ale do té doby bude server dělat spoustu zbytečné práce.
</ol>

<p>Takže nakonec <em>je možné</em> bezpečně vyhodnocovat pythonovské výrazy z nedůvěryhodných zdrojů. Vyžaduje to ale určitou definici pojmu „bezpečně“, která v reálném životě není zas tak užitečná. Dobré je, když si hrajete někde poblíž. Dobré taky je, když připustíte jen důvěryhodný vstup. Cokoliv jiného znamená, že si koledujete o malér.

<p class=a>&#x2042;

<h2 id=advanced-iterators-alphametics-finale>Spojme to všechno dohromady</h2>

<p>Rekapitulace: Tento program řeší algebrogramy hrubou silou, tj. vyčerpávajícím hledáním všech možných řešení. Program za tím účelem&hellip;

<ol>
<li><a href=#advanced-iterators-re-findall>Nalezne v zadání všechna písmena</a> voláním funkce <code>re.findall()</code>.
<li><a href=#advanced-iterators-unique-items>Nalezne všechna <em>jedinečná</em> písmena hádanky s využitím množiny a funkce <code>set()</code>.
<li><a href=#advanced-iterators-assert>Zkontroluje příkazem <code>assert</code>, zda se v zadání nevyskytuje více než 10 jedinečných znaků</a> (což by znamenalo, že hádanka je neřešitelná).
<li><a href=#advanced-iterators-generator-objects>Převede znaky na jejich ASCII hodnoty</a> použitím objektu generátoru.
<li><a href=#advanced-iterators-permutations>Počítá všechna možná řešení</a> pomocí funkce <code>itertools.permutations()</code>.
<li><a href=#advanced-iterators-string-translate>Převádí každé možné řešení na pythonovský výraz</a> pomocí metody řetězcového objektu <code>translate()</code>.
<li><a href=#advanced-iterators-eval>Testuje každé možné řešení vyhodnocením pythonovského výrazu</a> voláním funkce <code>eval()</code>.
<li>Vrací první řešení, které se vyhodnotí jako <code>True</code>.
</ol>

<p>&hellip; to vše na pouhých 14 řádcích kódu.

<p class=a>&#x2042;

<h2 id=advanced-iterators-furtherreading>Přečtěte si</h2>

<ul>
<li><a href="http://docs.python.org/3.1/library/itertools.html"><code>itertools</code> module</a>
<li><a href="http://www.doughellmann.com/PyMOTW/itertools/"><code>itertools</code>&nbsp;&mdash;&nbsp;Iterator functions for efficient looping</a>
<li><a href="http://blip.tv/file/1947373/">Podívejte se na přednášku Raymonda Hettingera „Easy AI with Python“</a> na PyCon 2009
<li><a href="http://code.activestate.com/recipes/576615/">Recipe 576615: Alphametics solver</a>, původní program Raymonda Hettingera pro Python 2.
<li><a href="http://code.activestate.com/recipes/users/178123/">Další recepty od Raymonda Hettingera</a> v ActiveState Code repository (archiv kódu).
<li><a href="http://en.wikipedia.org/wiki/Verbal_arithmetic">Alphametics on Wikipedia</a>
<li><a href="http://www.tkcs-collins.com/truman/alphamet/index.shtml">Alphametics Index</a>, včetně <a href="http://www.tkcs-collins.com/truman/alphamet/alphamet.shtml">mnoha zadání</a> a <a href="http://www.tkcs-collins.com/truman/alphamet/alpha_gen.shtml">generátoru vašich vlastních zadání</a>
</ul>

<p>Mnohokrát děkuji Raymondu Hettingerovi za souhlas s úpravou licence jeho kódu, abych ho mohl přepsat pro Python 3 a použít jako základ této kapitoly.

</div>
<div id=chapter-unit-testing>
<h1>Unit Testing</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> Certitude is not the test of certainty. We have been cocksure of many things that were not so. <span class="u">&#x275E;</span><br>(Pocit jistoty není měřítkem jistoty. Byli jsme si skálopevně jisti mnoha věcmi, které takové nebyly.)<br>&mdash; <a href="http://en.wikiquote.org/wiki/Oliver_Wendell_Holmes,_Jr.">Oliver Wendell Holmes, Jr.</a>
</blockquote>
<p>&nbsp;
<h2 id=unit-testing-divingin>(Ne)ponořme se</h2>
<p class=f>Ta dnešní mládež. Jsou tak zkažení těmi rychlými počítači a módními „dynamickými“ jazyky. Rychle napsat, pak dodat a ladit až nakonec (jestli vůbec). Za mých časů jsme dodržovali disciplínu. Říkám disciplínu! Museli jsme psát programy <em>ručně</em>, na <em>papír</em> a cpát je do počítače na <em>děrných štítcích</em>. A ono se nám to <em>líbilo</em>! A cože? Že je ten nadpis anglicky? Buďte rádi, že není v ruštině. Mnozí z vás ani neví, jak přečíst jednotlivá písmenka azbuky. No dobrá, trochu zvážním. Dá se to přeložit jako „testování jednotek“ nebo „jednotkové testování“. Ještě se k tomu dostaneme.

<p>V této kapitole si napíšeme a odladíme pár pomocných funkcí pro konverzi na a z římských čísel. Způsob tvorby a ověřování římských čísel jsme si ukázali v podkapitole <a href=#regular-expressions-romannumerals>Případová studie: Římská čísla</a>. Teď si poodstoupíme a zvážíme, kolik by dalo práce rozšířit původní kód na obousměrné pomocné funkce.
<p><a href=#regular-expressions-romannumerals>Pravidla pro římská čísla</a> vedla k řadě zajímavých postřehů:
<ol>
<li>Existuje jen jeden správný způsob vyjádření konkrétního čísla římskými číslicemi.
<li>Platí také opak. Pokud je řetězec znaků platným římským číslem, reprezentuje jen jedno možné číslo (to znamená, že řetězec může být interpretován jen jedním způsobem).
<li>Římskými čísly lze vyjádřit jen omezený rozsah čísel, konkrétně od <code>1</code> do <code>3999</code>. Římané používali několik způsobů vyjádření větších čísel. Tak například pruhem nad římským číslem vyjadřovali, že jeho číselná hodnota musí být vynásobená tisícem. Pro účely této kapitoly budeme uvažovat jen římská čísla od <code>1</code> do <code>3999</code>.
<li>Neexistuje způsob, jak římskými číslicemi vyjádřit nulu.
<li>Neexistuje způsob, jak římskými číslicemi vyjádřit záporná čísla.
<li>Neexistuje způsob, jak římskými číslicemi vyjádřit zlomky nebo neceločíselné hodnoty.
</ol>
<p>Začněme mapovat, co by takový modul <code>roman.py</code> měl dělat. Bude obsahovat dvě hlavní funkce, <code>to_roman()</code> (na římské číslo) a <code>from_roman()</code> (z římského čísla). Funkce <code>to_roman()</code> by měla převzít celé číslo v intervalu od <code>1</code> do <code>3999</code> a vrátit jeho reprezentaci římskými číslicemi jako řetězec&hellip;
<p>Hned tady se zastavíme. Teď uděláme něco trošku neočekávaného. Napíšeme si testovací příklad, který kontroluje, zda funkce <code>to_roman()</code> dělá to, co po ní chceme. Čtete dobře. Jdeme psát kód, který testuje jiný kód, který jsme ještě nenapsali.
<p>Říká se tomu <i>vývoj řízený testy (test-driven development)</i> nebo <abbr>TDD</abbr>. (V anglické literatuře si potrpí na zavádění a používání zkratek.) Dvojice převodních funkcí&nbsp;&mdash;&nbsp;<code>to_roman()</code> a později <code>from_roman()</code>&nbsp;&mdash;&nbsp;může být napsána a testována jako <em>jednotka</em> (unit), odděleně od jakéhokoliv většího programu, který funkce importuje. V Pythonu najdeme rámec (framework) pro unit testing (tedy testování jednotek), který má podobu příhodně nazvaného modulu <code>unittest</code>.
<p>Unit testing (testování jednotek) představuje důležitou součást celkové vývojové strategie založené na testování. Pokud testy jednotek píšete, je důležité, abyste je napsali brzy a abyste je udržovali v závislosti na změnách kódu a požadavků. Mnozí lidé se přimlouvají za to, aby se testy psaly dříve než kód, který mají testovat. V této kapitole si takový přístup předvedeme. Ale testy jednotek mají své výhody nezávisle na tom, kdy je napíšete.
<ul>
<li>Napsání jednotkových testů (i takto se to dá překládat) ještě před napsáním kódu vás účelným způsobem donutí upřesnit své požadavky
<li>Při vlastním psaní kódu vás pak jednotkové testy brzdí před psaním nadbytečných věcí. Jakmile všechny testy projdou, dosáhli jste úplné funkčnosti.
<li>Při provádění refaktorizace kódu vám testy jednotek pomohou prokázat, že se nová verze chová stejným způsobem jako ta stará.
<li>Při údržbě kódu vám existence testů pomůže krýt záda (v originále se mluví o té části těla, kde záda ztrácejí své slušné jméno) v situaci, kdy na vás někdo přiletí a řve, že vaše poslední změny pokazily jejich původní kód. („Ale <em>pane</em>, ale když jsem změny zveřejňoval, všechny unit testy prošly...“)
<li>Pokud píšeme kód v týmu, pak existence společné sady testů dramaticky snižuje možnost, že by váš kód způsobil nefunkčnost kódu někoho jiného. Jejich testy jednotek totiž můžete spustit jako první. (Tenhle druh závodů v psaní kódu už jsem zažil. Tým si zadání rozdělí, každý si převezme specifikace svého úkolu, napíše pro něj jednotkové testy a pak je dá k dispozici ostatním členům týmu. Při takovém postupu nikdo nezabloudí tak daleko, že by jím vyvíjený kód nespolupracoval s výsledky ostatních.)
</ul>
<p class=a>&#x2042;

<h2 id=unit-testing-romantest1>Jediná otázka</h2>
<aside>Každý test je ostrov.</aside>
<p>Testovací případ (test case) odpovídá na jedinou otázku, která se testovaného kódu týká. Testovací případ by měl být schopen&hellip;
<ul>
<li>&hellip; běžet zcela samostatně, bez jakéhokoliv lidského zásahu. Unit testing (testování jednotek) souvisí s automatizací.
<li>&hellip; sám rozhodnout o tom, zda testovaná funkce prošla nebo selhala &mdash; bez nutnosti posuzování výsledků člověkem.
<li>&hellip; běžet izolovaně, odděleně od jakýchkoliv jiných testovacích případů (dokonce i když testují stejnou funkci). Každý testovací případ je ostrov.
</ul>
<p>S ohledem na uvedené předpoklady začněme budovat testovací případ pro první požadavek:
<ol>
<li>Funkce <code>to_roman()</code> by měla vracet reprezentaci římského čísla pro všechna celá čísla v intervalu <code>1</code> až <code>3999</code>.
</ol>
<p>V prvním okamžiku není zřejmé, jak následující kód dělá&hellip; no vlastně <em>cokoliv</em>. Definuje třídu, která nemá žádnou metodu <code>__init__()</code>. Třída sice <em>má</em> nějakou metodu, ale ta se nikdy nevolá. Celý skript obsahuje blok <code>__main__</code>, ale nenajdeme v něm odkaz ani na třídu, ani na její metodu. Ale on opravdu něco dělá. Za to ručím.
<p class=d>[<a href="examples/romantest1.py">stáhnout <code>romantest1.py</code></a>]
<pre class=pp><code>import roman1
import unittest

<a>class KnownValues(unittest.TestCase):               <span class=u>&#x2460;</span></a>
    known_values = ( (1, 'I'),
                     (2, 'II'),
                     (3, 'III'),
                     (4, 'IV'),
                     (5, 'V'),
                     (6, 'VI'),
                     (7, 'VII'),
                     (8, 'VIII'),
                     (9, 'IX'),
                     (10, 'X'),
                     (50, 'L'),
                     (100, 'C'),
                     (500, 'D'),
                     (1000, 'M'),
                     (31, 'XXXI'),
                     (148, 'CXLVIII'),
                     (294, 'CCXCIV'),
                     (312, 'CCCXII'),
                     (421, 'CDXXI'),
                     (528, 'DXXVIII'),
                     (621, 'DCXXI'),
                     (782, 'DCCLXXXII'),
                     (870, 'DCCCLXX'),
                     (941, 'CMXLI'),
                     (1043, 'MXLIII'),
                     (1110, 'MCX'),
                     (1226, 'MCCXXVI'),
                     (1301, 'MCCCI'),
                     (1485, 'MCDLXXXV'),
                     (1509, 'MDIX'),
                     (1607, 'MDCVII'),
                     (1754, 'MDCCLIV'),
                     (1832, 'MDCCCXXXII'),
                     (1993, 'MCMXCIII'),
                     (2074, 'MMLXXIV'),
                     (2152, 'MMCLII'),
                     (2212, 'MMCCXII'),
                     (2343, 'MMCCCXLIII'),
                     (2499, 'MMCDXCIX'),
                     (2574, 'MMDLXXIV'),
                     (2646, 'MMDCXLVI'),
                     (2723, 'MMDCCXXIII'),
                     (2892, 'MMDCCCXCII'),
                     (2975, 'MMCMLXXV'),
                     (3051, 'MMMLI'),
                     (3185, 'MMMCLXXXV'),
                     (3250, 'MMMCCL'),
                     (3313, 'MMMCCCXIII'),
                     (3408, 'MMMCDVIII'),
                     (3501, 'MMMDI'),
                     (3610, 'MMMDCX'),
                     (3743, 'MMMDCCXLIII'),
                     (3844, 'MMMDCCCXLIV'),
                     (3888, 'MMMDCCCLXXXVIII'),
                     (3940, 'MMMCMXL'),
<a>                     (3999, 'MMMCMXCIX'))           <span class=u>&#x2461;</span></a>

<a>    def test_to_roman_known_values(self):           <span class=u>&#x2462;</span></a>
        '''to_roman should give known result with known input'''
        for integer, numeral in self.known_values:
<a>            result = roman1.to_roman(integer)       <span class=u>&#x2463;</span></a>
<a>            self.assertEqual(numeral, result)       <span class=u>&#x2464;</span></a>

if __name__ == '__main__':
    unittest.main()</code></pre>
<ol>
<li>Když chceme napsat nějaký testovací případ (test case), musíme nejdříve vytvořit třídu odvozenou od třídy <code>TestCase</code> z modulu <code>unittest</code>. Uvedená třída nám poskytuje řadu užitečných metod, které můžeme v našem testovacím případě využít pro testování specifických podmínek.
<li>Tohle je n-tice dvojic s celým číslem a s římským číslem, které jsem ověřil ručně. Obsahuje deset nejmenších čísel, největší číslo, každé číslo, které se vyjadřuje jednoznakovým římským číslem, a náhodnou sadu dalších platných čísel. Nemusíme testovat každý možný vstup, ale měli bychom se pokusit otestovat všechny zřejmé hraniční případy.
<li>Pro každý jednotlivý test je vytvořena jeho vlastní metoda. Metoda testu nemá žádné parametry, nevrací žádnou hodnotu a její jméno musí začínat čtyřmi písmeny <code>test</code>. Pokud testovací metoda skončí normálně, bez vyvolání výjimky, pokládáme test za úspěšný. Pokud metoda vyvolá výjimku, považujeme to za selhání testu.
<li>Tady voláme skutečnou funkci <code>to_roman()</code>. (Tu funkci jsme zatím nenapsali, ale jakmile ji jednou napíšeme, tento řádek ji zavolá.) Všimněte si, že jsme v tomto okamžiku pro funkci <code>to_roman()</code> definovali aplikační programové rozhraní (<abbr>API</abbr>). Musí přebírat celé číslo (převáděné číslo) a vrací řetězec (reprezentaci římského čísla). Pokud by rozhraní funkce bylo jiné, test by selhal. Všimněte si také, že při volání <code>to_roman()</code> žádnou výjimku neodchytáváme. Je to záměrné. Funkce <code>to_roman()</code> by při volání s platným vstupem žádnou výjimku vyvolat neměla a uvedené vstupní hodnoty jsou všechny platné. Pokud <code>to_roman()</code> vyvolá výjimku, bude se to považovat za selhání tohoto testu.
<li>Dejme tomu, že funkce <code>to_roman()</code> byla korektně definována, korektně volána, úspěšně skončila a vrátila výsledek. Pak nám jako poslední krok zbývá zkontrolovat, zda vrátila <em>správnou</em> hodnotu. Jde o obecně používaný dotaz. Ke kontrole, zda se dvě hodnoty shodují, poskytuje třída <code>TestCase</code> metodu <code>assertEqual</code>. Pokud výsledek (<var>result</var>) vrácený funkcí <code>to_roman()</code> neodpovídá očekávané známé hodnotě (<var>numeral</var>), vyvolá <code>assertEqual</code> výjimku a test selže. Pokud se ty dvě hodnoty shodují, neudělá <code>assertEqual</code> nic. Pokud všechny hodnoty vrácené funkcí <code>to_roman()</code> odpovídají očekávaným hodnotám, <code>assertEqual</code> nikdy výjimku nevyvolá, takže metoda <code>test_to_roman_known_values</code> nakonec normálně skončí. To znamená, že funkce <code>to_roman()</code> testem prošla.
</ol>
<aside>Napište test, který selže, a pak programujte, dokud neprojde.</aside>
<p>Jakmile máme vytvořen testovací případ, začneme psát funkci <code>to_roman()</code>. Nejdříve ji nahradíme prázdnou funkcí a ověříme si, že test selhává. Pokud by test prošel, aniž jsme napsali nějaký kód, pak by testy náš kód vůbec netestovaly! Unit testing je jako tanec: testy vedou, kód následuje. Napište test, který selže, a pak programujte, dokud neprojde.
<pre class=pp><code># roman1.py

def to_roman(n):
    '''convert integer to Roman numeral'''
<a>    pass                                   <span class=u>&#x2460;</span></a></code></pre>
<ol>
<li>V této fázi bychom rádi definovali rozhraní funkce <code>to_roman()</code>, ale nechceme zatím psát žádný kód. (Náš test musí nejdříve selhat.) Prázdné funkčnosti dosáhneme použitím pythonovského vyhrazeného slova <code>pass</code>, které dělá doslova nic.
</ol>
<p>Spuštění testu zajistíme provedením <code>romantest1.py</code> z příkazového řádku. Pokud jej zavoláme s volbou <code>-v</code>, dosáhneme podrobnějšího výstupu, takže přesně uvidíme, co se při běhu každého testovacího případu děje. S trochou štěstí by váš výstup měl vypadat nějak takto:
<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest1.py -v</kbd>
<a><samp>test_to_roman_known_values (__main__.KnownValues)</samp>                      <span class=u>&#x2460;</span></a>
<a><samp>to_roman should give known result with known input ... FAIL</samp>            <span class=u>&#x2461;</span></a>
<samp>
======================================================================
FAIL: to_roman should give known result with known input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest1.py", line 73, in test_to_roman_known_values
    self.assertEqual(numeral, result)
<a>AssertionError: 'I' != None                                            <span class=u>&#x2462;</span></a>

----------------------------------------------------------------------
<a>Ran 1 test in 0.016s                                                   <span class=u>&#x2463;</span></a>

<a>FAILED (failures=1)                                                    <span class=u>&#x2464;</span></a></samp></pre>
<ol>
<li>Když skript spustíme, spustí se funkce <code>unittest.main()</code>, která zajistí provedení každého testovacího případu. Každý testovací případ je metodou třídy z <code>romantest1.py</code>. U testovacích tříd se nevyžaduje nějaká zvláštní organizace. Každá z nich může obsahovat jedinou metodu, nebo můžeme mít jednu třídu, která obsahuje množství testovacích metod. Jediným požadavkem je to, že každá testovací třída musí dědit z třídy <code>unittest.TestCase</code>.
<li>Pro každý testovací případ modul <code>unittest</code> vytiskne <code>docstring</code> metody a to, zda test prošel (pass) nebo selhal (fail). Tento test podle očekávání selhal.
<li>Pro každý testovací případ, který selhal, zobrazí <code>unittest</code> trasovací informaci, která přesně ukazuje, co se stalo. V tomto případě vyvolala metoda <code>assertEqual()</code> výjimku <code>AssertionError</code>, protože se očekávalo, že funkce <code>to_roman(1)</code> vrátí <code>'I'</code>, ale nevrátila. (Protože jsme v ní explicitně neuvedli příkaz <code>return</code>, vrátila funkce hodnotu <code>None</code>, což je pythonovský ekvivalent hodnoty null.)
<li>Po detailních výpisech každého testu zobrazí <code>unittest</code> souhrnně, kolik testů se provádělo a jak dlouho to trvalo.
<li>Testovací běh celkově selhal, protože minimálně jeden test neprošel. Pokud testovací případ neprojde, rozlišuje <code>unittest</code> mezi selháním (failure) a chybou (error). Selhání (failure) je důsledkem volání metody <code>assertXYZ</code>, jako je například <code>assertEqual</code> nebo <code>assertRaises</code>, která selhala, protože neplatí předepsaná podmínka nebo nebyla vyvolána očekávaná výjimka. Za chybu (error) se považuje jakýkoliv jiný druh výjimky, která vznikla uvnitř testované kódu nebo v kódu testovacího případu.
</ol>
<p>A <em>teď</em> už můžeme konečně napsat funkci <code>to_roman()</code>.
<p class=d>[<a href="examples/roman1.py">stáhnout <code>roman1.py</code></a>]
<pre class=pp><code>roman_numeral_map = (('M',  1000),
                     ('CM', 900),
                     ('D',  500),
                     ('CD', 400),
                     ('C',  100),
                     ('XC', 90),
                     ('L',  50),
                     ('XL', 40),
                     ('X',  10),
                     ('IX', 9),
                     ('V',  5),
                     ('IV', 4),
<a>                     ('I',  1))                 <span class=u>&#x2460;</span></a>

def to_roman(n):
    '''convert integer to Roman numeral'''
    result = ''
    for numeral, integer in roman_numeral_map:
<a>        while n >= integer:                     <span class=u>&#x2461;</span></a>
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li><var>roman_numeral_map</var> je n-tice n-tic, které definují tři věci: znakovou reprezentaci nejzákladnějších římských čísel, pořadí římských čísel (sestupně od <code>M</code> až po <code>I</code>), hodnotu každého římského čísla. Každá vnitřní n-tice je dvojicí <code>(<var>římské číslo</var>, <var>hodnota</var>)</code>. Nejsou zde jen jednoznaková římská čísla. Jsou zde definována i dvojznaková čísla jako <code>CM</code> („o jedno sto méně než jeden tisíc“). Tím se kód funkce <code>to_roman()</code> zjednoduší.
<li>Zde je to místo, kde se bohatá datová struktura <var>roman_numeral_map</var> uplatní, protože díky ní k realizaci odečítacího pravidla nepotřebujeme žádnou speciální logiku. Při převodu na římské číslo jednoduše procházíme strukturou <var>roman_numeral_map</var> a hledáme největší celočíselnou hodnotu, která je menší nebo rovna vstupu. Jakmile ji nalezneme, přidáme její reprezentaci římským číslem na konec výstupu, odečteme odpovídající celočíselnou hodnotu od vstupu, namydlíme, opláchneme, zopakujeme.
</ol>
<p>Pokud vám pořád není jasné, jak funkce <code>to_roman()</code> pracuje, přidejte na konec cyklu <code>while</code> volání funkce <code>print()</code>:
<pre class='nd pp'><code>
while n >= integer:
    result += numeral
    n -= integer
    print('subtracting {0} from input, adding {1} to output'.format(integer, numeral))</code></pre>
<p>S ladicími příkazy <code>print()</code> vypadá výstup takto:
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import roman1</kbd>
<samp class=p>>>> </samp><kbd class=pp>roman1.to_roman(1424)</kbd>
<samp>subtracting 1000 from input, adding M to output
subtracting 400 from input, adding CD to output
subtracting 10 from input, adding X to output
subtracting 10 from input, adding X to output
subtracting 4 from input, adding IV to output
'MCDXXIV'</samp></pre>
<p>Takže se zdá, že funkce <code>to_roman()</code> pracuje přinejmenším v tomto ručně zkoušeném případě. Ale projde testovacím případem, který jsme napsali?
<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest1.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
<a>to_roman should give known result with known input ... ok               <span class=u>&#x2460;</span></a>

----------------------------------------------------------------------
Ran 1 test in 0.016s

OK</samp></pre>
<ol>
<li>Hurá! Funkce <code>to_roman()</code> prošla testovacím případem nazvaným „známé hodnoty“. Není sice všeobsažný, ale prověřil schopnosti funkce celou škálou vstupů, včetně vstupů, které produkují každé jednoznakové římské číslo, největší možný vstup (<code>3999</code>), a vstupu, který produkuje nejdelší možné římské číslo (<code>3888</code>). V tomto okamžiku už můžeme docela důvěřovat tomu, že funkce pracuje pro libovolnou správnou vstupní hodnotu, kterou bychom mohli zadat.
</ol>
<p>„Správný“ vstup? Hmm. A co takhle chybný vstup?
<p class=a>&#x2042;

<h2 id=unit-testing-romantest2>„Zastav a začni hořet“</h2>
<aside>Pythonovská signalizace typu „zastav a začni hořet“ spočívá ve vyvolání výjimky.</aside>
<p>Ono ale nestačí, když funkce uspějí při zadání správného vstupu. Musíme otestovat také to, že při chybném vstupu dojde k jejich selhání. Ale nemůže jít o jakýkoliv způsob selhání. Funkce musí selhat očekávaným způsobem.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import roman1</kbd>
<samp class=p>>>> </samp><kbd class=pp>roman1.to_roman(4000)</kbd>
<samp class=pp>'MMMM'</samp>
<samp class=p>>>> </samp><kbd class=pp>roman1.to_roman(5000)</kbd>
<samp class=pp>'MMMMM'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>roman1.to_roman(9000)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>'MMMMMMMMM'</samp></pre>
<ol>
<li>Tohle určitě není to, co jsme chtěli. Vždyť se dokonce nejedná ani o platné římské číslo! Každé z těchto čísel leží ve skutečnosti mimo rozsah přijatelných vstupů, ale funkce pro ně stejně vrací falešné, vykonstruované hodnoty. Pokud potichu vracíme špatné hodnoty, je to <em>velmi špatné</em>. Pokud má program selhat, pak je mnohem lepší, když selže rychle a nahlas. Jak se říká, „zastav a začni hořet“. (Jde o překlad anglické fráze „<a href="http://en.wikipedia.org/wiki/Halt_and_Catch_Fire">Halt And Catch Fire</a>“, která se při práci na úrovních blízkých hardwaru vztahuje k mechanismu velmi dobře pozorovatelného projevu nějaké neočekávané chyby. Vysvětlení původu této hlášky se různí, od skutečně kouřících přežhavených drátků feritové paměti při dynamické realizaci instrukce HALT, až po speciální nedokumentované strojové instrukce, které uvedou procesor do testovacího režimu.) Pythonovská signalizace typu „zastav a začni hořet“ spočívá ve vyvolání výjimky.
</ol>
<p>Měli byste si položit otázku: „Jak bychom to mohli vyjádřit formou testovatelného požadavku?“ Co kdybychom začali nějak takto:
<blockquote>
<p>Pokud funkci <code>to_roman()</code> zadáme celé číslo větší než <code>3999</code>, měla by vyvolat výjimku <code>OutOfRangeError</code>.
</blockquote>
<p>Jak by vypadal příslušný test?
<p class=d>[<a href="examples/romantest2.py">stáhnout <code>romantest2.py</code></a>]
<pre class=pp><code>import unittest, roman2
<a>class ToRomanBadInput(unittest.TestCase):                                 <span class=u>&#x2460;</span></a>
<a>    def test_too_large(self):                                             <span class=u>&#x2461;</span></a>
        '''to_roman should fail with large input'''
<a>        self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)  <span class=u>&#x2462;</span></a></code></pre>
<ol>
<li>Podobně jako v předchozím testovacím případě vytvoříme třídu, která dědí z <code>unittest.TestCase</code>. Jedna třída sice může obsahovat více než jeden test (jak si ukážeme v této kapitole později), ale já jsem se rozhodl, že vytvořím novou třídu, protože tento test dělá něco jiného než ten minulý. Všechny testy správných vstupů budeme udržovat v jedné třídě a o všechny testy chybných vstupů se bude starat druhá třída.
<li>Vlastní test, stejně jako v předchozím testovacím případě, má podobu metody třídy. Její jméno začíná písmeny <code>test</code>.
<li>Třída <code>unittest.TestCase</code> poskytuje metodu <code>assertRaises</code>, která přebírá následující argumenty: očekávanou výjimku, testovanou funkci a argumenty, které jí chceme předat. (Pokud testovaná funkce očekává více než jeden argument, předejte je metodě <code>assertRaises</code> všechny v daném pořadí. Ona už se postará o jejich předání testované funkci.)
</ol>
<p>Věnujte zvláštní pozornost tomu poslednímu řádku kódu. Místo toho, abychom volali <code>to_roman()</code>, přímo a ručně zkontrolovali, že vyvolává konkrétní výjimku (obalením <a href=#your-first-python-program-exceptions>do bloku <code>try...except</code></a>), metoda <code>assertRaises</code> to vše udělá za nás. Musíme jí jen říct, jakou výjimku očekáváme (<code>roman2.OutOfRangeError</code>), předat funkci (<code>to_roman()</code>) a její argumenty (<code>4000</code>). Metoda <code>assertRaises</code> se postará o zavolání <code>to_roman()</code> a o kontrolu toho, že vyvolala výjimku <code>roman2.OutOfRangeError</code>.
<p>Poznamenejme také, že funkci <code>to_roman()</code> předáváme jako argument. Nevoláme ji a ani nepředáváme její jméno jako řetězec. Zmínil jsem se už dříve o tom, jak je šikovné, že <a href=#your-first-python-program-everythingisanobject>v Pythonu je vše objektem</a>?
<p>Takže co se stane, když spustíme sadu testů doplněnou o tento nový test?
<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest2.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
to_roman should give known result with known input ... ok
test_too_large (__main__.ToRomanBadInput)
<a>to_roman should fail with large input ... ERROR                         <span class=u>&#x2460;</span></a>

======================================================================
ERROR: to_roman should fail with large input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest2.py", line 78, in test_too_large
    self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
<a>AttributeError: 'module' object has no attribute 'OutOfRangeError'      <span class=u>&#x2461;</span></a>

----------------------------------------------------------------------
Ran 2 tests in 0.000s

FAILED (errors=1)</samp></pre>
<ol>
<li>Asi jste očekávali, že dojde k selhání (protože zatím jsme nenapsali žádný kód, aby to prošlo), ale... ono to ve skutečnosti „neselhalo“ (fail). Místo toho došlo k „chybě“ (error). Je to sice jemný, ale důležitý rozdíl. Jednotkový test má ve skutečnosti <em>tři</em> návratové hodnoty: prošel (pass), selhal (fail) a chyba (error). „Pass“ (prošel) samozřejmě znamená, že test prošel. Kód dělá to, co jsme očekávali. „Fail“ (selhal) vyjadřuje to, co udělal minulý test (než jsme napsali kód, díky kterému prošel). Kód se provedl, ale výsledek neodpovídá tomu, co jsme očekávali. „Error“ (chyba) se objeví, když kód ani správně nedoběhl.
<li>A proč vlastně kód správně neproběhl? Vše se dozvíme z trasovacího hlášení. Testovaný modul vůbec nedefinuje výjimku zvanou <code>OutOfRangeError</code> (tj. hodnota mimo platný rozsah). Připomeňme si, že uvedenou výjimku jsme předali metodě <code>assertRaises()</code>, protože právě tohle má být výjimka, kterou má funkce vyvolat, když zadáme vstup mimo platný rozsah. Ale tato výjimka vůbec neexistuje, takže volání metody <code>assertRaises()</code> selhalo. Metoda neměla vůbec šanci otestovat funkci <code>to_roman()</code>. Tak daleko se vůbec nedostala.
</ol>
<p>K vyřešení zmíněného problému musíme v <code>roman2.py</code> doplnit definici výjimky <code>OutOfRangeError</code>.
<pre class=pp><code><a>class OutOfRangeError(ValueError):  <span class=u>&#x2460;</span></a>
<a>    pass                            <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>Výjimky mají podobu tříd. Chyba „mimo platný rozsah“ je druhem chyby hodnoty. Hodnota argumentu se nachází mimo přijatelné meze. Z tohoto důvodu výjimka dědí ze zabudované výjimky <code>ValueError</code>. Není to nezbytně nutné (mohli bychom prostě dědit od bázové třídy <code>Exception</code>, tj. obecná výjimka), ale zdá se to být správné.
<li>Výjimky samy o sobě ve skutečnosti nic nedělají, ale potřebujete nejméně jeden řádek kódu, abychom definovali třídu. Volání <code>pass</code> sice nic nedělá, ale je to řádek pythonovského kódu, který zajistí, že třída vznikne.
</ol>
<p>Teď spustíme sadu testů znovu.
<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest2.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
to_roman should give known result with known input ... ok
test_too_large (__main__.ToRomanBadInput)
<a>to_roman should fail with large input ... FAIL                          <span class=u>&#x2460;</span></a>

======================================================================
FAIL: to_roman should fail with large input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest2.py", line 78, in test_too_large
    self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
<a>AssertionError: OutOfRangeError not raised by to_roman                 <span class=u>&#x2461;</span></a>

----------------------------------------------------------------------
Ran 2 tests in 0.016s

FAILED (failures=1)</samp></pre>
<ol>
<li>Nový test sice stále neprošel, ale už také nevrací chybu. Místo toho došlo k selhání testu. To je pokrok! To znamená, že volání metody <code>assertRaises()</code> tentokrát prošlo a rámec pro testování jednotek (unit test framework) skutečně testoval funkci <code>to_roman()</code>.
<li>Funkce <code>to_roman()</code> zatím, samozřejmě, nevyvolává právě definovanou výjimku <code>OutOfRangeError</code>, protože jsme jí ještě neřekli, že to má dělat. To je ale výborná zpráva! Znamená to, že máme platný testovací případ&nbsp;&mdash;&nbsp;selhává (fails) před napsáním kódu, který zajistí, že projde.
</ol>
<p>Teď napíšeme kód, který zajistí, aby funkce testem prošla.
<p class=d>[<a href="examples/roman2.py">stáhnout <code>roman2.py</code></a>]
<pre class=pp><code>def to_roman(n):
    '''convert integer to Roman numeral'''
    if n > 3999:
<a>        raise OutOfRangeError('number out of range (must be less than 4000)')  <span class=u>&#x2460;</span></a>

    result = ''
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li>Přímočaré řešení: Pokud je daný vstup (<var>n</var>) větší než <code>3999</code>, vyvolej výjimku <code>OutOfRangeError</code>. Tento jednotkový test nekontroluje, zda výjimku doprovází lidsky čitelný řetězec. Mohli bychom napsat další test, který by to kontroloval (ale pozor na problémy s internacionalizací; řetězce se mohou lišit v závislosti na jazyku uživatele a v závislosti na prostředí).
</ol>
<p>Vede úprava k tomu, že test projde? Pojďme to zjistit.
<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest2.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
to_roman should give known result with known input ... ok
test_too_large (__main__.ToRomanBadInput)
<a>to_roman should fail with large input ... ok                            <span class=u>&#x2460;</span></a>

----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK</samp></pre>
<ol>
<li>Hurá! Oba testy prošly. Protože jsme pracovali po krocích (přebíhali jsme mezi testováním a psaním kódu), můžeme si být jisti, že ty dva řádky kódu, které jsme právě napsali, byly příčinou toho, že se výsledek testu změnil z „fail“ (selhal) na „pass“ (prošel). Tento druh (sebe)důvěry sice nebyl zadarmo, ale během života našeho kódu se ještě vyplatí.
</ol>

<p class=a>&#x2042;

<h2 id=unit-testing-romantest3>Více zastávek, více ohně</h2>

<p>Spolu s testováním čísel, která jsou příliš velká, bychom měli testovat i čísla, která jsou příliš malá. Přesně jak jsme poznamenali <a href=#unit-testing-divingin>v našich požadavcích na funkčnost</a>, římská čísla nemohou vyjádřit nulu nebo záporná čísla.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import roman2</kbd>
<samp class=p>>>> </samp><kbd class=pp>roman2.to_roman(0)</kbd>
<samp class=pp>''</samp>
<samp class=p>>>> </samp><kbd class=pp>roman2.to_roman(-1)</kbd>
<samp class=pp>''</samp></pre>

<p>Hmm, <em>tohle</em> není dobré. Přidejme testy pro každou z těchto podmínek.

<p class=d>[<a href="examples/romantest3.py">stáhnout <code>romantest3.py</code></a>]
<pre class=pp><code>class ToRomanBadInput(unittest.TestCase):
    def test_too_large(self):
        '''to_roman should fail with large input'''
<a>        self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 4000)  <span class=u>&#x2460;</span></a>

    def test_zero(self):
        '''to_roman should fail with 0 input'''
<a>        self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 0)     <span class=u>&#x2461;</span></a>

    def test_negative(self):
        '''to_roman should fail with negative input'''
<a>        self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, -1)    <span class=u>&#x2462;</span></a></code></pre>
<ol>
<li>Metoda <code>test_too_large()</code> se od minulého kroku nezměnila. Ponechal jsem ji zde, abych ukázal, kam nový kód zapadá.
<li>Máme tu nový test, metodu <code>test_zero()</code>. Je to stejné jako u metody <code>test_too_large()</code>. Metodě <code>assertRaises()</code> z třídy <code>unittest.TestCase</code> říkáme, aby zavolala naši funkci <code>to_roman()</code> s parametrem <code>0</code> a zkontrolovala, zda vyvolá příslušnou výjimku <code>OutOfRangeError</code>.
<li>Metoda <code>test_negative()</code> je téměř shodná až na to, že funkci <code>to_roman()</code> předává hodnotu <code>-1</code>. Pokud kterýkoliv z těchto nových testů <em>nevyvolá</em> výjimku <code>OutOfRangeError</code> (protože funkce buď vrátí nějakou skutečnou hodnotu nebo vyvolá nějakou jinou výjimku), bude se to považovat za selhání testu.
</ol>

<p>Teď zkontrolujme, že testy selhávají:

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest3.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
to_roman should give known result with known input ... ok
test_negative (__main__.ToRomanBadInput)
to_roman should fail with negative input ... FAIL
test_too_large (__main__.ToRomanBadInput)
to_roman should fail with large input ... ok
test_zero (__main__.ToRomanBadInput)
to_roman should fail with 0 input ... FAIL

======================================================================
FAIL: to_roman should fail with negative input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest3.py", line 86, in test_negative
    self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, -1)
AssertionError: OutOfRangeError not raised by to_roman

======================================================================
FAIL: to_roman should fail with 0 input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest3.py", line 82, in test_zero
    self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 0)
AssertionError: OutOfRangeError not raised by to_roman

----------------------------------------------------------------------
Ran 4 tests in 0.000s

FAILED (failures=2)</samp></pre>

<p>Výborně. Oba testy podle očekávání selhaly. Teď se přepněme na psaní kódu a uvidíme, co můžeme dělat, aby testy prošly.

<p class=d>[<a href="examples/roman3.py">stáhnout <code>roman3.py</code></a>]
<pre class=pp><code>def to_roman(n):
    '''convert integer to Roman numeral'''
<a>    if not (0 &lt; n &lt; 4000):                                              <span class=u>&#x2460;</span></a>
<a>        raise OutOfRangeError('number out of range (must be 1..3999)')  <span class=u>&#x2461;</span></a>

    result = ''
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li>Tohle je pěkná pythonovská zkratka &mdash; více porovnání najednou. Je to ekvivalentní zápisu <code>if not ((0 &lt; n) and (n &lt; 4000))</code>, ale je to mnohem čitelnější. Tento řádek kódu by měl zachytit vstupy, které jsou příliš velké, záporné nebo nulové.
<li>Pokud podmínky změníte, nezapomeňte odpovídajícím způsobem upravit i lidsky čitelný řetězec. Rámci <code>unittest</code> je to jedno. Pokud by ale váš kód vyvolával nesprávně popsané výjimky, ztížilo by se tím ruční ladění.
</ol>

<p>Mohl bych vám ukázat celou sérii nesouvisejících příkladů, které ukazují, že zkratka umožňující několik porovnání najednou funguje. Místo toho ale spustím testy jednotek a dokážu vám to.

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest3.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
to_roman should give known result with known input ... ok
test_negative (__main__.ToRomanBadInput)
to_roman should fail with negative input ... ok
test_too_large (__main__.ToRomanBadInput)
to_roman should fail with large input ... ok
test_zero (__main__.ToRomanBadInput)
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.016s

OK</samp></pre>

<p class=a>&#x2042;

<h2 id=unit-testing-romantest4>A ještě jedna věc&hellip;</h2>

<p>Mezi <a href=#unit-testing-divingin>požadavky na převod</a> na římská čísla byl ještě jeden, který se týkal neceločíselného vstupu.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import roman3</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>roman3.to_roman(0.5)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>''</samp>
<a><samp class=p>>>> </samp><kbd class=pp>roman3.to_roman(1.0)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'I'</samp></pre>
<ol>
<li>A jéje, to je špatné.
<li>Jejda, tohle je ještě horší. V obou uvedených případech by měla být vyvolána výjimka. Místo toho produkují falešné výstupy.
</ol>

<p>Testování na neceločíselný vstup není obtížné. Nejdříve si definujeme výjimku <code>NotIntegerError</code>.

<pre class='nd pp'><code># roman4.py
class OutOfRangeError(ValueError): pass
<mark>class NotIntegerError(ValueError): pass</mark></code></pre>

<p>Dále napíšeme testovací případ, který kontroluje výskyt výjimky <code>NotIntegerError</code>.

<pre class='nd pp'><code>class ToRomanBadInput(unittest.TestCase):
    .
    .
    .
    def test_non_integer(self):
        '''to_roman should fail with non-integer input'''
<mark>        self.assertRaises(roman4.NotIntegerError, roman4.to_roman, 0.5)</mark></code></pre>

<p>Teď zkontrolujme, zda test správně selhává.

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest4.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
to_roman should give known result with known input ... ok
test_negative (__main__.ToRomanBadInput)
to_roman should fail with negative input ... ok
test_non_integer (__main__.ToRomanBadInput)
to_roman should fail with non-integer input ... FAIL
test_too_large (__main__.ToRomanBadInput)
to_roman should fail with large input ... ok
test_zero (__main__.ToRomanBadInput)
to_roman should fail with 0 input ... ok

======================================================================
FAIL: to_roman should fail with non-integer input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest4.py", line 90, in test_non_integer
    self.assertRaises(roman4.NotIntegerError, roman4.to_roman, 0.5)
<mark>AssertionError: NotIntegerError not raised by to_roman</mark>

----------------------------------------------------------------------
Ran 5 tests in 0.000s

FAILED (failures=1)</samp></pre>

<p>Napíšeme kód, který má zajistit, aby test prošel.

<pre class=pp><code>def to_roman(n):
    '''convert integer to Roman numeral'''
    if not (0 &lt; n &lt; 4000):
        raise OutOfRangeError('number out of range (must be 1..3999)')
<a>    if not isinstance(n, int):                                          <span class=u>&#x2460;</span></a>
<a>        raise NotIntegerError('non-integers can not be converted')      <span class=u>&#x2461;</span></a>

    result = ''
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li>Zabudovaná funkce <code>isinstance()</code> testuje, zda je daná proměnná určitého typu (nebo, z technického hlediska, nějakého z něj odvozeného typu).
<li>Pokud argument <var>n</var> není typu <code>int</code>, vyvolej naši zbrusu novou výjimku <code>NotIntegerError</code>.
</ol>

<p>Nakonec zkontrolujeme, že tento kód zajistil průchod testem.

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest4.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
to_roman should give known result with known input ... ok
test_negative (__main__.ToRomanBadInput)
to_roman should fail with negative input ... ok
test_non_integer (__main__.ToRomanBadInput)
to_roman should fail with non-integer input ... ok
test_too_large (__main__.ToRomanBadInput)
to_roman should fail with large input ... ok
test_zero (__main__.ToRomanBadInput)
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 5 tests in 0.000s

OK</samp></pre>

<p>Funkce <code>to_roman()</code> prošla všemi testy a žádné další testy mě nenapadají. Takže nastal čas, abychom se přesunuli k <code>from_roman()</code>.

<p class=a>&#x2042;

<h2 id=unit-testing-romantest5>Symetrie, která potěší</h2>

<p>Převod řetězce vyjadřujícího římské číslo na číselnou hodnotu vypadá složitěji než převod čísla na římské číslo. Určitě budeme muset zajistit ověření platnosti. Zkontrolovat, zda je číslo rovno nule, je snadné. O něco obtížněji se kontroluje, zda je řetězec platným římským číslem. Jenže my už jsme zkonstruovali <a href=#regular-expressions-romannumerals>regulární výraz, který zkontroluje, zda jde o římské číslo</a>. Takže tuhle část už máme hotovou.

<p>Zbývá nám problém samotné konverze řetězce. Jak za chvíli uvidíme, díky existenci datové struktury, kterou jsme definovali pro převod určitých římských čísel na celočíselné hodnoty, bude jádro funkce <code>from_roman()</code> stejně přímočaré jako u funkce <code>to_roman()</code>.

<p>Ale nejdříve testy. Pro ověření správnosti konkrétních hodnot budeme potřebovat test „známých hodnot“. Naše testovací sada již <a href=#unit-testing-romantest1>tabulku známých hodnot</a> obsahuje, takže ji využijme.

<pre class='nd pp'><code>    def test_from_roman_known_values(self):
        '''from_roman should give known result with known input'''
        for integer, numeral in self.known_values:
            result = roman5.from_roman(numeral)
            self.assertEqual(integer, result)</code></pre>

<p>Najdeme zde potěšitelnou symetrii. Funkce <code>to_roman()</code> a <code>from_roman()</code> jsou vzájemně inverzní. První z nich převádí čísla na zvláštně formátované řetězce a druhá převádí zvláštně formátované řetězce na celá čísla. Teoreticky bychom měli být schopni dospět ke zvolenému číslu oklikou tak, že je nejdříve předáme funkci <code>to_roman()</code>. Získaný řetězec předáme funkci <code>from_roman()</code> a výsledné číslo by se mělo shodovat s počátečním.

<pre class='nd pp'><code>n = from_roman(to_roman(n)) pro všechny hodnoty n</code></pre>

<p>V tomto případě „všechny hodnoty“ znamená jakoukoliv hodnotu <code>1..3999</code>, protože toto je platný rozsah vstupů pro funkci <code>to_roman()</code>. Tuto symetrii můžeme vyjádřit testovacím případem, který prochází všechny hodnoty <code>1..3999</code>, volá <code>to_roman()</code>, volá <code>from_roman()</code> a kontroluje, zda se výstup shoduje s původním vstupem.

<pre class='nd pp'><code>class RoundtripCheck(unittest.TestCase):
    def test_roundtrip(self):
        '''from_roman(to_roman(n))==n for all n'''
        for integer in range(1, 4000):
            numeral = roman5.to_roman(integer)
            result = roman5.from_roman(numeral)
            self.assertEqual(integer, result)</code></pre>

<p>Tyto nové testy zatím ani neselžou (fail). Zatím jsme vůbec nedefinovali funkci <code>from_roman()</code>, takže způsobí chyby (errors).

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest5.py</kbd>
<samp>E.E....
======================================================================
ERROR: test_from_roman_known_values (__main__.KnownValues)
from_roman should give known result with known input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest5.py", line 78, in test_from_roman_known_values
    result = roman5.from_roman(numeral)
AttributeError: 'module' object has no attribute 'from_roman'

======================================================================
ERROR: test_roundtrip (__main__.RoundtripCheck)
from_roman(to_roman(n))==n for all n
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest5.py", line 103, in test_roundtrip
    result = roman5.from_roman(numeral)
AttributeError: 'module' object has no attribute 'from_roman'

----------------------------------------------------------------------
Ran 7 tests in 0.019s

FAILED (errors=2)</samp></pre>

<p>Problém vyřešíme rychlým vytvořením náhradní funkce.

<pre class='nd pp'><code># roman5.py
def from_roman(s):
    '''convert Roman numeral to integer'''</code></pre>

<p>(Hej, všimli jste si toho? Definoval jsem funkci, která neobsahuje nic než <a href=#your-first-python-program-docstrings>docstring</a> (dokumentační řetězec). Tohle je v Pythonu legální. Někteří programátoři vás ve skutečnosti zapřísahají: „Nepište náhrady. Dokumentujte!“)

<p>Teď už testovací případy opravdu selžou (fail).

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest5.py</kbd>
<samp>F.F....
======================================================================
FAIL: test_from_roman_known_values (__main__.KnownValues)
from_roman should give known result with known input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest5.py", line 79, in test_from_roman_known_values
    self.assertEqual(integer, result)
AssertionError: 1 != None

======================================================================
FAIL: test_roundtrip (__main__.RoundtripCheck)
from_roman(to_roman(n))==n for all n
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest5.py", line 104, in test_roundtrip
    self.assertEqual(integer, result)
AssertionError: 1 != None

----------------------------------------------------------------------
Ran 7 tests in 0.002s

FAILED (failures=2)</samp></pre>

<p>Nastal čas napsat funkci <code>from_roman()</code>.

<pre class=pp><code>def from_roman(s):
    """convert Roman numeral to integer"""
    result = 0
    index = 0
    for numeral, integer in roman_numeral_map:
<a>        while s[index:index+len(numeral)] == numeral:  <span class=u>&#x2460;</span></a>
            result += integer
            index += len(numeral)
    return result</code></pre>
<ol>
<li>Základní vzorec je zde stejný jako <a href=#unit-testing-romantest1>u funkce <code>to_roman()</code></a>. Procházíme datovou strukturou s římskými čísly (n-tice n-tic), ale místo hledání nejvyšších možných číselných hodnot se snažíme hledat řetězec znaků s „nejvyšším“ možným římským číslem.
</ol>

<p>Pokud vám pořád není jasné, jak funkce <code>from_roman()</code> pracuje, přidejte na konec cyklu <code>while</code> volání funkce <code>print</code>:

<pre><code>def from_roman(s):
    """convert Roman numeral to integer"""
    result = 0
    index = 0
    for numeral, integer in roman_numeral_map:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
<mark>            print('found', numeral, 'of length', len(numeral), ', adding', integer)</mark></code></pre>

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import roman5</kbd>
<samp class=p>>>> </samp><kbd class=pp>roman5.from_roman('MCMLXXII')</kbd>
<samp class=pp>found M of length 1, adding 1000
found CM of length 2, adding 900
found L of length 1, adding 50
found X of length 1, adding 10
found X of length 1, adding 10
found I of length 1, adding 1
found I of length 1, adding 1
1972</samp></pre>

<p>Nastal opět čas ke spuštění testů.

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest5.py</kbd>
<samp>.......
----------------------------------------------------------------------
Ran 7 tests in 0.060s

OK</samp></pre>

<p>Máme tady dvě vzrušující zprávy. Ta první je, že funkce <code>from_roman()</code> funguje pro správné vstupy &mdash; přinejmenším pro všechny <a href=#unit-testing-romantest1>známé hodnoty</a>. Ta druhá zpráva je, že test „kruhovým voláním“ (round trip test) také prošel. Když to zkombinujeme dohromady, můžeme si být docela jistí tím, že jak funkce <code>to_roman()</code>, tak funkce <code>from_roman()</code> pracují správně pro všechny možné správné hodnoty. (Není to ale zaručeno. Teoreticky je možné, že <code>to_roman()</code> obsahuje chybu, která pro určité hodnoty vstupů produkuje špatná římská čísla, <em>a současně</em> funkce <code>from_roman()</code> obsahuje obrácenou chybu, která produkuje stejná, ale špatná čísla přesně pro tu množinu římských čísel, která funkce <code>to_roman()</code> vygenerovala nesprávně. V závislosti na vaší aplikaci a na požadavcích by vám to mohlo dělat starosti. Pokud tomu tak je, napište obsažnější testovací případy, které vaše starosti rozptýlí.)

<p class=a>&#x2042;

<h2 id=unit-testing-romantest6>Více špatných vstupů</h2>

<p>Teď, když už funkce <code>from_roman()</code> pracuje správně pro korektní vstup, nastal čas k umístění posledního kousku skládanky &mdash; zajištění správné funkce pro špatné vstupy. To znamená, že musíme najít způsob, jak se podívat na řetězec a určit, zda je platným římským číslem. To už je ze své podstaty obtížnější než <a href=#unit-testing-romantest3>ověřování správnosti číselného vstupu</a> ve funkci <code>to_roman()</code>. Ale máme k dispozici mocný nástroj &mdash; regulární výrazy. (Pokud regulární výrazy neznáte, pak je vhodná doba na to, abyste si přečetli <a href=#chapter-regular-expressions>kapitolu o regulárních výrazech</a>.)

<p>V podkapitole <a href=#regular-expressions-romannumerals>Případová studie: Římská čísla</a> jsme viděli, že existuje několik jednoduchých pravidel pro konstrukci římského čísla, která jsou založena na využití písmen <code>M</code>, <code>D</code>, <code>C</code>, <code>L</code>, <code>X</code>, <code>V</code> a <code>I</code>. Pojďme si tato pravidla zopakovat:

<ul>
<li>V některých případech se znaky sčítají. <code>I</code> je <code>1</code>, <code>II</code> je rovno <code>2</code> a <code>III</code> znamená <code>3</code>. <code>VI</code> se rovná <code>6</code> (doslova „<code>5</code> a <code>1</code>“), <code>VII</code> je <code>7</code> a <code>VIII</code> je <code>8</code>.
<li>Desítkové znaky (<code>I</code>, <code>X</code>, <code>C</code> a <code>M</code>) se mohou opakovat nanejvýš třikrát. Hodnotu <code>4</code> musíme vyjádřit odečtením od dalšího vyššího pětkového znaku. Hodnotu <code>4</code> nemůžeme zapsat jako <code>IIII</code>. Místo toho ji musíme zapsat jako <code>IV</code> („o <code>1</code> méně než <code>5</code>“). <code>40</code> se zapisuje jako <code>XL</code> („o <code>10</code> méně než <code>50</code>“), <code>41</code> jako <code>XLI</code>, <code>42</code> jako <code>XLII</code>, <code>43</code> jako <code>XLIII</code> a následuje <code>44</code> jako <code>XLIV</code> („o <code>10</code> méně než <code>50</code> a k tomu o <code>1</code> méně než <code>5</code>“).
<li>Někdy znaky vyjadřují... opak sčítání. Když některé znaky umístíme před jiné, provádíme odčítání od konečné hodnoty. Například hodnotu <code>9</code> musíme vyjádřit odečtením od dalšího vyššího desítkového znaku: <code>8</code> zapíšeme jako <code>VIII</code>, ale <code>9</code> zapíšeme <code>IX</code> („o <code>1</code> méně než <code>10</code>“) a ne jako <code>VIIII</code> (protože znak <code>I</code> nemůžeme opakovat čtyřikrát). <code>90</code> je <code>XC</code>, <code>900</code> je <code>CM</code>.
<li>Pětkové znaky se nesmí opakovat. <code>10</code> se vždy zapisuje jako <code>X</code> a nikdy jako <code>VV</code>. <code>100</code> je vždy <code>C</code>, nikdy <code>LL</code>.
<li>Římská čísla se čtou zleva doprava, takže na pořadí znaků velmi záleží. <code>DC</code> znamená <code>600</code>, ale <code>CD</code> je úplně jiné číslo (<code>400</code>, „o <code>100</code> méně než <code>500</code>“). <code>CI</code> je <code>101</code>, ale <code>IC</code> není dokonce vůbec platné římské číslo (protože <code>1</code> nemůžeme přímo odčítat od <code>100</code>; musíme to napsat jako <code>XCIX</code>, „o <code>10</code> méně než <code>100</code> a k tomu o <code>1</code> méně než <code>10</code>“).
</ul>

<p>Takže jeden z užitečných testů bude ověřovat, že by funkce <code>from_roman()</code> měla selhat (fail) v případě, kdy jí předáme řetězec s příliš mnoha opakujícími se římskými číslicemi. Co znamená „příliš mnoho“, závisí na konkrétní číslici.

<pre class='nd pp'><code>class FromRomanBadInput(unittest.TestCase):
    def test_too_many_repeated_numerals(self):
        '''from_roman should fail with too many repeated numerals'''
        for s in ('MMMM', 'DD', 'CCCC', 'LL', 'XXXX', 'VV', 'IIII'):
            self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)</code></pre>

<p>Další užitečný test bude založen na kontrole, že se neopakují některé vzory. Například <code>IX</code> je <code>9</code>, ale <code>IXIX</code> je vždy neplatné.

<pre class='nd pp'><code>    def test_repeated_pairs(self):
        '''from_roman should fail with repeated pairs of numerals'''
        for s in ('CMCM', 'CDCD', 'XCXC', 'XLXL', 'IXIX', 'IVIV'):
            self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)</code></pre>

<p>Třetí test by mohl kontrolovat, zda se číslice objevují ve správném pořadí, od nejvyšších k nejnižším hodnotám. Například <code>CL</code> je <code>150</code>, ale <code>LC</code> je vždy neplatné, protože číslice pro <code>50</code> se nesmí nikdy vyskytovat před číslicí pro <code>100</code>. Tento test zahrnuje náhodně zvolenou množinu nesprávných předchůdců: <code>I</code> před <code>M</code>, <code>V</code> před <code>X</code> a tak dále.

<pre class='nd pp'><code>    def test_malformed_antecedents(self):
        '''from_roman should fail with malformed antecedents'''
        for s in ('IIMXCC', 'VX', 'DCM', 'CMM', 'IXIV',
                  'MCMC', 'XCX', 'IVI', 'LM', 'LD', 'LC'):
            self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)</code></pre>

<p>Každý z těchto testů spoléhá na to, že funkce <code>from_roman()</code> vyvolává novou výjimku <code>InvalidRomanNumeralError</code>, kterou jsme ještě nedefinovali.

<pre class='nd pp'><code># roman6.py
class InvalidRomanNumeralError(ValueError): pass</code></pre>

<p>Všechny tři testy by měly selhat (fail), protože funkce <code>from_roman()</code> momentálně neprovádí žádnou kontrolu platnosti. (Pokud by neselhaly teď, tak co by vlastně testovaly?)

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest6.py</kbd>
<samp>FFF.......
======================================================================
FAIL: test_malformed_antecedents (__main__.FromRomanBadInput)
from_roman should fail with malformed antecedents
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest6.py", line 113, in test_malformed_antecedents
    self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)
AssertionError: InvalidRomanNumeralError not raised by from_roman

======================================================================
FAIL: test_repeated_pairs (__main__.FromRomanBadInput)
from_roman should fail with repeated pairs of numerals
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest6.py", line 107, in test_repeated_pairs
    self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)
AssertionError: InvalidRomanNumeralError not raised by from_roman

======================================================================
FAIL: test_too_many_repeated_numerals (__main__.FromRomanBadInput)
from_roman should fail with too many repeated numerals
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest6.py", line 102, in test_too_many_repeated_numerals
    self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)
AssertionError: InvalidRomanNumeralError not raised by from_roman

----------------------------------------------------------------------
Ran 10 tests in 0.058s

FAILED (failures=3)</samp></pre>

<p>Fajn. Teď už do funkce <code>from_roman()</code> potřebujeme přidat jen <a href=#regular-expressions-romannumerals>regulární výraz, který testuje platnost římských čísel</a>.

<pre class='nd pp'><code>roman_numeral_pattern = re.compile('''
    ^                   # začátek řetězce
    M{0,3}              # tisíce - 0 až 3 M
    (CM|CD|D?C{0,3})    # stovky - 900 (CM), 400 (CD), 0-300 (0 až 3 C),
                        #        nebo 500-800 (D následované 0 až 3 C)
    (XC|XL|L?X{0,3})    # desítky - 90 (XC), 40 (XL), 0-30 (0 až 3 X),
                        #        nebo 50-80 (L následované 0 až 3 X)
    (IX|IV|V?I{0,3})    # jednotky - 9 (IX), 4 (IV), 0-3 (0 až 3 I),
                        #        nebo 5-8 (V následované 0 až 3 I)
    $                   # konec řetězce
    ''', re.VERBOSE)

def from_roman(s):
    '''convert Roman numeral to integer'''
<mark>    if not roman_numeral_pattern.search(s):
        raise InvalidRomanNumeralError('Invalid Roman numeral: {0}'.format(s))</mark>

    result = 0
    index = 0
    for numeral, integer in roman_numeral_map:
        while s[index : index + len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result</code></pre>

<p>A znovu spustíme testy&hellip;

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest7.py</kbd>
<samp>..........
----------------------------------------------------------------------
Ran 10 tests in 0.066s

OK</samp></pre>

<p>A cenu za zklamání roku dostává&hellip; slovo „<code>OK</code>“, které modul <code>unittest</code> zobrazí poté, co všechny testy prošly.

</div>
<div id=chapter-refactoring>
<h1>Refaktorizace</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> After one has played a vast quantity of notes and more notes, it is simplicity that emerges as the crowning reward of art. <span class="u">&#x275E;</span><br>(Poté, co jste zahráli ohromné množství not a ještě více not, se jako vrcholná odměna umění objeví jednoduchost.)<br>&mdash; <a href="http://en.wikiquote.org/wiki/Fr%C3%A9d%C3%A9ric_Chopin">Frédéric Chopin</a>
</blockquote>
<p>&nbsp;
<h2 id=refactoring-divingin>Ponořme se</h2>
<p class=f>K chybám dochází, ať se vám to líbí nebo ne. Chyby se objeví navzdory vašemu nejlepšímu úsilí o vytvoření všezahrnujících <a href=#chapter-unit-testing>testů jednotek</a> (unit test). Co vlastně myslím slovem „chyba“? Chybou rozumím testovací případ (test case), který jste ještě nenapsali.

<pre class=screen><samp class=p>>>> </samp><kbd class=pp>import roman7</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>roman7.from_roman('')</kbd> <span class=u>&#x2460;</span></a>
<samp class=pp>0</samp></pre>
<ol>
<li>Tohle je chyba. Prázdný řetězec by měl vyvolat výjimku <code>InvalidRomanNumeralError</code> stejně jako jiné posloupnosti znaků, které nevyjadřují platné římské číslo.
</ol>

<p>Jakmile chybu umíte navodit, měli byste napsat testovací případ (test case) ještě dříve, než ji opravíte. Tím chybu popíšete.

<pre class=pp><code>class FromRomanBadInput(unittest.TestCase):
    .
    .
    .
    def testBlank(self):
        '''from_roman should fail with blank string'''
<a>        self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, '') <span class=u>&#x2460;</span></a></code></pre>
<ol>
<li>Je to docela jednoduché. Voláme funkci <code>from_roman()</code> s prázdným řetězcem a ujišťujeme se, že vyvolává výjimku <code>InvalidRomanNumeralError</code>. Nalezení chyby je obtížnou částí úkolu. Pokud už o ní víme, představuje její otestování snadnou část úkolu.
</ol>

<p>Protože náš kód obsahuje chybu a protože už máme k dispozici testovací případ, který ji popisuje, dojde k jeho selhání:
<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest8.py -v</kbd>
<samp>from_roman should fail with blank string ... FAIL
from_roman should fail with malformed antecedents ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
from_roman should give known result with known input ... ok
to_roman should give known result with known input ... ok
from_roman(to_roman(n))==n for all n ... ok
to_roman should fail with negative input ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

======================================================================
FAIL: from_roman should fail with blank string
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest8.py", line 117, in test_blank
    self.assertRaises(roman8.InvalidRomanNumeralError, roman8.from_roman, '')
<mark>AssertionError: InvalidRomanNumeralError not raised by from_roman</mark>

----------------------------------------------------------------------
Ran 11 tests in 0.171s

FAILED (failures=1)</samp></pre>

<p><em>Teď</em> už chybu můžeme opravit.

<pre class=pp><code>def from_roman(s):
    '''convert Roman numeral to integer'''
<a>    if not s:                                                                  <span class=u>&#x2460;</span></a>
        raise InvalidRomanNumeralError('Input can not be blank')
    if not re.search(romanNumeralPattern, s):
<a>        raise InvalidRomanNumeralError('Invalid Roman numeral: {}'.format(s))  <span class=u>&#x2461;</span></a>

    result = 0
    index = 0
    for numeral, integer in romanNumeralMap:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result</code></pre>
<ol>
<li>Musíme přidat jen dva řádky kódu: explicitní kontrolu na prázdný řetězec a příkaz <code>raise</code>.
<li>Myslím, že o tomhle jsem se v této knize zatím ještě nezmínil. Nechť to slouží jako závěrečná lekce <a href=#strings-formatting-strings>z formátování řetězců</a>. Počínaje verzí Python 3.1 můžete při specifikaci formátu vynechat čísla pozičních indexů. To znamená, že místo specifikátoru <code>{0}</code>, kterým se odkazujeme na první parametr metody <code>format()</code>, můžeme jednoduše použít <code>{}</code> a Python doplní správný poziční index za nás. Funguje to pro libovolný počet argumentů. První <code>{}</code> se chápe jako <code>{0}</code>, druhý výskyt <code>{}</code> znamená <code>{1}</code> a tak dále.
</ol>

<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest8.py -v</kbd>
<a><samp>from_roman should fail with blank string ... ok</samp>  <span class=u>&#x2460;</span></a>
<samp>from_roman should fail with malformed antecedents ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
from_roman should give known result with known input ... ok
to_roman should give known result with known input ... ok
from_roman(to_roman(n))==n for all n ... ok
to_roman should fail with negative input ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 11 tests in 0.156s
</samp>
<a><samp>OK</samp>  <span class=u>&#x2461;</span></a></pre>
<ol>
<li>Testovací případ pro prázdný řetězec prošel, takže chyba je opravena.
<li>Všechny ostatní testovací případy prošly také. To znamená, že jsme opravou chyby nic jiného nepokazili. Přestaňte psát kód.
</ol>

<p>Tento přístup k programování opravu chyb nijak neusnadňuje. Jednoduché chyby (jako je tato) vyžadují jednodušší testovací případy, složité chyby povedou k složitým testovacím případům. V prostředí soustředěném kolem testů se může <em>zdát</em>, že oprava chyby trvá déle. Musíme chybu přesně popsat v kódu (tj. musíme napsat testovací případ) a teprve potom ji opravit. Pokud testovací případ hned neprojde, musíme zjistit, zda jsme udělali chybu v opravě, nebo zda je chyba v kódu testovacího případu. Ale z dlouhodobého hlediska se střídavá tvorba testovacího a testovaného kódu vyplatí, protože se tím zvyšuje pravděpodobnost správné opravy chyb napoprvé. S vaším novým testem se také snadno opakovaně spouštějí <em>všechny</em> testy. Proto je málo pravděpodobné, že opravou nového kódu pokazíte původní kód. Dnešní test jednotky (unit test) je zítřejším regresním testem.

<p class=a>&#x2042;

<h2 id=refactoring-changing-requirements>Zvládání měnících se požadavků</h2>
<p>Navzdory vašemu nejlepšímu úsilí o připíchnutí zákazníka k zemi, poté co z něj při bolestivé proceduře zahrnující hrůzné odpornosti (jako jsou nůžky a horký vosk) vytáhnete přesné požadavky... ty požadavky se změní. Většina zákazníků neví, co chce, dokud to neuvidí. A dokonce když už to vidí, nejsou dost dobří na to, aby vyjádřili, co chtějí, tak přesně, aby to k něčemu bylo. A dokonce i když se vyjádří přesně, v příští verzi toho stejně budou chtít víc. Takže v souvislosti s měnícími se požadavky buďte připraveni na úpravy svých testovacích případů (test case).

<p>Dejme tomu, že bychom například chtěli rozšířit rozsah funkce pro převod římských čísel. V římských číslech se žádný znak nemůže opakovat víc než třikrát. Ale Římané byli ochotni připustit výjimku z tohoto pravidla a reprezentovat hodnotu <code>4000</code> uvedením čtyř <code>M</code> za sebou. Pokud takovou změnu provedeme, budeme schopni rozšířit rozsah převáděných čísel z <code>1..3999</code> na <code>1..4999</code>. Ale nejdříve provedeme úpravy testovacích případů.

<p class=d>[<a href="examples/roman8.py">stáhnout <code>roman8.py</code></a>]
<pre class=pp><code>class KnownValues(unittest.TestCase):
    known_values = ( (1, 'I'),
                      .
                      .
                      .
                     (3999, 'MMMCMXCIX'),
<a>                     (4000, 'MMMM'),                                      <span class=u>&#x2460;</span></a>
                     (4500, 'MMMMD'),
                     (4888, 'MMMMDCCCLXXXVIII'),
                     (4999, 'MMMMCMXCIX') )

class ToRomanBadInput(unittest.TestCase):
    def test_too_large(self):
        '''to_roman should fail with large input'''
<a>        self.assertRaises(roman8.OutOfRangeError, roman8.to_roman, 5000)  <span class=u>&#x2461;</span></a>

    .
    .
    .

class FromRomanBadInput(unittest.TestCase):
    def test_too_many_repeated_numerals(self):
        '''from_roman should fail with too many repeated numerals'''
<a>        for s in ('MMMMM', 'DD', 'CCCC', 'LL', 'XXXX', 'VV', 'IIII'):     <span class=u>&#x2462;</span></a>
            self.assertRaises(roman8.InvalidRomanNumeralError, roman8.from_roman, s)

    .
    .
    .

class RoundtripCheck(unittest.TestCase):
    def test_roundtrip(self):
        '''from_roman(to_roman(n))==n for all n'''
<a>        for integer in range(1, 5000):                                    <span class=u>&#x2463;</span></a>
            numeral = roman8.to_roman(integer)
            result = roman8.from_roman(numeral)
            self.assertEqual(integer, result)</code></pre>
<ol>
<li>Stávající známé hodnoty se nemění (pořád jde o rozumné testovací hodnoty), ale potřebujeme přidat pár dalších v rozsahu od <code>4000</code>. Přidali jsme <code>4000</code> (nejkratší), <code>4500</code> (druhé nejkratší), <code>4888</code> (nejdelší) a <code>4999</code> (největší).
<li>Změnila se definice „velké vstupní hodnoty“. U tohoto testu se při volání <code>to_roman()</code> s hodnotou <code>4000</code> očekávala chyba. Teď se ale rozsah <code>4000&ndash;4999</code> považuje za správné hodnoty, proto musíme hranici zvýšit na <code>5000</code>.
<li>Změnila se také definice „příliš mnoho opakujících se znaků“. U tohoto testu se při volání t<code>from_roman()</code> se vstupem <code>'MMMM'</code> očekávala chyba. Teď je <code>MMMM</code> považováno za platné římské číslo. Testovací hodnotu musíme zvětšit na <code>'MMMMM'</code>.
<li>Test funkčnosti procházel v cyklu každým číslem z intervalu <code>1</code> až <code>3999</code>. Rozsah se teď rozšířil, takže cyklus <code>for</code> musíme upravit, aby se dostal až k <code>4999</code>.
</ol>

<p>Teď máme testovací případy upraveny ve shodě s novými požadavky, ale kód zatím ne. Takže se dá čekat, že některé z testů selžou.

<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest9.py -v</kbd>
<samp>from_roman should fail with blank string ... ok
from_roman should fail with malformed antecedents ... ok
from_roman should fail with non-string input ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
<a>from_roman should give known result with known input ... ERROR          <span class=u>&#x2460;</span></a>
<a>to_roman should give known result with known input ... ERROR            <span class=u>&#x2461;</span></a>
<a>from_roman(to_roman(n))==n for all n ... ERROR                          <span class=u>&#x2462;</span></a>
to_roman should fail with negative input ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

======================================================================
ERROR: from_roman should give known result with known input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest9.py", line 82, in test_from_roman_known_values
    result = roman9.from_roman(numeral)
  File "C:\home\diveintopython3\examples\roman9.py", line 60, in from_roman
    raise InvalidRomanNumeralError('Invalid Roman numeral: {0}'.format(s))
<mark>roman9.InvalidRomanNumeralError: Invalid Roman numeral: MMMM</mark>

======================================================================
ERROR: to_roman should give known result with known input
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest9.py", line 76, in test_to_roman_known_values
    result = roman9.to_roman(integer)
  File "C:\home\diveintopython3\examples\roman9.py", line 42, in to_roman
    raise OutOfRangeError('number out of range (must be 0..3999)')
<mark>roman9.OutOfRangeError: number out of range (must be 0..3999)</mark>

======================================================================
ERROR: from_roman(to_roman(n))==n for all n
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest9.py", line 131, in testSanity
    numeral = roman9.to_roman(integer)
  File "C:\home\diveintopython3\examples\roman9.py", line 42, in to_roman
    raise OutOfRangeError('number out of range (must be 0..3999)')
<mark>roman9.OutOfRangeError: number out of range (must be 0..3999)</mark>

----------------------------------------------------------------------
Ran 12 tests in 0.171s

FAILED (errors=3)</samp></pre>
<ol>
<li>Test známých hodnot pro <code>from_roman()</code> selže v okamžiku, kdy se dostane k hodnotě <code>'MMMM'</code>. Funkce <code>from_roman()</code> si totiž pořád myslí, že jde o neplatné římské číslo.
<li>Test známých hodnot pro <code>to_roman()</code> selže v okamžiku, kdy se narazí na hodnotu <code>4000</code>, protože <code>to_roman()</code> ji stále považuje za hodnotu mimo rozsah.
<li>Kruhový test selže rovněž u hodnoty <code>4000</code>, protože <code>to_roman()</code> ji považuje za hodnotu mimo rozsah.
</ol>

<p>Máme tedy testovací případy, které selhávají v důsledku nových požadavků, a můžeme uvažovat o opravení kódu do odpovídajícího stavu. (Když s psaním testů jednotek (unit test) začínáte, můžete mít divný pocit, že testovaný kód nikdy „nepředbíhá“ testovací případy. Dokud je pozadu, máme pořád nějakou práci před sebou. Jakmile doběhne testovací případy, přestaneme jej upravovat. Jakmile si na to jednou zvyknete, budete se divit, jak jste vůbec dříve mohli programovat bez testů.)

<p class=d>[<a href="examples/roman9.py">stáhnout <code>roman9.py</code></a>]
<pre class=pp><code>roman_numeral_pattern = re.compile('''
    ^                   # začátek řetězce
<a>    M{0,4}              # tisíce - 0 až 4 M       <span class="u">①</span></a>
    (CM|CD|D?C{0,3})    # stovky - 900 (CM), 400 (CD), 0-300 (0 až 3 C),
                        #        nebo 500-800 (D následované 0 až 3 C)
    (XC|XL|L?X{0,3})    # desítky - 90 (XC), 40 (XL), 0-30 (0 až 3 X),
                        #        nebo 50-80 (L následované 0 až 3 X)
    (IX|IV|V?I{0,3})    # jednotky - 9 (IX), 4 (IV), 0-3 (0 až 3 I),
                        #        nebo 5-8 (V následované 0 až 3 I)
    $                   # konec řetězce
    ''', re.VERBOSE)

def to_roman(n):
    '''convert integer to Roman numeral'''
    if not isinstance(n, int):
        raise NotIntegerError('non-integers can not be converted')
<a>    if not (0 &lt; n &lt; 5000):                        <span class=u>&#x2461;</span></a>
        raise OutOfRangeError('number out of range (must be 1..4999)')

    result = ''
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result

def from_roman(s):
    .
    .
    .</code></pre>
<ol>
<li>Funkci <code>from_roman()</code> nemusíme vůbec upravovat. Změna se týká jen vzorku <var>roman_numeral_pattern</var>. Při podrobnějším pohledu zjistíte, že jsem v první části regulárního výrazu změnil maximální počet nepovinných znaků <code>M</code> z <code>3</code> na <code>4</code>. Tím povolíme čísla odpovídající hodnotě až <code>4999</code> místo původní <code>3999</code>. Samotná funkce <code>from_roman()</code> je zcela obecná. Zkrátka jen hledá opakující se znaky římského čísla a sčítá odpovídající hodnoty. Nestará se o to, kolikrát se opakují. Dříve nezvládala <code>'MMMM'</code> pouze z toho důvodu, že jsme ji explicitně zastavili na základě porovnání s regulárním výrazem.
<li>Funkce <code>to_roman()</code> si vyžádá jen jednu malou změnu v místě kontroly rozsahu. Kde jsme dříve testovali <code>0 &lt; n &lt; 4000</code>, budeme teď kontrolovat <code>0 &lt; n &lt; 5000</code>. A hlášení o chybě vyvolávané příkazem <code>raise</code> změníme tak, aby odpovídalo novému povolenému rozsahu (<code>1..4999</code> místo <code>1..3999</code>). Zbytek funkce nemusíme měnit. Nové případy zvládá. (Vesele přidává <code>'M'</code> pro každou nalezenou tisícovku. Když dostane <code>4000</code> vychrlí <code>'MMMM'</code>. Dříve tento případ nezvládala jen proto, že jsme ji explicitně zastavili při kontrole rozsahu.)
</ol>

<p>Možná pochybujete o tom, že by tyhle dvě malé změny vyřešily vše, co potřebujeme. Nemusíte mi to věřit. Zkontrolujte si to sami.

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest9.py -v</kbd>
<samp>from_roman should fail with blank string ... ok
from_roman should fail with malformed antecedents ... ok
from_roman should fail with non-string input ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
from_roman should give known result with known input ... ok
to_roman should give known result with known input ... ok
from_roman(to_roman(n))==n for all n ... ok
to_roman should fail with negative input ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 12 tests in 0.203s

<a>OK  <span class=u>&#x2460;</span></a></samp></pre>
<ol>
<li>Všechny testovací případy prošly. Přestaňte psát kód.
</ol>

<p>Při používání obsáhlých testů jednotek nemusíte spoléhat na programátora, který říká: „Věř mi.“

<p class=a>&#x2042;

<h2 id=refactoring-refactoring>Refaktorizace</h2>

<p>Na komplexním používání testů jednotek (unit testing) není nejlepší to, jak se cítíte, když všechny testovací případy nakonec projdou, dokonce ani to, jak se cítíte, když vás někdo nařkne, že jste mu pokazili jeho kód, a vy ve skutečnosti můžete <em>dokázat</em>, že tomu tak není. Na testech jednotek je nejlepší věcí to, že vám dává volnost nemilosrdně refaktorizovat.

<p>Refaktorizace je činností, kdy vezmete fungující kód a uděláte z něj ještě lepší. „Lepší“ obvykle znamená „rychlejší“, ale může to taky znamenat „používající méně paměti“ nebo „používající menší diskový prostor“ nebo je prostě „elegantnější“. Refaktorizace je z hlediska dlouhodobého zdraví každého programu důležitá, ať už to znamená cokoliv pro vás, pro váš projekt nebo pro vaše okolí.

<p>V případě našeho kódu bude „lepší“ znamenat jak „rychlejší“, tak „snadněji udržovatelný“. Konkrétně funkce <code>from_roman()</code> je pomalejší a složitější, než by se mi líbilo. Je to dáno oním velkým, hnusným regulárním výrazem, který se používá pro ověřování, zda jde o římské číslo. Teď si možná pomyslíte: „No jo. Ten regulární výraz sice je velký a střapatý, ale jak jinak by se dalo ověřit, zda je libovolný řetězec platným římským číslem?“

<p>Odpověď zní: Těch čísel je jen 5000. Proč bychom pro ně prostě nemohli vytvořit vyhledávací tabulku? Ta myšlenka se vám bude líbit ještě víc, když zjistíte, že <em>vůbec nebudeme potřebovat regulární výrazy</em>. Při budování vyhledávací tabulky pro převod čísel na římská čísla můžeme současně vytvářet opačnou vyhledávací tabulku pro konverzi římských čísel na celá čísla. Při testu, zda je libovolný řetězec platným římským číslem, budeme mít k dispozici všechna platná římská čísla. „Ověření platnosti“ se redukuje na jedno vyhledání ve slovníku.

<p>A ze všeho nejlepší je, že už máme k dispozici úplnou sadu testů jednotek (unit test). V modulu můžeme vyměnit klidně polovinu kódu, ale testy jednotek zůstanou stejné. To znamená, že můžete dokázat&nbsp;&mdash;&nbsp;sami sobě a ostatním&nbsp;&mdash;,&nbsp;že nový kód funguje stejně dobře jako ten původní.

<p class=d>[<a href="examples/roman10.py">stáhnout <code>roman10.py</code></a>]
<pre class=pp><code>class OutOfRangeError(ValueError): pass
class NotIntegerError(ValueError): pass
class InvalidRomanNumeralError(ValueError): pass

roman_numeral_map = (('M',  1000),
                     ('CM', 900),
                     ('D',  500),
                     ('CD', 400),
                     ('C',  100),
                     ('XC', 90),
                     ('L',  50),
                     ('XL', 40),
                     ('X',  10),
                     ('IX', 9),
                     ('V',  5),
                     ('IV', 4),
                     ('I',  1))

to_roman_table = [ None ]
from_roman_table = {}

def to_roman(n):
    '''convert integer to Roman numeral'''
    if not (0 &lt; n &lt; 5000):
        raise OutOfRangeError('number out of range (must be 1..4999)')
    if int(n) != n:
        raise NotIntegerError('non-integers can not be converted')
    return to_roman_table[n]

def from_roman(s):
    '''convert Roman numeral to integer'''
    if not isinstance(s, str):
        raise InvalidRomanNumeralError('Input must be a string')
    if not s:
        raise InvalidRomanNumeralError('Input can not be blank')
    if s not in from_roman_table:
        raise InvalidRomanNumeralError('Invalid Roman numeral: {0}'.format(s))
    return from_roman_table[s]

def build_lookup_tables():
    def to_roman(n):
        result = ''
        for numeral, integer in roman_numeral_map:
            if n >= integer:
                result = numeral
                n -= integer
                break
        if n > 0:
            result += to_roman_table[n]
        return result

    for integer in range(1, 5000):
        roman_numeral = to_roman(integer)
        to_roman_table.append(roman_numeral)
        from_roman_table[roman_numeral] = integer

build_lookup_tables()</code></pre>

<p>Rozdělme si to na stravitelné kousky. Prokazatelně nejdůležitějším řádkem je ten poslední:

<pre class='nd pp'><code>build_lookup_tables()</code></pre>

<p>Jistě si všimnete, že jde o volání funkce. Ale není tu žádný obalující příkaz <code>if</code>. Tady nejde o blok uvnitř <code>if __name__ == '__main__'</code>. Funkce se zavolá <em>v okamžiku importu modulu</em>. (Zde je důležité vědět, že se moduly importují jen jednou a poté se pamatují ve vyrovnávací paměti (cache). Pokud importujeme už jednou importovaný modul, nic se neděje. Takže uvedený kód bude zavolán jen při prvním importu tohoto modulu.)

<p>Co vlastně funkce <code>build_lookup_tables()</code> dělá? To jsem rád, že se ptáte.

<pre class=pp><code>to_roman_table = [ None ]
from_roman_table = {}
.
.
.
def build_lookup_tables():
<a>    def to_roman(n):                                <span class=u>&#x2460;</span></a>
        result = ''
        for numeral, integer in roman_numeral_map:
            if n >= integer:
                result = numeral
                n -= integer
                break
        if n > 0:
            result += to_roman_table[n]
        return result

    for integer in range(1, 5000):
<a>        roman_numeral = to_roman(integer)          <span class=u>&#x2461;</span></a>
<a>        to_roman_table.append(roman_numeral)       <span class=u>&#x2462;</span></a>
        from_roman_table[roman_numeral] = integer</code></pre>
<ol>
<li>Tohle je takový chytrý programátorský obrat... možná až příliš chytrý. Funkce <code>to_roman()</code> je definována výše. Vyhledává hodnoty ve vyhledávací tabulce a vrací je. Ale funkce <code>build_lookup_tables()</code> si pro realizaci převodu vytváří svou vlastní definici funkce <code>to_roman()</code> (stejnou, jaká se používala v předchozích případech, než jsme přidali vyhledávací tabulku). Uvnitř funkce <code>build_lookup_tables()</code> se bude volat ta redefinovaná verze funkce <code>to_roman()</code>. Jakmile funkce <code>build_lookup_tables()</code> skončí, redefinovaná verze zmizí. Její definice je platná jen lokálně, uvnitř funkce <code>build_lookup_tables()</code>.
<li>Na tomto řádku kódu se volá redefinovaná funkce <code>to_roman()</code>, která ve skutečnosti vytváří římské číslo.
<li>Jakmile máme k dispozici výsledek (redefinované funkce <code>to_roman()</code>), přidáme číslo a jemu odpovídající římské číslo do obou vyhledávacích tabulek.
</ol>

<p>Jakmile jsou vyhledávací tabulky naplněny, je zbývající kód jednoduchý a rychlý.

<pre class=pp><code>def to_roman(n):
    '''convert integer to Roman numeral'''
    if not (0 &lt; n &lt; 5000):
        raise OutOfRangeError('number out of range (must be 1..4999)')
    if int(n) != n:
        raise NotIntegerError('non-integers can not be converted')
<a>    return to_roman_table[n]                                            <span class=u>&#x2460;</span></a>

def from_roman(s):
    '''convert Roman numeral to integer'''
    if not isinstance(s, str):
        raise InvalidRomanNumeralError('Input must be a string')
    if not s:
        raise InvalidRomanNumeralError('Input can not be blank')
    if s not in from_roman_table:
        raise InvalidRomanNumeralError('Invalid Roman numeral: {0}'.format(s))
<a>    return from_roman_table[s]                                          <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>Funkce <code>to_roman()</code> provede stejné kontroly hraničních případů (jako dříve) a potom jednoduše najde odpovídající hodnotu ve vyhledávací tabulce a vrátí ji.
<li>Také funkce <code>from_roman()</code> je redukována na kontroly a jeden řádek kódu. Už žádné regulární výrazy. Už žádné cykly. Převod na a z římského čísla se složitostí O(1) &mdash; tj. v konstantním čase.
</ol>

<p>Ale funguje to? Proč se ptáte? Jasně že funguje. A můžu to dokázat.

<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest10.py -v</kbd>
<samp>from_roman should fail with blank string ... ok
from_roman should fail with malformed antecedents ... ok
from_roman should fail with non-string input ... ok
from_roman should fail with repeated pairs of numerals ... ok
from_roman should fail with too many repeated numerals ... ok
from_roman should give known result with known input ... ok
to_roman should give known result with known input ... ok
from_roman(to_roman(n))==n for all n ... ok
to_roman should fail with negative input ... ok
to_roman should fail with non-integer input ... ok
to_roman should fail with large input ... ok
to_roman should fail with 0 input ... ok

----------------------------------------------------------------------
<a>Ran 12 tests in 0.031s                                                  <span class=u>&#x2460;</span></a>

OK</samp></pre>
<ol>
<li>Tedy, ne že byste se ptali, ale ono je to taky rychlé! Skoro 10krát rychlejší. Není to, samozřejmě, úplně férové srovnání, protože u této verze trvá déle import (budují se vyhledávací tabulky). Ale protože se import dělá jen jednou, rozpustí se nákladnost při startu mezi volání funkcí <code>to_roman()</code> a <code>from_roman()</code>. A protože se při testech provádí několik tisíc volání funkcí (jen samotný kruhový test jich provede 10 000), úspory se rychle nasčítají!
</ol>

<p>A jak zní ponaučení?

<ul>
<li>V jednoduchosti je síla.
<li>Zvláště tehdy, když jsou do toho zapletené regulární výrazy.
<li>Díky testům jednotek (unit test) získáte sebedůvěru a odvahu k provádění rozsáhlé refaktorizace.
</ul>

<p class=a>&#x2042;

<h2 id=refactoring-summary>Shrnutí</h2>

<p>Unit testing (testování jednotek) představuje mocný koncept, který při správné implementaci vede u dlouhodobých projektů jak k redukci nákladů na údržbu, tak ke zvýšení pružnosti. Současně si ale musíme uvědomit, že testování jednotek není všelék. Napsat dobré testové případy není jednoduchá věc a udržet je v aktuálním stavu vyžaduje disciplínu (zvlášť když zákazníci vřískají, aby byly opraveny kritické chyby). Unit testing není náhradou ostatních forem testování, zahrnujících testování funkčnosti celého systému, integrační testování (tj. test spolupráce jednotek) a uživatelské akceptační testy. Testy jednotek jsou ale přesto rozumné, fungují, a když už je jednou uvidíte v činnosti, budete se divit, jak jste se bez nich mohli obejít.

<p>V pár posledních kapitolách jsme se šířeji zabývali základy, z nichž mnohé dokonce nejsou specifické jen pro Python. Rámce pro testování jednotek (unit testing frameworks) jsou dostupné pro mnoho jazyků a všechny vyžadují, abyste porozuměli týmž konceptům:

<ul>
<li>Návrh testovacích případů (test case), které jsou specifické, automatizované a nezávislé.
<li>Napsání testovacích případů <em>před psaním kódu</em>, který mají testovat.
<li>Psaní testů, které testují správné vstupy a kontrolují očekávané výsledky.
<li>Psaní testů, které testují chybné vstupy a kontrolují očekávané chybové reakce.
<li>Psaní a aktualizace testovacích případů tak, aby odrážely nové požadavky.
<li>Nemilosrdná refaktorizace za účelem zvýšení výkonnosti, škálovatelnosti, čitelnosti, udržovatelnosti a jakýchkoliv jiných -ostí, po kterých toužíte.
</ul>

</div>
<div id=chapter-files>
<h1>Soubory</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> A nine mile walk is no joke, especially in the rain. <span class="u">&#x275E;</span><br>(Jít devět mil není žádná legrace, zvlášť v dešti. [<a href="http://www.youtube.com/watch?v=9qQKYBzLgaM">krátký film</a>])<br>&mdash; Harry Kemelman, <cite>The Nine Mile Walk</cite>
</blockquote>
<p>&nbsp;
<h2 id=files-divingin>Ponořme se</h2>
<p class=f>Než jsem začal instalovat první aplikaci, obsahovaly Windows na mém laptopu 38 493 souborů. Po instalaci Pythonu 3 k nim přibylo téměř 3000 dalších. Každý významnější operační systém považuje soubory za základ ukládání dat. Koncepce souborů je tak zakořeněná, že by <a href="http://en.wikipedia.org/wiki/Computer_file#History">představa jiné možnosti</a> dělala většině lidí problémy. Obrazně řečeno, váš počítač se topí v souborech.

<h2 id=files-reading>Čtení z textových souborů</h2>

<p>Než můžeme ze souboru číst, musíme jej otevřít. Otvírání souborů v Pythonu už nemohlo být jednodušší.

<pre class='nd pp'><code>a_file = open('examples/chinese.txt', encoding='utf-8')</code></pre>

<p>V Pythonu najdeme zabudovanou funkci <code>open()</code>, která přebírá jméno souboru jako argument. Jménem souboru je zde <code class="pp">'examples/chinese.txt'</code>. Na uvedeném jméně souboru najdeme pět zajímavostí:

<ol>
<li>Není to pouhé jméno souboru. Je to kombinace adresářové cesty a jména souboru. Hypotetická funkce pro otvírání souboru by mohla požadovat dva argumenty&nbsp;&mdash;&nbsp;adresářovou cestu a jméno souboru. Ale funkce <code>open()</code> požaduje jen jeden. Kdykoliv se po vás v Pythonu požaduje „jméno souboru“, můžete do něj zahrnout také celou adresářovou cestu nebo její část.
<li>Uvedená adresářová cesta používá normální lomítko, ale neupřesnil jsem, jaký operační systém používám. Windows používají pro oddělování podadresářů zpětná lomítka, zatímco Mac OS X a Linux používají obyčejná lomítka. Ale v Pythonu fungují obyčejná lomítka i pod Windows.
<li>Uvedená adresářová cesta nezačíná lomítkem nebo písmenem disku, takže ji nazýváme <i>relativní cesta</i>. Mohli byste se zeptat &mdash; relativní k čemu? Zachovejte klid.
<li>Je to řetězec. Všechny moderní operační systémy (dokonce i Windows!) ukládají jména souborů a adresářů v Unicode. Python 3 plně podporuje jména cest, která nemusí být výhradně v <abbr>ASCII</abbr>.
<li>A nemusí vést jen na váš lokální disk. Můžete mít připojený síťový disk. Daný „soubor“ může být fiktivní součástí <a href="http://cs.wikipedia.org/wiki/Filesystem_in_Userspace">zcela virtuálního souborového systému</a>. Pokud jej váš počítač považuje za soubor a může k němu jako k souboru přistupovat, může jej Python otevřít také.
</ol>

<p>Ale volání funkce <code>open()</code> nekončí zadáním jména souboru. Máme zde další argument nazvaný <code>encoding</code> (kódování). No nazdar. To zní <a href=#strings-boring-stuff>příšerně povědomě</a>.

<h3 id=files-encoding>Kódování znaků vystrkuje svou ošklivou hlavu.</h3>

<p>Bajty jsou bajty, <a href=#strings-byte-arrays>znaky jsou abstrakce</a>. Řetězec je posloupností znaků v Unicode. Ale soubor na disku není posloupností Unicode znaků. Soubor na disku je posloupností bajtů. Takže jak Python převádí posloupnost bajtů na posloupnost znaků, když čteme „textový soubor“ z disku? Dekóduje bajty podle určitého algoritmu pro kódování znaků a vrací posloupnost znaků v Unicode (známou také jako řetězec).

<pre>
# Tento příklad byl vytvořen pod Windows. Z důvodů popsaných
# níže se na ostatních platformách může chovat jinak.
<samp class=p>>>> </samp><kbd class=pp>file = open('examples/chinese.txt')</kbd>
<samp class=p>>>> </samp><kbd class=pp>a_string = file.read()</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "C:\Python31\lib\encodings\cp1252.py", line 23, in decode
    return codecs.charmap_decode(input,self.errors,decoding_table)[0]
UnicodeDecodeError: 'charmap' codec can't decode byte 0x8f in position 28: character maps to &lt;undefined></samp>
<samp class=p>>>> </samp></pre>

<aside>Výchozí kódování je závislé na platformě.</aside>

<p>Co se to vlastně stalo? Neurčili jsme znakové kódování, takže Python byl donucen použít výchozí kódování. Co to je výchozí kódování? Pokud se pořádně podíváme na trasovací výpis, vidíme, že skončil uvnitř <code>cp1252.py</code>. To znamená, že Python použil jako výchozí kódování CP-1252. (CP-1252 je běžné kódování, které se používá na počítačích s Microsoft Windows. To se týká západní Evropy. Čeština a slovenština používají kódování CP-1250.) Znaková sada CP-1252 nepodporuje znaky, které se v souboru nacházejí, takže čtení selhává s nepěknou chybou <code>UnicodeDecodeError</code>.

<p>Ale počkejte. Ono je to ještě horší! Výchozí kódování je <em>závislé na platformě</em>, takže stejný kód by na vašem počítači fungovat <em>mohl</em> (pokud by vaším výchozím kódováním bylo <abbr>UTF-8</abbr>). Ale pokud program přenesete k někomu jinému (kdo používá jiné výchozí kódování, jako třeba CP-1252), dojde k selhání.

<blockquote class=note>
<p><span class="u">&#x261E;</span>Pokud potřebujete zjistit výchozí znakové kódování, importujte modul <code>locale</code> a zavolejte <code>locale.getpreferredencoding()</code>. Na mém laptopu s Windows funkce vrací <code>'cp1252'</code>, ale na mém linuxovém stroji v horním pokoji se vrací <code>'UTF8'</code>. Nejsem schopen udržet shodu dokonce ani ve svém vlastním domě! Ve vašem případě mohou být výsledky jiné (dokonce i pod Windows) v závislosti na verzi operačního systému, který jste nainstalovali, a na konfiguraci regionálních a jazykových nastavení. To je důvod, proč je tak důležité uvádět kódování pokaždé, když otvíráme soubor.

</blockquote>

<h3 id=files-file-objects>Objekty typu stream</h3>

<p>Zatím víme jen to, že Python má zabudovanou funkci zvanou <code>open()</code>. Funkce <code>open()</code> vrací <i>objekt typu stream</i> (čti [strím], proud dat), který poskytuje metody a atributy pro získávání informací o proudu znaků a pro manipulaci s ním.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_file = open('examples/chinese.txt', encoding='utf-8')</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.name</kbd>                                              <span class=u>&#x2460;</span></a>
<samp class=pp>'examples/chinese.txt'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.encoding</kbd>                                          <span class=u>&#x2461;</span></a>
<samp class=pp>'utf-8'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.mode</kbd>                                              <span class=u>&#x2462;</span></a>
<samp class=pp>'r'</samp></pre>
<ol>
<li>Atribut <code>name</code> zachycuje jméno, které jsme při otvírání souboru předali funkci <code>open()</code>. Není upraveno do podoby absolutní cesty.
<li>Podobně atribut <code>encoding</code> zachycuje kódování, které jsme při otvírání souboru předali funkci <code>open()</code>. Pokud byste při otvírání souboru kódování neuvedli (nepořádný vývojář!), pak by atribut <code>encoding</code> odpovídal výsledku <code>locale.getpreferredencoding()</code>.
<li>Z atributu <code>mode</code> poznáme, v jakém režimu byl soubor otevřen. Funkci <code>open()</code> můžeme předat nepovinný parametr <var>mode</var> (režim). Při otvírání tohoto souboru jsme režim neurčili, takže Python použije výchozí hodnotu <code>'r'</code>, která má význam „otevřít jen pro čtení, v textovém režimu“. Jak uvidíme v této kapitole později, plní režim otevření souboru několik účelů. Různé režimy nám umožní do souboru zapisovat, připojovat na konec souboru nebo otvírat soubor v binárním režimu (ve kterém místo s řetězci pracujeme s bajty).
</ol>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Seznam všech možných režimů najdete <a href="http://docs.python.org/3.1/library/io.html#module-interface">v dokumentaci pro funkci <code>open()</code></a>.
</blockquote>

<h3 id=files-read>Čtení dat z textového souboru</h3>

<p>Po otevření souboru pro čtení z něj pravděpodobně v určitém místě budete chtít číst.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_file = open('examples/chinese.txt', encoding='utf-8')</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.read()</kbd>                                            <span class=u>&#x2460;</span></a>
<samp class=pp>'Dive Into Python 是为有经验的程序员编写的一本 Python 书。\n'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.read()</kbd>                                            <span class=u>&#x2461;</span></a>
<samp class=pp>''</samp></pre>
<ol>
<li>Jakmile soubor otevřeme (při zadání správného kódování), spočívá čtení z něj v prostém volání metody <code>read()</code> objektu typu stream. Výsledkem je řetězec.
<li>Trochu překvapující je možná to, že další čtení ze souboru nevyvolá výjimku. Python nepovažuje čtení za koncem souboru za chybu. Vrátí se jednoduše prázdný řetězec.
</ol>

<aside>Při otvírání souboru vždy uvádějte parametr <code>encoding</code>.</aside>

<p>A co kdybychom chtěli soubor číst znovu?

<pre class=screen>
# pokračování předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>a_file.read()</kbd>                      <span class=u>&#x2460;</span></a>
<samp class=pp>''</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.seek(0)</kbd>                     <span class=u>&#x2461;</span></a>
<samp class=pp>0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.read(16)</kbd>                    <span class=u>&#x2462;</span></a>
<samp class=pp>'Dive Into Python'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.read(1)</kbd>                     <span class=u>&#x2463;</span></a>
<samp class=pp>' '</samp>
<samp class=p>>>> </samp><kbd class=pp>a_file.read(1)</kbd>
<samp class=pp>'是'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.tell()</kbd>                      <span class=u>&#x2464;</span></a>
<samp class=pp>20</samp></pre>
<ol>
<li>Protože jsme ještě pořád na konci souboru, další volání metody <code>read()</code> vrací prázdný řetězec.
<li>Metoda <code>seek()</code> zajistí přesun v souboru na určenou bajtovou pozici.
<li>Metodě <code>read()</code> můžeme zadat nepovinný parametr, který určuje počet znaků, které se mají načíst.
<li>Pokud budeme chtít, můžeme číst klidně i po jednom znaku.
<li>16 + 1 + 1 = &hellip; 20?
</ol>

<p>Zkusme to znovu.

<pre class=screen>
# pokračování předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>a_file.seek(17)</kbd>                    <span class=u>&#x2460;</span></a>
<samp class=pp>17</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.read(1)</kbd>                     <span class=u>&#x2461;</span></a>
<samp class=pp>'是'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.tell()</kbd>                      <span class=u>&#x2462;</span></a>
<samp class=pp>20</samp></pre>
<ol>
<li>Přesuneme se na 17. bajt.
<li>Přečteme jeden znak.
<li>A najednou jsme na 20. bajtu.
</ol>

<p>Už jste na to přišli? Metody <code>seek()</code> a <code>tell()</code> počítají vždy po <em>bajtech</em>, ale protože jsme soubor otevřeli v textovém režimu, čte metoda <code>read()</code> po <em>znacích</em>. Pro zakódování čínských znaků <a href=#strings-boring-stuff>v <abbr>UTF-8</abbr> potřebujeme více bajtů</a>. Pro každý anglický znak potřebujeme v souboru jen jeden bajt, takže by vás to mohlo svést k mylnému závěru, že metody <code>seek()</code> a <code>read()</code> počítají stejné jednotky. To ale platí jen pro některé znaky.

<p>Ale moment, začíná to být ještě horší!

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.seek(18)</kbd>                         <span class=u>&#x2460;</span></a>
<samp class=pp>18</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.read(1)</kbd>                          <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;pyshell#12>", line 1, in &lt;module>
    a_file.read(1)
  File "C:\Python31\lib\codecs.py", line 300, in decode
    (result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: 'utf8' codec can't decode byte 0x98 in position 0: unexpected code byte</samp></pre>
<ol>
<li>Přesuneme se na 18. bajt a zkusíme přečíst jeden znak.
<li>Proč to selhalo? Protože na 18. bajtu není znak. Nejbližší znak začíná na 17. bajtu (a zabírá tři bajty). Pokus o čtení znaku od středu jeho kódované posloupnosti vede k chybě <code>UnicodeDecodeError</code>.
</ol>

<h3 id=files-close>Zavírání souborů</h3>

<p>Otevřené soubory zabírají systémové prostředky a v závislosti na režimu otevření souboru k nim některé programy nemusí být schopny přistupovat. Proto je důležité, abychom soubory zavírali hned poté, co s nimi přestaneme pracovat.

<pre class='nd screen'>
# pokračování předchozího příkladu
<samp class=p>>>> </samp><kbd class=pp>a_file.close()</kbd></pre>

<p>Tak <em>tohle</em> bylo zklamání.

<p>Objekt <var>a_file</var> typu stream pořád existuje. Volání jeho metody <code>close()</code> nevede k jeho zrušení. Ale už není nějak zvlášť užitečný.

<pre class=screen>
# pokračování předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>a_file.read()</kbd>                           <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;pyshell#24>", line 1, in &lt;module>
    a_file.read()
ValueError: I/O operation on closed file.</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.seek(0)</kbd>                          <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;pyshell#25>", line 1, in &lt;module>
    a_file.seek(0)
ValueError: I/O operation on closed file.</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.tell()</kbd>                           <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;pyshell#26>", line 1, in &lt;module>
    a_file.tell()
ValueError: I/O operation on closed file.</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.close()</kbd>                          <span class=u>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.closed</kbd>                           <span class=u>&#x2464;</span></a>
<samp class=pp>True</samp></pre>
<ol>
<li>Ze zavřeného objektu nemůžeme číst. Vyvolá se tím výjimka <code>IOError</code>.
<li>V zavřeném souboru nemůžeme ani přesunovat pozici (seek).
<li>U zavřeného souboru neexistuje žádná aktuální pozice, takže metoda <code>tell()</code> také selže.
<li>Překvapením možná je, že volání metody <code>close()</code> pro objekt typu stream, jehož soubor byl už zavřený, <em>nevyvolá</em> výjimku. Jde o prázdnou operaci.
<li>Zavřený objekt typu stream má přece jen jeden užitečný atribut. Atribut <code>closed</code> potvrzuje, že soubor byl uzavřen.
</ol>

<h3 id=files-with>Automatické zavírání souborů</h3>

<aside>Konstrukce <code>try..finally</code> je dobrá. <code>with</code> je lepší.</aside>

<p>Objekty typu stream mají explicitní metodu <code>close()</code>, ale co se stane, když je ve vašem programu chyba a zhavaruje předtím, než zavoláte <code>close()</code>? Soubor by teoreticky mohl zůstat otevřený mnohem déle, než bychom potřebovali. Pokud zrovna něco ladíte na svém lokálním počítači, není to takový problém. Ale na používaném serveru už možná ano.

<p>Python 2 pro tento případ nabízel řešení v podobě bloku <code>try..finally</code>. V Pythonu 3 tento obrat stále funguje. Proto se s ním můžete setkat v kódu některých programátorů nebo ve starším kódu, který byl <a href=#chapter-case-study-porting-chardet-to-python-3>převeden pro Python 3</a>. Ale Python 2.6 zavedl čistší řešení, které se v Pythonu 3 stalo preferovaným. Jde o příkaz <code>with</code>.

<pre class='nd pp'><code>with open('examples/chinese.txt', encoding='utf-8') as a_file:
    a_file.seek(17)
    a_character = a_file.read(1)
    print(a_character)</code></pre>

<p>V tomto kódu se volá <code>open()</code>, ale nikde se v něm nevolá <code>a_file.close()</code>. Příkaz <code>with</code> zahajuje blok kódu podobně, jako je tomu u příkazu <code>if</code> nebo u cyklu <code>for</code>. Uvnitř bloku kódu můžeme používat proměnnou <var>a_file</var>, kterou objekt typu stream vrátil jako výsledek volání <code>open()</code>. K dispozici máme všechny obvyklé metody objektu typu stream, jako jsou <code>seek()</code>, <code>read()</code> a všechny ostatní. Když blok <code>with</code> skončí, <em>Python automaticky zavolá <code>a_file.close()</code></em>.

<p>Když to shrneme, Python soubor uzavře nezávisle na tom, jak a kdy blok <code>with</code> skončí&hellip; i kdyby „skončil“ v důsledku neošetřené výjimky. Tak to opravdu je. I v případě, kdy kód vyvolá výjimku a celý váš program se skřípěním zastaví, dotčený soubor bude uzavřen. Je to zaručeno.

<blockquote class=note>
<p><span class="u">&#x261E;</span>Z technického pohledu příkaz <code>with</code> vytváří <dfn>operační kontext</dfn> (runtime context). Objekt typu stream je v těchto příkladech využit jako <dfn>správce kontextu</dfn> (context manager). Python vytvoří objekt <var>a_file</var> typu stream a řekne mu, že vstupuje do operačního kontextu. Jakmile blok příkazu <code>with</code> skončí, Python sdělí objektu typu stream, že opouští operační kontext a objekt zavolá svou vlastní metodu <code>close()</code>. Detaily hledejte <a href=#special-method-names-context-managers>v příloze B, „Třídy, které mohou být použity v bloku <code>with</code>“</a>.
</blockquote>

<p>Příkaz <code>with</code> není nijak zvlášť zaměřen na soubory. Je to prostě obecný rámec pro vytvoření operačního kontextu. Objekt se dozví, že vstupuje do operačního kontextu nebo že z něj vystupuje. Pokud je dotčený objekt typu stream, pak provede užitečné „souborové“ věci (jako je například automatické uzavření souboru). Ale toto chování je definováno uvnitř objektu typu stream a ne v příkazu <code>with</code>. Správce kontextu může být použit mnoha jinými způsoby, které nemají se soubory nic společného. Můžete si dokonce vytvořit svého vlastního správce kontextu. Ukážeme si to o něco později, ale ještě v této kapitole.

<h3 id=files-for>Čtení dat po řádcích</h3>

<p>„Řádek“ textového souboru je to, co si myslíte, že by to mělo být&nbsp;&mdash;&nbsp;napíšete pár slov, stisknete <kbd>ENTER</kbd> a najednou jste na novém řádku. Řádek textu je posloupnost znaků oddělená&hellip; čím vlastně? Ono je to komplikované, protože textové soubory mohou pro označení konce řádků použít několik různých znaků. Každý operační systém má svou vlastní konvenci. Některé používají znak návratu vozíku (carriage return), jiné používají znak přechodu na nový řádek (line feed) a některé používají na konci každého řádku oba zmíněné znaky.

<p>Teď si můžete s úlevou oddechnout, protože <em>Python zpracovává konce řádků automaticky</em>. Pokud řeknete „chci přečíst tento textový soubor řádek po řádku“, Python zjistí, který typ konců řádků se v textovém souboru používá, a zařídí, že to prostě bude fungovat.

<blockquote class=note>
<p><span class="u">&#x261E;</span>Pokud potřebujete získat detailní kontrolu nad tím, co se považuje za konec řádku, můžete funkci <code>open()</code> předat nepovinný parametr <code>newline</code>. Detaily najdete <a href="http://docs.python.org/3.1/library/io.html#module-interface">v dokumentaci funkce <code>open()</code></a>.
</blockquote>

<p>Takže jak se to vlastně dělá? Čtěte ze souboru po řádcích. Je to tak jednoduché. V jednoduchosti je krása.

<p class=d>[<a href="examples/oneline.py">stáhnnout <code>oneline.py</code></a>]
<pre class=pp><code>line_number = 0
<a>with open('examples/favorite-people.txt', encoding='utf-8') as a_file:  <span class=u>&#x2460;</span></a>
<a>    for a_line in a_file:                                               <span class=u>&#x2461;</span></a>
        line_number += 1
<a>        print('{:>4} {}'.format(line_number, a_line.rstrip()))          <span class=u>&#x2462;</span></a></code></pre>
<ol>
<li>Použitím <a href=#files-with>vzoru <code>with</code></a> dosáhneme bezpečného otevření souboru a necháme Python, aby ho zavřel za nás.
<li>Pro čtení souboru po řádcích využijeme cyklus <code>for</code>. To je vše. Objekty typu stream podporují metody jako <code>read()</code>, ale kromě toho <em>je objekt typu stream také <a href=#chapter-iterators>iterátorem</a></em>, který vrátí jeden řádek pokaždé, když jej požádáte o další hodnotu.
<li>Číslo řádku a řádek samotný můžeme zobrazit s využitím <a href=#strings-formatting-strings>řetězcové metody <code>format()</code> </a>. Specifikátor formátu <code>{:&gt;4}</code> říká „vytiskni tento argument zarovnaný doprava na šířku čtyř pozic“. Proměnná <var>a_line</var> obsahuje celý řádek, včetně znaků ukončujících řádek. Řetězcová metoda <code>rstrip()</code> odstraní všechny koncové bílé znaky (whitespace) včetně znaků ukončujících řádek.
</ol>

<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3$ </samp><kbd class=pp>python3 examples/oneline.py</kbd>
<samp>   1 Dora
   2 Ethan
   3 Wesley
   4 John
   5 Anne
   6 Mike
   7 Chris
   8 Sarah
   9 Alex
  10 Lizzie</samp></pre>

<blockquote class=pf>
<p>Setkali jste se s následující chybou?
<pre class='nd screen'>
<samp class=p>you@localhost:~/diveintopython3$ </samp><kbd class=pp>python3 examples/oneline.py</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "examples/oneline.py", line 4, in &lt;module>
    print('{:>4} {}'.format(line_number, a_line.rstrip()))
ValueError: zero length field name in format</samp></pre>
<p>Pokud ano, pravděpodobně používáte Python 3.0. Měli byste provést aktualizaci na Python 3.1.
<p>Python 3.0 sice podporuje nový způsob formátování řetězců, ale vyžaduje <a href=#strings-formatting-strings>explicitní formátování specifikátorů formátu</a>. Python 3.1 vám umožní ve specifikátorech formátu indexy argumentů vynechávat. Verze kompatibilní s Pythonem 3.0 je pro porovnání zde:
<pre class='pp nd'><code>print('{<mark>0</mark>:>4} {<mark>1</mark>}'.format(line_number, a_line.rstrip()))</code></pre>
</blockquote>

<p class=a>&#x2042;

<h2 id=files-writing>Zápis do textových souborů</h2>

<aside>Soubor prostě otevřete a začněte zapisovat.</aside>

<p>Do souborů můžeme zapisovat velmi podobným způsobem, jakým z nich čteme. Soubor nejdříve otevřeme a získáme objekt typu stream. Pro zápis do souboru použijeme jeho metody. Nakonec soubor zavřeme.

<p>Při otvírání souboru pro zápis použijeme funkci <code>open()</code> a předepíšeme režim zápisu. U souborů můžeme použít dva režimy zápisu:

<ul>
<li>Režim „write“ (zápis) vede k přepsání obsahu souboru. Funkci <code>open()</code> předáme <code>mode='w'</code>.
<li>Režim „append“ přidává data na konec souboru. Funkci <code>open()</code> předáme <code>mode='a'</code>.
</ul>

<p>Pokud soubor dosud neexistuje, bude při obou uvedených režimech vytvořen automaticky. To znamená, že se nikdy nemusíme piplat s funkčností jako „pokud soubor ještě neexistuje, vytvoř nový, prázdný soubor, abychom jej mohli poprvé otevřít“. Prostě soubor otevřeme a začneme zapisovat.

<p>Jakmile zápis do souboru dokončíme, měli bychom jej vždy zavřít, aby došlo k uvolnění deskriptoru souboru (file handle) a abychom zajistili, že došlo ke skutečnému zápisu dat na disk. Stejně jako v případě čtení dat můžeme soubor zavřít voláním metody <code>close()</code> objektu typu stream nebo můžeme použít příkaz <code>with</code> a předat starost o zavření souboru Pythonu. Vsadím se, že uhodnete, kterou techniku doporučuji.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>with open('test.log', mode='w', encoding='utf-8') as a_file:</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>&hellip; </samp><kbd class=pp>    a_file.write('test succeeded')</kbd>                            <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>with open('test.log', encoding='utf-8') as a_file:</kbd>
<samp class=p>&hellip; </samp><kbd class=pp>    print(a_file.read())</kbd>
<samp class=pp>test succeeded</samp>
<a><samp class=p>>>> </samp><kbd class=pp>with open('test.log', mode='a', encoding='utf-8') as a_file:</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>&hellip; </samp><kbd class=pp>    a_file.write('and again')</kbd>
<samp class=p>>>> </samp><kbd class=pp>with open('test.log', encoding='utf-8') as a_file:</kbd>
<samp class=p>&hellip; </samp><kbd class=pp>    print(a_file.read())</kbd>
<a><samp class=pp>test succeededand again</samp>                                           <span class=u>&#x2463;</span></a></pre>
<ol>
<li>Začali jsme odvážně vytvořením nového souboru <code>test.log</code> (nebo přepsáním existujícího souboru) a jeho otevřením pro zápis. Parametr <code>mode='w'</code> znamená „otevři soubor pro zápis“. Ano, je to opravdu tak nebezpečné, jak to zní. Doufám, že vám na dřívějším obsahu tohoto souboru nezáleželo (pokud existoval), protože jeho obsah právě zmizel.
<li>Do nově otevřeného souboru můžeme data přidávat metodou <code>write()</code> objektu, který vrátila funkce <code>open()</code>. Jakmile blok <code>with</code> skončí, Python soubor automaticky uzavře.
<li>To bylo zábavné. Zkusme to znovu. Ale tentokrát použijeme <code>mode='a'</code>, abychom místo přepsání souboru připojili data na jeho konec. Připsání na konec (append) <em>nikdy</em> nezničí existující obsah souboru.
<li>Jak původně zapsaný řádek, tak druhý řádek, který jsme připojili teď, se nacházejí v souboru <code>test.log</code>. Všimněte si také, že nepřibyly žádné znaky pro návrat vozíku nebo pro odřádkování. Soubor je neobsahuje, protože jsme je do něj ani při jedné příležitosti explicitně nezapsali. Znak pro návrat vozíku (carriage return) můžeme zapsat jako <code>'\r'</code>, znak pro odřádkování (line feed) můžeme zapsat <code>'\n'</code>. Protože jsme nic z toho neudělali, skončilo vše, co jsme zapsali do souboru, na jediném řádku.
</ol>

<h3 id=files-encoding-again>A znovu kódování znaků</h3>

<p>Všimli jste si parametru <code>encoding</code>, který jsme při <a href=#files-writing>otvírání souboru pro zápis</a> předávali funkci <code>open()</code>? Je důležitý. Nikdy ho nevynechávejte! Jak jsme si ukázali na začátku kapitoly, soubory neobsahují <i>řetězce</i>. Soubory obsahují <i>bajty</i>. Z textového souboru můžeme číst „řetězce“ jen díky tomu, že jsme Pythonu řekli, jaké má při převodu proudu bajtů na řetězec použít kódování. Zápis textu do souboru představuje stejný problém, jen z opačné strany. Do souboru nemůžeme zapisovat znaky, protože <a href=#strings-byte-arrays>znaky jsou abstraktní</a>. Při zápisu do souboru musí Python vědět, jak má řetězce převádět na posloupnost bajtů. Jediný způsob, jak se ujistit, že se provede správný převod, spočívá v uvedení parametru <code>encoding</code> při otvírání souboru pro zápis.

<p class=a>&#x2042;

<h2 id=files-binary>Binární soubory</h2>

<p class=ss><img src="examples/beauregard.jpg" alt="Můj pes Beauregard." width="100" height="100" />

<p>Všechny soubory neobsahují text. Některé mohou obsahovat obrázky mého psa.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>an_image = open('examples/beauregard.jpg', mode='rb')</kbd>                <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>an_image.mode</kbd>                                                        <span class=u>&#x2461;</span></a>
<samp class=pp>'rb'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>an_image.name</kbd>                                                        <span class=u>&#x2462;</span></a>
<samp class=pp>'examples/beauregard.jpg'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>an_image.encoding</kbd>                                                    <span class=u>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AttributeError: '_io.BufferedReader' object has no attribute 'encoding'</samp></pre>
<ol>
<li>Otevření souboru v binárním režimu je jednoduché, ale záludné. Ve srovnání s otvíráním v textovém režimu spočívá jediný rozdíl v tom, že parametr <code>mode</code> obsahuje znak<code>'b'</code>.
<li>Objekt typu stream, který získáme otevřením souboru v binárním režimu, má mnoho stejných atributů, včetně atributu <code>mode</code>, který odpovídá stejnojmennému parametru předanému funkci <code>open()</code>.
<li>Binární objekty typu stream mají také atribut <code>name</code> &mdash; stejně jako textové objekty typu stream.
<li>Ale jeden rozdíl tady přesto je. Binární objekty typu stream nemají atribut <code>encoding</code>. Dává to smysl, že? Čteme (nebo zapisujeme) bajty a ne řetězce. Python tedy nemusí dělat žádný převod. Z binárního souboru dostaneme přesně to, co jsme do něj vložili. Žádná konverze není nutná.
</ol>

<p>Už jsem řekl, že čteme bajty? Ano, je to tak.

<pre class=screen>
# pokračování předchozího příkladu
<samp class=p>>>> </samp><kbd class=pp>an_image.tell()</kbd>
<samp class=pp>0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>data = an_image.read(3)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>data</kbd>
<samp class=pp>b'\xff\xd8\xff'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(data)</kbd>               <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;class 'bytes'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>an_image.tell()</kbd>          <span class=u>&#x2462;</span></a>
<samp class=pp>3</samp>
<samp class=p>>>> </samp><kbd class=pp>an_image.seek(0)</kbd>
<samp class=pp>0</samp>
<samp class=p>>>> </samp><kbd class=pp>data = an_image.read()</kbd>
<samp class=p>>>> </samp><kbd class=pp>len(data)</kbd>
<samp class=pp>3150</samp></pre>
<ol>
<li>Stejně jako v případě textových souborů také z binárních souborů můžeme číst po kouscích. Ale je tu jeden zásadní rozdíl&hellip;
<li>&hellip; čteme bajty, ne řetězce. Protože jsme soubor otevřeli v binárním režimu, přebírá metoda <code>read()</code> jako argument počet <em>bajtů</em>, které se mají načíst, a ne počet znaků.
<li>To znamená, že zde nikdy nedojde <a href=#files-read>k neočekávanému nesouladu</a> mezi číslem, které jsme předali metodě <code>read()</code>, a pozičním indexem, který nám vrací metoda <code>tell()</code>. Metoda <code>read()</code> čte bajty a metody <code>seek()</code> a <code>tell()</code> sledují počet přečtených bajtů. U binárních souborů budou vždy v souladu.
</ol>

<p class=a>&#x2042;

<h2 id=files-file-like-objects>Objekty typu stream z nesouborových zdrojů</h2>

<aside>Z předstíraného souboru čteme jednoduše voláním <code>read()</code>.</aside>

<p>Představte si, že píšete knihovnu a jedna z vašich knihovních funkcí má číst data ze souboru. Funkce by mohla jednoduše převzít jméno souboru v řetězcové podobě, otevřít soubor pro čtení, přečíst jeho obsah a před skončením funkce jej uzavřít. Ale takhle byste to dělat neměli. Místo toho by rozhraní vaší funkce (API) mělo přebírat <abbr>libovolný objekt typu stream</abbr>.

<p>V nejjednodušším případě je objektem typu stream cokoliv, co má metodu <code>read()</code>, která přebírá nepovinný parametr <var>size</var> (velikost) a vrací řetězec. Pokud je metoda <code>read()</code> zavolána bez uvedení parametru <var>size</var>, měla by ze zdroje informací přečíst všechna zbývající data a vrátit je jako jednu hodnotu. Pokud je metoda zavolána s parametrem <var>size</var>, přečte ze zdroje požadované množství dat a vrátí je. Pokud je zavolána znovu, pokračuje od místa, kde se čtením přestala, a vrací další část dat.

<p>Vypadá to, jako kdybychom používali objekt typu stream vzniklý otevřením skutečného souboru. Rozdíl je v tom, že se <em>neomezujeme na skutečné soubory</em>. Zdrojem informací, ze kterého „čteme“, může být cokoliv: webová stránka, řetězec v paměti nebo dokonce výstup z jiného programu. Pokud vaše funkce přebírá objekt typu stream a jednoduše volá jeho metodu <code>read()</code>, můžete zpracovávat libovolný zdroj informací, který se tváří jako soubor, aniž byste museli pro každý druh vstupu psát různý kód.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_string = 'PapayaWhip is the new black.'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>import io</kbd>                                  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_file = io.StringIO(a_string)</kbd>             <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.read()</kbd>                              <span class=u>&#x2462;</span></a>
<samp class=pp>'PapayaWhip is the new black.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.read()</kbd>                              <span class=u>&#x2463;</span></a>
<samp class=pp>''</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.seek(0)</kbd>                             <span class=u>&#x2464;</span></a>
<samp class=pp>0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_file.read(10)</kbd>                            <span class=u>&#x2465;</span></a>
<samp class=pp>'PapayaWhip'</samp>
<samp class=p>>>> </samp><kbd class=pp>a_file.tell()</kbd>
<samp class=pp>10</samp>
<samp class=p>>>> </samp><kbd class=pp>a_file.seek(18)</kbd>
<samp class=pp>18</samp>
<samp class=p>>>> </samp><kbd class=pp>a_file.read()</kbd>
<samp class=pp>'new black.'</samp></pre>
<ol>
<li>Modul <code>io</code> definuje třídu <code>StringIO</code>, kterou můžeme dosáhnout toho, aby se řetězec v paměti choval jako soubor.
<li>Když chceme z řetězce vytvořit objekt typu stream, vytvoříme instanci třídy <code>io.StringIO()</code> a předáme jí řetězec, který chceme použít jako zdroj „souborových“ dat. Teď máme k dispozici objekt typu stream a můžeme s ním dělat všechny možné odpovídající věci.
<li>Voláním metody <code>read()</code> „přečteme“ celý „soubor“. V takovém případě objekt třídy <code>StringIO</code> jednoduše vrátí původní řetězec.
<li>Opakované volání metody <code>read()</code> vrací prázdný řetězec &mdash; stejně jako u opravdového souboru.
<li>Použitím metody <code>seek()</code> objektu třídy <code>StringIO</code> se můžeme explicitně nastavit na začátek řetězce &mdash; stejně jako při volání téže metody u opravdového souboru.
<li>Pokud metodě <code>read()</code> předáme parametr <var>size</var>, můžeme číst po větších kouscích i z řetězce.
</ol>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Třída <code>io.StringIO</code> vám umožní chovat se k řetězci jako k textovému souboru. Existuje také třída <code>io.BytesIO</code>, která vám umožní chovat se k poli bajtů jako k binárnímu souboru.
</blockquote>

<h3 id=files-gzip>Práce s komprimovanými soubory</h3>

<p>Pythonovská standardní knihovna obsahuje moduly, které podporují čtení a zápis komprimovaných souborů. Různých komprimačních schémat existuje celá řada. Mezi newindowsovskými systémy patří mezi dva nejpopulárnější <a href="http://docs.python.org/3.1/library/gzip.html">gzip</a> a <a href="http://docs.python.org/3.1/library/bz2.html">bzip2</a>. (Mohli jste se setkat také <a href="http://docs.python.org/3.1/library/zipfile.html">s archivy PKZIP</a> a <a href="http://docs.python.org/3.1/library/tarfile.html">s archivy GNU Tar</a>. V Pythonu najdete moduly i pro tyto dva.)

<p>Modul <code>gzip</code> nám umožní vytvořit objekt typu stream pro čtení a zápis souborů komprimovaných algoritmem gzip. Příslušný objekt podporuje metodu <code>read()</code> (pokud jsme jej otevřeli pro čtení) nebo metodu <code>write()</code> (pokud jsme jej otevřeli pro zápis). To znamená, že <em>k přímému zápisu nebo čtení souborů komprimovaných algoritmem gzip</em> můžeme použít metody, které jsme se už naučili používat s normálními soubory. Nemusíme vytvářet pomocné soubory k ukládání dekomprimovaných dat.

<p>Jako bonus navíc podporuje modul <code>gzip</code> i příkaz <code>with</code>, takže uzavření komprimovaného souboru můžete ponechat na Pythonu.

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~$ </samp><kbd>python3</kbd>

<samp class=p>>>> </samp><kbd class=pp>import gzip</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>with gzip.open('out.log.gz', mode='wb') as z_file:</kbd>                                      <span class=u>&#x2460;</span></a>
<samp class=p>... </samp><kbd class=pp>  z_file.write('A nine mile walk is no joke, especially in the rain.'.encode('utf-8'))</kbd>
<samp class=p>... </samp>
<samp class=p>>>> </samp><kbd class=pp>exit()</kbd>

<a><samp class=p>you@localhost:~$ </samp><kbd>ls -l out.log.gz</kbd>                                                           <span class=u>&#x2461;</span></a>
<samp>-rw-r--r--  1 mark mark    79 2009-07-19 14:29 out.log.gz</samp>
<a><samp class=p>you@localhost:~$ </samp><kbd>gunzip out.log.gz</kbd>                                                          <span class=u>&#x2462;</span></a>
<a><samp class=p>you@localhost:~$ </samp><kbd>cat out.log</kbd>                                                                <span class=u>&#x2463;</span></a>
<samp>A nine mile walk is no joke, especially in the rain.</samp></pre>
<ol>
<li>Soubory zabalené gzip bychom měli vždy otvírat v binárním režimu. (Všimněte si znaku <code>'b'</code> v argumentu <code>mode</code>.)
<li>Tento příklad jsem vytvořil na Linuxu. Pokud vám tento příkazový řádek nic neříká, zobrazuje výpis položky souboru „v dlouhém formátu“ (v pracovním adresáři). Soubor jsme právě vytvořili v pythonovském shellu s využitím komprese gzip. Tento soubor ukazuje, že soubor existuje (fajn) a že má velikost 79 bajtů. Ve skutečnosti je větší než řetězec, se kterým jsme začali! Soubor ve formátu gzip zahrnuje hlavičku pevné délky, která obsahuje nějaké informace o souboru. Pro velmi malé soubory je to tedy neefektivní.
<li>Příkaz <code>gunzip</code> (vyslovuje se „dží anzip“) dekomprimuje daný soubor a ukládá jeho obsah do nového souboru se stejným jménem, ale bez přípony <code>.gz</code>.
<li>Příkaz <code>cat</code> zobrazuje obsah souboru. Soubor obsahuje řetězec, který jsme původně zapsali v pythonovském shellu přímo do komprimovaného souboru <code>out.log.gz</code>.
</ol>

<blockquote class=pf>
<p>Setkali jste se s následující chybou?
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>with gzip.open('out.log.gz', mode='wb') as z_file:</kbd>
<samp class=p>... </samp><kbd class=pp>        z_file.write('A nine mile walk is no joke, especially in the rain.'.encode('utf-8'))</kbd>
<samp class=p>... </samp>
<samp class=traceback>Traceback (most recent call last):
 File "&lt;stdin>", line 1, in &lt;module>
AttributeError: 'GzipFile' object has no attribute '__exit__'</samp></pre>
<p>Pokud ano, pravděpodobně používáte Python 3.0. Měli byste provést aktualizaci na Python 3.1.
<p>V Pythonu 3.0 se sice modul <code>gzip</code> nacházel, ale nepodporoval použití objektů komprimovaných souborů jako správců kontextu. V Pythonu 3.1 byla přidána možnost používat objekty gzip souborů i v příkazu <code>with</code>.
</blockquote>

<p class=a>&#x2042;

<h2 id=files-stdio>Standardní vstup, výstup a chybový výstup</h2>

<aside><code>sys.stdin</code>, <code>sys.stdout</code>, <code>sys.stderr</code>.</aside>

<p>Machři na práci přes příkazový řádek už koncept standardního vstupu, standardního výstupu a standardního chybového výstupu znají. Tato podkapitola je určena těm ostatním.

<p>Standardní výstup a standardní chybový výstup (běžně se zkracují jako <code>stdout</code> a <code>stderr</code>) jsou roury (pipe), které jsou zabudovány do každého systému, který je odvozen od <abbr>UNIX</abbr>u. Platí to i pro Mac OS X a pro Linux. Pokud voláte funkci <code>print()</code>, tištěný obsah je odeslán do roury <code>stdout</code>. Pokud váš program zhavaruje a tiskne trasovací výpis, posílá jej do roury <code>stderr</code>. Ve výchozím stavu jsou obě uvedené roury napojeny na terminálové okno, ve kterém pracujete. Když váš program něco tiskne, zobrazuje se jeho výstup ve vašem terminálovém okně. Když program zhavaruje, vidíte trasovací výpis také ve svém terminálovém okně. V grafickém pythonovském shellu jsou roury <code>stdout</code> and <code>stderr</code> přesměrovány do vašeho „interaktivního okna“.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>for i in range(3):</kbd>
<a><samp class=p>... </samp><kbd class=pp>    print('PapayaWhip')</kbd>                <span class=u>&#x2460;</span></a>
<samp>PapayaWhip
PapayaWhip
PapayaWhip</samp>
<samp class=p>>>> </samp><kbd class=pp>import sys</kbd>
<samp class=p>>>> </samp><kbd class=pp>for i in range(3):</kbd>
<a><samp class=p>... </samp><kbd class=pp>    l = sys.stdout.write('is the')</kbd>     <span class=u>&#x2461;</span></a>
<samp>is theis theis the</samp>
<samp class=p>>>> </samp><kbd class=pp>for i in range(3):</kbd>
<a><samp class=p>... </samp><kbd class=pp>    l = sys.stderr.write('new black')</kbd>  <span class=u>&#x2462;</span></a>
<samp>new blacknew blacknew black</samp></pre>
<ol>
<li>Funkce <code>print()</code> volaná v cyklu. Tady nic překvapujícího nenajdeme.
<li><code>stdout</code> je definován v modulu <code>sys</code> a jde <a href=#files-file-like-objects>o objekt typu stream</a>. Když zavoláme jeho metodu <code>write()</code>, vytiskne každý řetězec, který jí předáme, a potom vrátí délku na výstupu. Funkce <code>print</code> ve skutečnosti dělá právě tohle. Na konec každého tištěného řetězce přidá znak ukončující řádek a pak volá <code>sys.stdout.write</code>.
<li>V nejjednodušším případě posílají <code>sys.stdout</code> a <code>sys.stderr</code> výstup do stejného místa: do pythonovského integrovaného vývojového prostředí (<abbr>IDE</abbr>, pokud v něm pracujeme) nebo do terminálového okna (pokud Python spouštíme z příkazového řádku). Standardní chybový výstup (stejně jako standardní výstup) přechod na nový řádek nepřidávají. Pokud chceme přejít na nový řádek, musíme zapsat příslušné znaky pro přechod na nový řádek.
</ol>

<p><code>sys.stdout</code> a <code>sys.stderr</code> jsou objekty typu stream, ale dá se do nich pouze zapisovat. Pokus o volání jejich metody <code>read()</code> vždy vyvolá výjimku <code>IOError</code>.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import sys</kbd>
<samp class=p>>>> </samp><kbd class=pp>sys.stdout.read()</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
IOError: not readable</samp></pre>

<h3 id=files-redirect>Přesměrování standardního výstupu</h3>

<p><code>sys.stdout</code> a <code>sys.stderr</code> jsou objekty typu stream, i když podporují pouze zápis. Ale nejsou konstantní. Jde o proměnné. To znamená, že do nich můžeme přiřadit novou hodnotu&nbsp;&mdash;&nbsp;nějaký jiný objekt typu stream&nbsp;&mdash;&nbsp;a přesměrovat jejich výstup.

<p class=d>[<a href="examples/stdout.py">stáhnout <code>stdout.py</code></a>]
<pre class=pp><code>import sys

class RedirectStdoutTo:
    def __init__(self, out_new):
        self.out_new = out_new

    def __enter__(self):
        self.out_old = sys.stdout
        sys.stdout = self.out_new

    def __exit__(self, *args):
        sys.stdout = self.out_old

print('A')
with open('out.log', mode='w', encoding='utf-8') as a_file, RedirectStdoutTo(a_file):
    print('B')
print('C')</code></pre>

<p>Podívejte se na tohle:

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 stdout.py</kbd>
<samp>A
C</samp>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>cat out.log</kbd>
<samp>B</samp></pre>

<blockquote class=pf>
<p>Setkali jste se s následující chybou?
<pre class='nd screen'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd class=pp>python3 stdout.py</kbd>
<samp class=traceback>  File "stdout.py", line 15
    with open('out.log', mode='w', encoding='utf-8') as a_file, RedirectStdoutTo(a_file):
                                                              ^
SyntaxError: invalid syntax</samp></pre>
<p>Pokud ano, pravděpodobně používáte Python 3.0. Měli byste provést aktualizaci na Python 3.1.
<p>Python 3.0 podporoval příkaz <code>with</code>, ale každý příkaz mohl používat jen jednoho správce kontextu. Python 3.1 umožňuje použít v jednom příkazu <code>with</code> více správců kontextu.
</blockquote>

<p>Podívejme se nejdříve na poslední část.

<pre class=pp><code>print('A')
with open('out.log', mode='w', encoding='utf-8') as a_file, RedirectStdoutTo(a_file):
    print('B')
print('C')</code></pre>

<p>Tenhle příkaz <code>with</code> je docela komplikovaný. Přepíšu ho do trochu srozumitelnější podoby.

<pre class=pp><code>with open('out.log', mode='w', encoding='utf-8') as a_file:
    with RedirectStdoutTo(a_file):
        print('B')</code></pre>

<p>Z přepisu je vidět, že ve skutečnosti jde o <em>dva</em> příkazy <code>with</code>, z nichž jeden je zanořen do druhého. „Vnější“ příkaz <code>with</code> by nám měl být povědomý. Otvírá textový soubor zakódovaný v <abbr>UTF-8</abbr> a pojmenovaný <code>out.log</code> pro zápis a přiřazuje objekt typu stream do proměnné pojmenované <var>a_file</var>. Ale je tu ještě jedna zvláštnost.
<pre class='nd pp'><code>with RedirectStdoutTo(a_file):</code></pre>

<p>Kdepak je část <code>as</code>? Příkaz <code>with</code> ji ve skutečnosti nevyžaduje. Podobně, jako když voláte funkci a ignorujete její návratovou hodnotu, můžete použít i příkaz <code>with</code>, který nepřiřazuje kontext příkazu <code>with</code> do nějaké proměnné. V tomto případě nás zajímají pouze vedlejší efekty kontextu <code>RedirectStdoutTo</code>.

<p>A jaké jsou ty vedlejší efekty? Nahlédněme do třídy <code>RedirectStdoutTo</code>. Tato třída je uživatelsky definovaným <a href=#special-method-names-context-managers>správcem kontextu</a>. Roli správce kontextu může hrát každá funkce, která definuje <a href=#iterators-a-fibonacci-iterator>speciální metody</a> <code>__enter__()</code> a <code>__exit__()</code>.

<pre class=pp><code>class RedirectStdoutTo:
<a>    def __init__(self, out_new):    <span class=u>&#x2460;</span></a>
        self.out_new = out_new

<a>    def __enter__(self):            <span class=u>&#x2461;</span></a>
        self.out_old = sys.stdout
        sys.stdout = self.out_new

<a>    def __exit__(self, *args):      <span class=u>&#x2462;</span></a>
        sys.stdout = self.out_old</code></pre>
<ol>
<li>Metoda <code>__init__()</code> se volá bezprostředně po vytvoření instance. Přebírá jeden parametr &mdash; objekt typu stream, který chceme po dobu životnosti kontextu používat jako standardní výstup. Metoda uloží odkaz na objekt typu stream do instanční proměnné, aby jej mohly později používat ostatní metody.
<li>Metoda <code>__enter__()</code> patří mezi <a href=#iterators-a-fibonacci-iterator>speciální metody třídy</a>. Python ji volá v okamžiku vstupu do kontextu (tj. na začátku příkazu <code>with</code>). Metoda ukládá aktuální hodnotu <code>sys.stdout</code> do <var>self.out_old</var> a poté přesměruje standardní výstup přiřazením <var>self.out_new</var> do <var>sys.stdout</var>.
<li>Metoda <code>__exit__()</code> je další speciální metodou třídy. Python ji volá při opouštění kontextu (tj. na konci příkazu <code>with</code>). Metoda obnoví původní nasměrování standardního výstupu přiřazením uložené hodnoty <var>self.out_old</var> do <var>sys.stdout</var>.
</ol>

<p>Spojme to všechno dohromady:

<pre class=pp><code>
<a>print('A')                                                                             <span class=u>&#x2460;</span></a>
<a>with open('out.log', mode='w', encoding='utf-8') as a_file, RedirectStdoutTo(a_file):  <span class=u>&#x2461;</span></a>
<a>    print('B')                                                                         <span class=u>&#x2462;</span></a>
<a>print('C')                                                                             <span class=u>&#x2463;</span></a></code></pre>
<ol>
<li>Výsledek se vytiskne v „interaktivním okně“ <abbr>IDE</abbr> (nebo v terminálovém okně, pokud skript spouštíme z příkazového řádku).
<li>Tento <a href=#files-with>příkaz <code>with</code></a> přebírá <em>čárkou oddělený seznam kontextů</em>. Uvedený seznam se chová jako posloupnost vnořených bloků <code>with</code>. První kontext v seznamu je chápán jako „vnější“ blok, poslední jako „vnitřní“ blok. První kontext otvírá soubor, druhý kontext přesměrovává <code>sys.stdout</code> do objektu typu stream, který byl vytvořen v prvním kontextu.
<li>Funkce <code>print()</code> je provedena v kontextu vytvořeném příkazem <code>with</code>, a proto nebude tisknout na obrazovku. Místo toho provede zápis do souboru <code>out.log</code>.
<li>Blok kódu v příkazu <code>with</code> skončil. Python každému správci kontextu oznámil, že má udělat to, co se má udělat při opouštění kontextu. Správci kontextu jsou uloženi v zásobníku (LIFO). Druhý kontext při ukončování změnil obsah <code>sys.stdout</code> zpět na původní hodnotu a potom první kontext uzavřel soubor pojmenovaný <code>out.log</code>. A protože bylo přesměrování standardního výstupu obnoveno na původní hodnotu, bude funkce <code>print()</code> tisknout zase na obrazovku.
</ol>

<p>Přesměrování standardního chybového výstupu funguje naprosto stejně. Jen se místo <code>sys.stdout</code> použije <code>sys.stderr</code>.

<p class=a>&#x2042;

<h2 id=files-furtherreading>Přečtěte si (vše anglicky)</h2>

<ul>
<li><a href="http://docs.python.org/py3k/tutorial/inputoutput.html#reading-and-writing-files">Reading and writing files</a> v oficiální učebnici Python.org
<li><a href="http://docs.python.org/3.1/library/io.html"><code>io</code> module</a> &mdash; standardní dokumentace
<li><a href="http://docs.python.org/3.1/library/stdtypes.html#file-objects">Stream objects</a> &mdash; standardní dokumentace
<li><a href="http://docs.python.org/3.1/library/stdtypes.html#context-manager-types">Context manager types</a> &mdash; standardní dokumentace
<li><a href="http://docs.python.org/3.1/library/sys.html#sys.stdout"><code>sys.stdout</code> and <code>sys.stderr</code></a> &mdash; standardní dokumentace
<li><a href="http://en.wikipedia.org/wiki/Filesystem_in_Userspace"><abbr>FUSE</abbr> na Wikipedii</a> (anglicky; lze přepnout na odpovídající české heslo)
</ul>

</div>
<div id=chapter-xml>
<h1>XML</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> In the archonship of Aristaechmus, Draco enacted his ordinances. <span class="u">&#x275E;</span><br>(Za vlády Aristaechma uzákonil Drakon svá pravidla.)<br>&mdash; <a href="http://www.perseus.tufts.edu/cgi-bin/ptext?doc=Perseus:text:1999.01.0046;query=chapter%3D%235;layout=;loc=3.1">Aristoteles</a>
</blockquote>
<p>&nbsp;
<h2 id=xml-divingin>Ponořme se</h2>
<p class=f>Téměř všechny kapitoly této knihy se točí kolem příkladů kódu. <abbr>XML</abbr> nesouvisí s kódem, ale s daty. Jedním z míst, kde se <abbr>XML</abbr> běžně používá, je „publikovaný obsah“ (syndication feeds), ve kterém se udržuje seznam posledních článků blogu, fóra nebo jiného, často aktualizovaného obsahu webového místa. Nejpopulárnější blogovací programy vytvářejí obsah (feed), a kdykoliv je publikován nový článek, diskusní vlákno nebo zpráva na blogu, tento obsah aktualizují. Blog můžeme sledovat tak, že se „přihlásíme k odběru“ jeho obsahu (feed). Více blogů můžeme sledovat tak, že použijeme k tomu určený „<a href="http://en.wikipedia.org/wiki/List_of_feed_aggregators">nástroj pro sdružování obsahu (feed aggregator)</a>“, jako je například <a href="http://www.google.com/reader/">Google Reader</a>.

<p>V této kapitole budeme pracovat s následujícími <abbr>XML</abbr> daty. Jde o publikovaný obsah (feed)&nbsp;&mdash;&nbsp;konkrétně o <a href="http://atompub.org/rfc4287.html">Atom syndication feed</a>.

<p class=d>[<a href="examples/feed.xml">stáhnout <code>feed.xml</code></a>]
<pre class=pp><code>&lt;?xml version='1.0' encoding='utf-8'?>
&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'>
  &lt;title>dive into mark&lt;/title>
  &lt;subtitle>currently between addictions&lt;/subtitle>
  &lt;id>tag:diveintomark.org,2001-07-29:/&lt;/id>
  &lt;updated>2009-03-27T21:56:07Z&lt;/updated>
  &lt;link rel='alternate' type='text/html' href='http://diveintomark.org/'/>
  &lt;link rel='self' type='application/atom+xml' href='http://diveintomark.org/feed/'/>
  &lt;entry>
    &lt;author>
      &lt;name>Mark&lt;/name>
      &lt;uri>http://diveintomark.org/&lt;/uri>
    &lt;/author>
    &lt;title>Dive into history, 2009 edition&lt;/title>
    &lt;link rel='alternate' type='text/html'
      href='http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'/>
    &lt;id>tag:diveintomark.org,2009-03-27:/archives/20090327172042&lt;/id>
    &lt;updated>2009-03-27T21:56:07Z&lt;/updated>
    &lt;published>2009-03-27T17:20:42Z&lt;/published>
    &lt;category scheme='http://diveintomark.org' term='diveintopython'/>
    &lt;category scheme='http://diveintomark.org' term='docbook'/>
    &lt;category scheme='http://diveintomark.org' term='html'/>
  &lt;summary type='html'>Putting an entire chapter on one page sounds
    bloated, but consider this &amp;amp;mdash; my longest chapter so far
    would be 75 printed pages, and it loads in under 5 seconds&amp;amp;hellip;
    On dialup.&lt;/summary>
  &lt;/entry>
  &lt;entry>
    &lt;author>
      &lt;name>Mark&lt;/name>
      &lt;uri>http://diveintomark.org/&lt;/uri>
    &lt;/author>
    &lt;title>Accessibility is a harsh mistress&lt;/title>
    &lt;link rel='alternate' type='text/html'
      href='http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress'/>
    &lt;id>tag:diveintomark.org,2009-03-21:/archives/20090321200928&lt;/id>
    &lt;updated>2009-03-22T01:05:37Z&lt;/updated>
    &lt;published>2009-03-21T20:09:28Z&lt;/published>
    &lt;category scheme='http://diveintomark.org' term='accessibility'/>
    &lt;summary type='html'>The accessibility orthodoxy does not permit people to
      question the value of features that are rarely useful and rarely used.&lt;/summary>
  &lt;/entry>
  &lt;entry>
    &lt;author>
      &lt;name>Mark&lt;/name>
    &lt;/author>
    &lt;title>A gentle introduction to video encoding, part 1: container formats&lt;/title>
    &lt;link rel='alternate' type='text/html'
      href='http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats'/>
    &lt;id>tag:diveintomark.org,2008-12-18:/archives/20081218155422&lt;/id>
    &lt;updated>2009-01-11T19:39:22Z&lt;/updated>
    &lt;published>2008-12-18T15:54:22Z&lt;/published>
    &lt;category scheme='http://diveintomark.org' term='asf'/>
    &lt;category scheme='http://diveintomark.org' term='avi'/>
    &lt;category scheme='http://diveintomark.org' term='encoding'/>
    &lt;category scheme='http://diveintomark.org' term='flv'/>
    &lt;category scheme='http://diveintomark.org' term='GIVE'/>
    &lt;category scheme='http://diveintomark.org' term='mp4'/>
    &lt;category scheme='http://diveintomark.org' term='ogg'/>
    &lt;category scheme='http://diveintomark.org' term='video'/>
    &lt;summary type='html'>These notes will eventually become part of a
      tech talk on video encoding.&lt;/summary>
  &lt;/entry>
&lt;/feed></code></pre>

<p class=a>&#x2042;

<h2 id=xml-xml-intro>Pětiminutový rychlokurz XML</h2>

<p>Pokud už o <abbr>XML</abbr> něco víte, můžete tuto podkapitolu přeskočit.

<p><abbr>XML</abbr> představuje zobecněný způsob popisu hierarchických strukturovaných dat. <abbr>XML</abbr>-<i>dokument</i> obsahuje jeden nebo více <i>elementů</i>, které jsou ohraničeny <i>počátečními a koncovými značkami</i> (tag). Tohle je kompletní (i když poněkud nudný) <abbr>XML</abbr> dokument:

<pre class='nd pp'><code><a>&lt;foo>   <span class=u>&#x2460;</span></a>
<a>&lt;/foo>  <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>Toto je <i>počáteční značka</i> elementu <code>foo</code>.
<li>Toto je odpovídající <i>koncová značka</i> elementu <code>foo</code>. Každá počáteční značka musí být <i>uzavřena</i> (spárována s) odpovídající koncovou značkou stejně, jako musíme párovat závorky v matematice nebo v textu.
</ol>

<p>Elementy lze <i>zanořovat</i> do libovolné hloubky. O elementu <code>bar</code> uvnitř elementu <code>foo</code> se říká, že je <i>subelementem</i> nebo <i>potomkem</i> (child) elementu <code>foo</code>.

<pre class='nd pp'><code>&lt;foo>
  <mark>&lt;bar>&lt;/bar></mark>
&lt;/foo>
</code></pre>

<p>Prvnímu elementu v každém <abbr>XML</abbr> dokumentu se říká <i>kořenový element</i> (root element). <abbr>XML</abbr> dokument může mít jen jeden kořenový element. Následující text <strong>není <abbr>XML</abbr> dokumentem</strong>, protože obsahuje dva kořenové elementy:

<pre class='nd pp'><code>&lt;foo>&lt;/foo>
&lt;bar>&lt;/bar></code></pre>

<p>Elementy mohou nést <i>atributy</i>, což jsou dvojice jméno-hodnota. Atributy se uvádějí uvnitř počáteční značky elementu a oddělují se bílými znaky. Uvnitř jednoho elementu se <i>jména atributů</i> nesmějí opakovat. <i>Hodnoty atributů</i> musí být uzavřeny v uvozovkách nebo v apostrofech.

<pre class='nd pp'><code><a>&lt;foo <mark>lang='en'</mark>>                          <span class=u>&#x2460;</span></a>
<a>  &lt;bar id=xml-'papayawhip' <mark>lang="fr"</mark>>&lt;/bar>  <span class=u>&#x2461;</span></a>
&lt;/foo>
</code></pre>
<ol>
<li>Element <code>foo</code> má jeden atribut pojmenovaný <code>lang</code>. Hodnotou jeho atributu <code>lang</code> je <code>en</code>.
<li>Element <code>bar</code> má dva atributy pojmenované <code>id</code> a <code>lang</code>. Jeho atribut <code>lang</code> má hodnotu <code>fr</code>. Nedochází vůbec k žádnému konfliktu s elementem <code>foo</code>. Každý element má svou vlastní sadu atributů.
</ol>

<p>Pokud je v jednom elementu uvedeno víc atributů, pak jejich pořadí není významné. Atributy elementu tvoří neuspořádanou množinu dvojic klíčů a hodnot &mdash; jako pythonovský slovník. Počet atributů, které můžeme u každého elementu definovat, není nijak omezen.

<p>Elementy mohou <i>obsahovat text</i>.

<pre class='nd pp'><code>&lt;foo lang='en'>
  &lt;bar lang='fr'><mark>PapayaWhip</mark>&lt;/bar>
&lt;/foo>
</code></pre>

<p>Elementy, které neobsahují žádný text a nemají žádné potomky, jsou <i>prázdné</i>.

<pre class='nd pp'><code>&lt;foo>&lt;/foo></code></pre>

<p>Prázdné elementy můžeme zapisovat zkráceně. Když do počáteční značky umístíme znak <code>/</code>, můžeme koncovou značku úplně vynechat. <abbr>XML</abbr> dokument z předchozího příkladu můžeme zkráceně zapsat takto:

<pre class='nd pp'><code>&lt;foo<mark>/</mark>></code></pre>

<p>Podobně jako můžeme pythonovské funkce deklarovat v <i>různých modulech</i>, <abbr>XML</abbr> elementy můžeme deklarovat v různých <i>prostorech jmen</i>. Prostory jmen se obvykle podobají zápisu URL. <i>Výchozí prostor jmen</i> definujeme pomocí deklarace <code>xmlns</code>. Deklarace prostoru jmen vypadá podobně jako zápis atributu, ale plní odlišný účel.

<pre class='nd pp'><code><a>&lt;feed <mark>xmlns='http://www.w3.org/2005/Atom'</mark>>  <span class=u>&#x2460;</span></a>
<a>  &lt;title>dive into mark&lt;/title>             <span class=u>&#x2461;</span></a>
&lt;/feed>
</code></pre>
<ol>
<li>Element <code>feed</code> se nachází v prostoru jmen <code>http://www.w3.org/2005/Atom</code>.
<li>Element <code>title</code> se také nachází v prostoru jmen <code>http://www.w3.org/2005/Atom</code>. Deklarace prostoru jmen ovlivní element, ve kterém se deklarace nachází, a dále všechny jeho dětské elementy (potomky).
</ol>

<p>Při deklaraci prostoru jmen můžeme použít také zápis <code>xmlns:<var>prefix</var></code>, čímž prostor jmen spřáhneme se zadaným <i>prefix</i>em. V takovém případě musí být každý element tohoto prostoru jmen explicitně deklarován se stejným prefixem.

<pre class='nd pp'><code><a>&lt;atom:feed <mark>xmlns:atom='http://www.w3.org/2005/Atom'</mark>>  <span class=u>&#x2460;</span></a>
<a>  &lt;atom:title>dive into mark&lt;/atom:title>             <span class=u>&#x2461;</span></a>
&lt;/atom:feed></code></pre>
<ol>
<li>Element <code>feed</code> se nachází v prostoru jmen <code>http://www.w3.org/2005/Atom</code>.
<li>Element <code>title</code> se také nachází v prostoru jmen <code>http://www.w3.org/2005/Atom</code>.
</ol>

<p>Z pohledu syntaktického analyzátoru pro <abbr>XML</abbr> jsou přecházející dva <abbr>XML</abbr> dokumenty <em>identické</em>. Prostor jmen + jméno elementu = <abbr>XML</abbr> identita. Prefixy se používají pouze k odkazu na prostor jmen. To znamená, že konkrétní jméno prefixu (<code>atom:</code>) je nepodstatné. Prostory jmen pasují, jména elementů se shodují, atributy (nebo neuvedení atributů) sedí, textový obsah každého elementu se také shoduje. To znamená, že se jedná o stejné <abbr>XML</abbr> dokumenty.

<p>Na závěr uveďme, že <abbr>XML</abbr> dokumenty mohou na prvním řádku, před kořenovým elementem, uvádět <a href=#strings-one-ring-to-rule-them-all>informaci o znakovém kódování</a>. (Pokud vás zajímá, jak může dokument obsahovat informaci, která musí být známa předtím, než se dokument zpracovává, pak detaily řešení této Hlavy XXII hledejte <a href="http://www.w3.org/TR/REC-xml/#sec-guessing-no-ext-info">v sekci F specifikace <abbr>XML</abbr></a> (anglicky).)

<pre class='nd pp'><code>&lt;?xml version='1.0' <mark>encoding='utf-8'</mark>?></code></pre>

<p>Tak a teď už o <abbr>XML</abbr> víte dost na to, abyste mohli být nebezpeční!

<p class=a>&#x2042;

<h2 id=xml-xml-structure>Struktura Atom Feed</h2>

<p>Vezměme si nějaký weblog nebo v podstatě libovolný webový server s často aktualizovaným obsahem, jako je například <a href="http://www.cnn.com/">CNN.com</a>. Server má svůj nadpis („CNN.com“), podnadpis („Breaking News, U.S., World, Weather, Entertainment <i class="baa">&amp;</i> Video News“), datum poslední aktualizace („updated 12:43 p.m. EDT, Sat May 16, 2009“) a seznam článků zveřejněných v různých časech. Každý článek má také nadpis, datum prvního zveřejnění (a možná také datum poslední aktualizace, pokud zveřejnili upřesnění nebo opravili překlep) a jedinečné URL.

<p><a href="http://atompub.org/rfc4287.html">The Atom syndication format</a> je navržen tak, aby všechny tyto informace zachytil ve standardním tvaru. Můj weblog a CNN.com se sice velmi liší v návrhu, rozsahu a v návštěvnosti, ale oba mají stejnou základní strukturu. CNN.com má nadpis, můj blog má nadpis. CNN.com zveřejňuje články, já zveřejňuji články.

<p>Na nejvyšší úrovni se nachází <i>kořenový element</i>, který používají všechny „Atom feed“ &mdash; element <code>feed</code> v prostoru jmen <code>http://www.w3.org/2005/Atom</code>.

<pre class=pp><code><a>&lt;feed xmlns='http://www.w3.org/2005/Atom'  <span class=u>&#x2460;</span></a>
<a>      xml:lang='en'>                       <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li><code>http://www.w3.org/2005/Atom</code> je prostor jmen pro Atom.
<li>Libovolný element může obsahovat atribut <code>xml:lang</code>, který deklaruje jazyk elementu a jeho potomků. V tomto případě je atribut <code>xml:lang</code> deklarován jen jednou, v kořenovém elementu. To znamená, že celý obsah (feed) je v angličtině.
</ol>

<p>Atom feed (chápejte tento název jako pojem) obsahuje pár informací i o dokumentu samotném (tedy o sobě). Jsou deklarovány jako potomci kořenového elementu <code>feed</code>.

<pre class=pp><code>&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'>
<a>  &lt;title>dive into mark&lt;/title>                                             <span class=u>&#x2460;</span></a>
<a>  &lt;subtitle>currently between addictions&lt;/subtitle>                         <span class=u>&#x2461;</span></a>
<a>  &lt;id>tag:diveintomark.org,2001-07-29:/&lt;/id>                                <span class=u>&#x2462;</span></a>
<a>  &lt;updated>2009-03-27T21:56:07Z&lt;/updated>                                   <span class=u>&#x2463;</span></a>
<a>  &lt;link rel='alternate' type='text/html' href='http://diveintomark.org/'/>  <span class=u>&#x2464;</span></a></code></pre>
<ol>
<li>Nadpis obsahu je <code>dive into mark</code>.
<li>Podnadpis obsahu je <code>currently between addictions</code>.
<li>Každý obsah (feed) potřebuje globálně jednoznačný identifikátor. V dokumentu <a href="http://www.ietf.org/rfc/rfc4151.txt">RFC 4151</a> najdete, jak se dá vytvořit.
<li>Tento obsah byl naposledy aktualizován 27. března 2009 v 21.56 GMT. Obvykle se shoduje s časem poslední modifikace nejnovějšího článku.
<li>Teď to začne být zajímavé. Tento element <code>link</code> nemá žádný textový obsah, ale má tři atributy: <code>rel</code>, <code>type</code> a <code>href</code>. Hodnota atributu <code>rel</code> říká, jakého druhu odkaz je. Hodnota <code>rel='alternate'</code> vyjadřuje, že jde o odkaz na alternativní reprezentaci tohoto obsahu (feed). Atribut <code>type='text/html'</code> říká, že jde o odkaz na <abbr>HTML</abbr> stránku. Cíl odkazu je uveden v atributu <code>href</code>.
</ol>

<p>Teď už víme, že jde o obsah (feed) pro místo zvané „dive into mark“, které se nachází na <a href="http://diveintomark.org/"><code>http://diveintomark.org/</code></a> a bylo naposledy aktualizováno 27. března 2009.

<blockquote class=note>
<p><span class="u">&#x261E;</span>Ačkoliv v některých <abbr>XML</abbr> dokumentech může být pořadí elementů důležité, pro Atom feed to neplatí.
</blockquote>

<p>Po metadatech vázaných na celý dokument (feed) se nachází seznam nejnovějších článků. Článek vypadá takto:

<pre class=pp><code>&lt;entry>
<a>  &lt;author>                                                                 <span class=u>&#x2460;</span></a>
    &lt;name>Mark&lt;/name>
    &lt;uri>http://diveintomark.org/&lt;/uri>
  &lt;/author>
<a>  &lt;title>Dive into history, 2009 edition&lt;/title>                           <span class=u>&#x2461;</span></a>
<a>  &lt;link rel='alternate' type='text/html'                                   <span class=u>&#x2462;</span></a>
    href='http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'/>
<a>  &lt;id>tag:diveintomark.org,2009-03-27:/archives/20090327172042&lt;/id>        <span class=u>&#x2463;</span></a>
<a>  &lt;updated>2009-03-27T21:56:07Z&lt;/updated>                                  <span class=u>&#x2464;</span></a>
  &lt;published>2009-03-27T17:20:42Z&lt;/published>
<a>  &lt;category scheme='http://diveintomark.org' term='diveintopython'/>       <span class=u>&#x2465;</span></a>
  &lt;category scheme='http://diveintomark.org' term='docbook'/>
  &lt;category scheme='http://diveintomark.org' term='html'/>
<a>  &lt;summary type='html'>Putting an entire chapter on one page sounds        <span class=u>&#x2466;</span></a>
    bloated, but consider this &amp;amp;mdash; my longest chapter so far
    would be 75 printed pages, and it loads in under 5 seconds&amp;amp;hellip;
    On dialup.&lt;/summary>
<a>&lt;/entry>                                                                   <span class=u>&#x2467;</span></a></code></pre>
<ol>
<li>Element <code>author</code> říká, kdo článek napsal: nějaký maník jménem Mark, který se poflakuje někde na <code>http://diveintomark.org/</code>. (Je to stejná hodnota, jako alternativní odkaz v metadatech k feed, ale nemusí tomu tak být. Mnoho weblogů využívá více autorů najednou a každý z nich mívá jiný osobní webový server.)
<li>Element <code>title</code> nese název článku &mdash; „Dive into history, 2009 edition“.
<li>Element <code>link</code> obsahuje adresu <abbr>HTML</abbr> verze tohoto článku, podobně jako v případě alternativního odkazu na úrovni celého obsahu (feed).
<li>Položky (<code>entry</code>), stejně jako celý obsah (feed), potřebují jednoznačný identifikátor.
<li>Položky nesou dvě data: datum prvního zveřejnění (<code>published</code>) a datum poslední modifikace (<code>updated</code>).
<li>Položky mohou nést libovolný počet kategorií (<code>category</code>). Tento článek je zařazen pod <code>diveintopython</code>, <code>docbook</code> a <code>html</code>.
<li>Element <code>summary</code> nese stručné shrnutí obsahu článku. (Existuje i element <code>content</code> &mdash; tj. obsah &mdash;, který zde není použit. Je určen pro vložení celého textu článku.) Tento element <code>summary</code> nese atribut <code>type='html'</code>, který je specifický pro Atom. Říká, že uvedené shrnutí není prostý text, ale úryvek ve formátu <abbr>HTML</abbr>. Ta informace je důležitá, protože se v něm nacházejí věci specifické pro <abbr>HTML</abbr> (<code>&amp;mdash;</code> a <code>&amp;hellip;</code>), které se nemají zviditelňovat jako text, ale jako „&mdash;“ a „&hellip;“.
<li>A na závěr je tu koncová značka elementu <code>entry</code>, která signalizuje konec metadat pro tento článek.
</ol>

<p class=a>&#x2042;

<h2 id=xml-xml-parse>Analýza XML</h2>

<p>Python dovede analyzovat <abbr>XML</abbr> dokumenty několika způsoby. Najdeme zde tradiční syntaktické analyzátory (také parsery) <a href="http://en.wikipedia.org/wiki/XML#DOM"><abbr>DOM</abbr></a> a <a href="http://en.wikipedia.org/wiki/Simple_API_for_XML"><abbr>SAX</abbr></a>. My se ale zaměříme na jinou knihovnu zvanou ElementTree.

<p class=d>[<a href="examples/feed.xml">download <code>feed.xml</code></a>]
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import xml.etree.ElementTree as etree</kbd>    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>tree = etree.parse('examples/feed.xml')</kbd>  <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>root = tree.getroot()</kbd>                    <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>root</kbd>                                     <span class=u>&#x2463;</span></a>
<samp>&lt;Element {http://www.w3.org/2005/Atom}feed at cd1eb0></samp></pre>
<ol>
<li>Knihovna ElementTree je součástí standardní pythonovské knihovny. Nachází se v <code>xml.etree.ElementTree</code>.
<li>Primárním vstupním bodem knihovny ElementTree je funkce <code>parse()</code>, která přebírá buď jméno souboru nebo <a href=#files-file-like-objects>souboru se podobající objekt</a>. Funkce zpracuje celý dokument najednou. Pokud chceme šetřit pamětí, existují způsoby, jak můžeme <a href="http://effbot.org/zone/element-iterparse.htm"><abbr>XML</abbr> dokument zpracovávat postupně</a>.
<li>Funkce <code>parse()</code> vrací objekt, který reprezentuje celý dokument. Ale <em>není</em> to kořenový element. Pokud chceme získat odkaz na kořenový element, zavoláme metodu <code>getroot()</code>.
<li>Jak se dalo čekat, kořenovým elementem je element <code>feed</code>, který se nachází v prostoru jmen <code>http://www.w3.org/2005/Atom</code>. Řetězcová reprezentace tohoto objektu v nás posiluje důležitý pohled: <abbr>XML</abbr> element je kombinací svého prostoru jmen a jména své značky (která se též nazývá <i>lokální jméno</i>). Každý element tohoto dokumentu se nachází v prostoru jmen Atom, takže kořenový element je reprezentován jako <code>{http://www.w3.org/2005/Atom}feed</code>.
</ol>

<blockquote class=note>
<p><span class="u">&#x261E;</span>ElementTree reprezentuje <abbr>XML</abbr> elementy jako <code>{<var>prostor_jmen</var>}<var>lokální_jméno</var></code>. Tento formát uvidíme a budeme používat na mnoha místech aplikačního rozhraní ElementTree.
</blockquote>

<h3 id=xml-xml-elements>Elementy jsou reprezentovány seznamy</h3>

<p>V aplikačním rozhraní ElementTree se elementy chovají jako seznamy. Položkami seznamu jsou elementy potomků (child).

<pre class=screen>
# pokračování předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>root.tag</kbd>                        <span class=u>&#x2460;</span></a>
<samp>'{http://www.w3.org/2005/Atom}feed'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(root)</kbd>                       <span class=u>&#x2461;</span></a>
<samp class=pp>8</samp>
<a><samp class=p>>>> </samp><kbd class=pp>for child in root:</kbd>              <span class=u>&#x2462;</span></a>
<a><samp class=p>... </samp><kbd class=pp>  print(child)</kbd>                  <span class=u>&#x2463;</span></a>
<samp class=p>... </samp>
<samp>&lt;Element {http://www.w3.org/2005/Atom}title at e2b5d0>
&lt;Element {http://www.w3.org/2005/Atom}subtitle at e2b4e0>
&lt;Element {http://www.w3.org/2005/Atom}id at e2b6c0>
&lt;Element {http://www.w3.org/2005/Atom}updated at e2b6f0>
&lt;Element {http://www.w3.org/2005/Atom}link at e2b4b0>
&lt;Element {http://www.w3.org/2005/Atom}entry at e2b720>
&lt;Element {http://www.w3.org/2005/Atom}entry at e2b510>
&lt;Element {http://www.w3.org/2005/Atom}entry at e2b750></samp></pre>
<ol>
<li>Pokračujme v předchozím příkladu. Kořenový element je <code>{http://www.w3.org/2005/Atom}feed</code>.
<li>„Délkou“ kořenového elementu rozumíme počet dětských elementů (potomků, child).
<li>Objekt elementu můžeme použít jako iterátor, který zajistí průchod všemi svými dětskými elementy.
<li>Na výstupu vidíme, že obsahuje očekávaných 8 potomků: metadata patřící k feed (<code>title</code>, <code>subtitle</code>, <code>id</code>, <code>updated</code> a <code>link</code>) následovaná třemi elementy <code>entry</code>.
</ol>

<p>Asi už jste to odhadli, ale zdůrazněme to ještě explicitně: seznam dětských elementů zahrnuje pouze <em>přímé</em> potomky. Každý z elementů <code>entry</code> obsahuje své vlastní potomky, ale ti v tomto seznamu uvedeni nejsou. Jako dětské elementy jsou součástí seznamů elementů <code>entry</code>, ale nejsou zahrnuty mezi potomky elementu <code>feed</code>. Existují způsoby, jak můžeme elementy vyhledat nezávisle na tom, jak hluboko jsou zanořené. Na dva takové způsoby se v této kapitole podíváme později.

<h3 id=xml-xml-attributes>Atributy jsou reprezentovány slovníky</h3>

<p><abbr>XML</abbr> není jen kolekcí elementů. Každý element má svou vlastní sadu atributů. Jakmile máme odkaz na konkrétní element, můžeme jeho atributy snadno získat jako pythonovský slovník.

<pre class=screen>
# pokračování předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>root.attrib</kbd>                           <span class=u>&#x2460;</span></a>
<samp class=pp>{'{http://www.w3.org/XML/1998/namespace}lang': 'en'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>root[4]</kbd>                               <span class=u>&#x2461;</span></a>
<samp>&lt;Element {http://www.w3.org/2005/Atom}link at e181b0></samp>
<a><samp class=p>>>> </samp><kbd class=pp>root[4].attrib</kbd>                        <span class=u>&#x2462;</span></a>
<samp class=pp>{'href': 'http://diveintomark.org/',
 'type': 'text/html',
 'rel': 'alternate'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>root[3]</kbd>                               <span class=u>&#x2463;</span></a>
<samp>&lt;Element {http://www.w3.org/2005/Atom}updated at e2b4e0></samp>
<a><samp class=p>>>> </samp><kbd class=pp>root[3].attrib</kbd>                        <span class=u>&#x2464;</span></a>
<samp class=pp>{}</samp></pre>
<ol>
<li>Vlastnost <code>attrib</code> je slovníkem atributů elementu. Původní značka vypadala takto: <code>&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'&gt;</code>. Prefix <code>xml:</code> se vztahuje k zabudovanému prostoru jmen, který můžeme používat v každém <abbr>XML</abbr> dokumentu, aniž bychom jej museli deklarovat.
<li>Pátým potomkem&nbsp;&mdash;&nbsp;<code>[4]</code> odpovídá indexování seznamu od nuly&nbsp;&mdash;&nbsp; je element <code>link</code>.
<li>Element <code>link</code> má tři atributy: <code>href</code>, <code>type</code> a <code>rel</code>.
<li>Čtvrtým potomkem&nbsp;&mdash;&nbsp;<code>[3]</code> odpovídá indexování seznamu od nuly&nbsp;&mdash;&nbsp; je element <code>updated</code>.
<li>Element <code>updated</code> nemá žádné atributy, takže jeho vlastnost <code>.attrib</code> je prostě prázdný slovník.
</ol>

<p class=a>&#x2042;

<h2 id=xml-xml-find>Vyhledávání uzlů v XML dokumentu</h2>

<p>Zatím jsme s uvedeným <abbr>XML</abbr> dokumentem pracovali „shora dolů“. Začali jsme u kořenového elementu, zpřístupnili jsme si elementy jeho potomků a tak dále napříč dokumentem. Ale při mnoha použitích <abbr>XML</abbr> se požaduje nalezení určitého elementu. Etree to umí také.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import xml.etree.ElementTree as etree</kbd>
<samp class=p>>>> </samp><kbd class=pp>tree = etree.parse('examples/feed.xml')</kbd>
<samp class=p>>>> </samp><kbd class=pp>root = tree.getroot()</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>root.findall('{http://www.w3.org/2005/Atom}entry')</kbd>    <span class=u>&#x2460;</span></a>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}entry at e2b4e0>,
 &lt;Element {http://www.w3.org/2005/Atom}entry at e2b510>,
 &lt;Element {http://www.w3.org/2005/Atom}entry at e2b540>]</samp>
<samp class=p>>>> </samp><kbd class=pp>root.tag</kbd>
<samp class=pp>'{http://www.w3.org/2005/Atom}feed'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>root.findall('{http://www.w3.org/2005/Atom}feed')</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>[]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>root.findall('{http://www.w3.org/2005/Atom}author')</kbd>   <span class=u>&#x2462;</span></a>
<samp class=pp>[]</samp></pre>
<ol>
<li>Metoda <code>findall()</code> najde všechny dětské elementy, které odpovídají určitému dotazu. (O formátu dotazu si řekneme za minutku.)
<li>Každý element&nbsp;&mdash;&nbsp;včetně kořenového elementu, ale také dětských elementů&nbsp;&mdash;&nbsp;má metodu <code>findall()</code>. Ta mezi potomky najde všechny odpovídající elementy. Ale proč tu nejsou žádné výsledky? Ačkoliv to nemusí být úplně zřejmé, tento dotaz prohledává jen elementy potomků. A protože kořenový element <code>feed</code> nemá žádného potomka jménem <code>feed</code>, vrací dotaz prázdný seznam.
<li>Tento výsledek vás možná také překvapí. V tomto dokumentu <a href=#xml-divingin>se nachází element <code>author</code></a>. Ve skutečnosti jsou v něm tři (jeden v každém elementu <code>entry</code>). Ale elementy <code>author</code> nejsou <em>přímými potomky</em> kořenového elementu. Jsou to jeho „vnuci“ (doslova potomci potomků). Pokud hledáte elementy <code>author</code> na libovolné úrovni zanoření, je to možné provést, ale formát dotazu se mírně liší.
</ol>

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>tree.findall('{http://www.w3.org/2005/Atom}entry')</kbd>    <span class=u>&#x2460;</span></a>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}entry at e2b4e0>,
 &lt;Element {http://www.w3.org/2005/Atom}entry at e2b510>,
 &lt;Element {http://www.w3.org/2005/Atom}entry at e2b540>]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>tree.findall('{http://www.w3.org/2005/Atom}author')</kbd>   <span class=u>&#x2461;</span></a>
<samp class=pp>[]</samp>
</pre>
<ol>
<li>Z praktických důvodů má objekt <code>tree</code> (vracený funkcí <code>etree.parse()</code>) několik metod, které odpovídají metodám kořenového elementu. Výsledky jsou stejné, jako kdybychom zavolali metodu <code>tree.getroot().findall()</code>.
<li>Tento dotaz, možná trošku překvapivě, v dokumentu nenajde elementy <code>author</code>. Proč ne? Protože je to zkratka pro <code>tree.getroot().findall('{http://www.w3.org/2005/Atom}author')</code>, což znamená „najdi všechny elementy <code>author</code>, které jsou potomky kořenového elementu“. Elementy <code>author</code> nejsou potomky kořenového elementu. Jsou to potomci elementů <code>entry</code>. Takže uvedený dotaz nenajde žádnou shodu.
</ol>

<p>Existuje také metoda <code>find()</code>, která vrací první vyhovující element. Hodí se v situacích, kdy očekáváme pouze jeden výskyt, nebo když je výskytů víc, ale zajímá nás jen první.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>entries = tree.findall('{http://www.w3.org/2005/Atom}entry')</kbd>           <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>len(entries)</kbd>
<samp class=p>3</samp>
<a><samp class=p>>>> </samp><kbd class=pp>title_element = entries[0].find('{http://www.w3.org/2005/Atom}title')</kbd>  <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>title_element.text</kbd>
<samp class=pp>'Dive into history, 2009 edition'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>foo_element = entries[0].find('{http://www.w3.org/2005/Atom}foo')</kbd>      <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>foo_element</kbd>
<samp class=p>>>> </samp><kbd class=pp>type(foo_element)</kbd>
<samp class=pp>&lt;class 'NoneType'></samp>
</pre>
<ol>
<li>Tohle jsme viděli v předchozím příkladu. Naleznou se všechny elementy <code>atom:entry</code>.
<li>Metoda <code>find()</code> přebírá dotaz a vrací první vyhovující element.
<li>Uvnitř elementu nejsou žádné položky nazvané <code>foo</code>, takže se vrací <code>None</code>.
</ol>

<blockquote class=note>
<p><span class="u">&#x261E;</span>S metodou <code>find()</code> je spojen „chyták“, který vás jednou dostane. Objekt elementu z ElementTree se v booleovském kontextu vyhodnocuje jako <code>False</code> v případě, kdy neobsahuje žádné potomky (tj. jestliže <code>len(element)</code> je rovno nule). To znamená, že zápis <code>if element.find('...')</code> netestuje, zda metoda <code>find()</code> nalezla vyhovující element. Testuje, zda vyhovující element má nějaké potomky! Pokud chceme testovat, zda metoda <code>find()</code> vrátila nějaký element, musíme použít zápis <code>if element.find('...') is not None</code>.
</blockquote>

<p>On ale <em>existuje</em> způsob, jak najít elementy veškerých <em>příbuzných potomků</em>, tj. dětí, vnuků a dalších elementů na libovolné úrovni zanoření.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>all_links = tree.findall('//{http://www.w3.org/2005/Atom}link')</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>all_links</kbd>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}link at e181b0>,
 &lt;Element {http://www.w3.org/2005/Atom}link at e2b570>,
 &lt;Element {http://www.w3.org/2005/Atom}link at e2b480>,
 &lt;Element {http://www.w3.org/2005/Atom}link at e2b5a0>]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>all_links[0].attrib</kbd>                                              <span class=u>&#x2461;</span></a>
<samp class=pp>{'href': 'http://diveintomark.org/',
 'type': 'text/html',
 'rel': 'alternate'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>all_links[1].attrib</kbd>                                              <span class=u>&#x2462;</span></a>
<samp class=pp>{'href': 'http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition',
 'type': 'text/html',
 'rel': 'alternate'}</samp>
<samp class=p>>>> </samp><kbd class=pp>all_links[2].attrib</kbd>
<samp class=pp>{'href': 'http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress',
 'type': 'text/html',
 'rel': 'alternate'}</samp>
<samp class=p>>>> </samp><kbd class=pp>all_links[3].attrib</kbd>
<samp class=pp>{'href': 'http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats',
 'type': 'text/html',
 'rel': 'alternate'}</samp></pre>
<ol>
<li>Tento dotaz&nbsp;&mdash;&nbsp;<code>//{http://www.w3.org/2005/Atom}link</code>&nbsp;&mdash;&nbsp;je těm z předchozích příkladů velmi podobný. Jedinou odlišností jsou dvě lomítka na začátku dotazu. Tato dvě lomítka znamenají: „Nedívej se jen na přímé potomky. Chci najít <em>jakékoliv</em> elementy, nezávisle na úrovni zanoření.“ Takže výsledkem je seznam čtyř elementů <code>link</code> a nejen jednoho.
<li>První výsledek <em>je</em> přímým potomkem kořenového elementu. Jak vidíme z jeho atributů, jde o alternativní odkaz z úrovně celého obsahu (feed). Odkazuje na <abbr>HTML</abbr> verzi webového místa, které zveřejňovaný obsah popisuje.
<li>Ostatní tři výsledky jsou alternativní odkazy z každého elementu <code>entry</code>. Každý element <code>entry</code> obsahuje jeden dětský element <code>link</code>. A protože je na začátku dotazu uvedena dvojice lomítek, najde dotaz všechny.
</ol>

<!--
<p>What&#8217;s that? You say you want the power of the <code>findall()</code> method, but you want to work with an iterator instead of building a complete list? ElementTree can do that too.

<pre class=screen>
# continuing from the previous example
<a><samp class=p>>>> </samp><kbd class=pp>it = tree.getiterator('{http://www.w3.org/2005/Atom}link')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>next(it)</kbd>                                                    <span class=u>&#x2461;</span></a>
<samp>&lt;Element {http://www.w3.org/2005/Atom}link at 122f1b0></samp>
<samp class=p>>>> </samp><kbd class=pp>next(it)</kbd>
<samp>&lt;Element {http://www.w3.org/2005/Atom}link at 122f1e0></samp>
<samp class=p>>>> </samp><kbd class=pp>next(it)</kbd>
<samp>&lt;Element {http://www.w3.org/2005/Atom}link at 122f210></samp>
<samp class=p>>>> </samp><kbd class=pp>next(it)</kbd>
<samp>&lt;Element {http://www.w3.org/2005/Atom}link at 122f1b0></samp>
<samp class=p>>>> </samp><kbd class=pp>next(it)</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
StopIteration</samp></pre>
<ol>
<li>The <code>getiterator()</code> method can take zero or one arguments. If called with no arguments, it returns an iterator that spits out every element and child element in the entire document. Or, as shown here, you can call it with an element name in standard ElementTree format. This returns an iterator that spits out only elements of that name.
<li>Repeatedly calling the <code>next()</code> function with this iterator will eventually return every element of the document that matches the query you passed to the <code>getiterator()</code> method.
</ol>
-->

<p>Celkově vzato je metoda <code>findall()</code> objektu třídy ElementTree velmi mocným nástrojem, ale dotazovací jazyk může přinést pár překvapení. Oficiálně se o něm píše jako o „<a href="http://effbot.org/zone/element-xpath.htm">omezené podpoře výrazů XPath</a>”. <a href="http://www.w3.org/TR/xpath">XPath</a> je W3C standardem pro dotazování v <abbr>XML</abbr> dokumentech. Dotazovací jazyk implementovaný třídou ElementTree se XPath podobá do té míry, že se hodí pro základní vyhledávání. Ale pokud už znáte XPath, mohou vás rozdíly rozčilovat. Teď se podíváme na <abbr>XML</abbr> knihovnu třetí strany, která rozšiřuje aplikační rozhraní ElementTree o plnou podporu XPath.

<p class=a>&#x2042;

<h2 id=xml-xml-lxml>Lxml jde ještě dál</h2>

<p><a href="http://codespeak.net/lxml/"><code>lxml</code></a> je open source knihovna třetí strany, která je vybudována nad populárním <a href="http://www.xmlsoft.org/">parserem libxml2</a>. Poskytuje aplikační rozhraní, které je 100% slučitelné s ElementTree a rozšiřuje ho o plnou podporu XPath 1.0 a o pár dalších vylepšení. K dispozici jsou <a href="http://pypi.python.org/pypi/lxml/">instalátory pro Windows</a>. Uživatelé Linuxu by měli zkusit nainstalovat předkompilovaný binární tvar z archivů prostřednictvím nástrojů příslušné distribuce, jako je třeba <code>yum</code> nebo <code>apt-get</code>. Pokud by to nešlo, museli byste <a href="http://codespeak.net/lxml/installation.html"><code>lxml</code> nainstalovat ručně</a>.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>from lxml import etree</kbd>                   <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>tree = etree.parse('examples/feed.xml')</kbd>  <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>root = tree.getroot()</kbd>                    <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>root.findall('{http://www.w3.org/2005/Atom}entry')</kbd>  <span class=u>&#x2463;</span></a>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}entry at e2b4e0>,
 &lt;Element {http://www.w3.org/2005/Atom}entry at e2b510>,
 &lt;Element {http://www.w3.org/2005/Atom}entry at e2b540>]</samp></pre>
<ol>
<li>Jakmile <code>lxml</code> naimportujeme, máme k dispozici stejné aplikační rozhraní jako u zabudované knihovny ElementTree.
<li>Funkce <code>parse()</code> &mdash; stejná jako u ElementTree.
<li>Metoda <code>getroot()</code> &mdash; také stejná.
<li>Metoda <code>findall()</code> &mdash; naprosto stejná.
</ol>

<p>Pro velké <abbr>XML</abbr> dokumenty je <code>lxml</code> výrazně rychlejší než zabudovaná knihovna ElementTree. Pokud používáte pouze aplikační rozhraní ElementTree a chcete používat nejrychlejší dostupnou implementaci, můžete vyzkoušet naimportovat <code>lxml</code> se záchranou v podobě zabudované ElementTree.

<pre class='nd pp'><code>try:
    from lxml import etree
except ImportError:
    import xml.etree.ElementTree as etree</code></pre>

<p>Ale <code>lxml</code> je víc než pouhá rychlejší podoba ElementTree. Její implementace metody <code>findall()</code> podporuje komplikovanější výrazy.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import lxml.etree</kbd>                                                                   <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>tree = lxml.etree.parse('examples/feed.xml')</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>tree.findall('//{http://www.w3.org/2005/Atom}*[@href]')</kbd>                             <span class=u>&#x2461;</span></a>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}link at eeb8a0>,
 &lt;Element {http://www.w3.org/2005/Atom}link at eeb990>,
 &lt;Element {http://www.w3.org/2005/Atom}link at eeb960>,
 &lt;Element {http://www.w3.org/2005/Atom}link at eeb9c0>]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>tree.findall("//{http://www.w3.org/2005/Atom}*[@href='http://diveintomark.org/']")</kbd>  <span class=u>&#x2462;</span></a>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}link at eeb930>]</samp>
<samp class=p>>>> </samp><kbd class=pp>NS = '{http://www.w3.org/2005/Atom}'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>tree.findall('//{NS}author[{NS}uri]'.format(NS=NS))</kbd>                                 <span class=u>&#x2463;</span></a>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}author at eeba80>,
 &lt;Element {http://www.w3.org/2005/Atom}author at eebba0>]</samp></pre>
<ol>
<li>V tomto příkladu provedeme <code>import lxml.etree</code>. Chceme zde zdůraznit, že jde o vlastnosti specifické pro <code>lxml</code> (takže nenapíšeme, dejme tomu, <code>from lxml import etree</code>).
<li>Tento dotaz najde všechny elementy z prostoru jmen Atom, které mají atribut <code>href</code> &mdash; ať už se nacházejí v dokumentu kdekoliv. Dvě lomítka (<code>//</code>) na začátku dotazu znamenají „elementy nacházející se kdekoliv (ne jenom potomci nebo kořenový element)“. <code>{http://www.w3.org/2005/Atom}</code> znamená „jen elementy z prostoru jmen Atom“. <code>*</code> znamená „elementy s libovolným lokálním jménem“. A <code>[@href]</code> znamená, „které mají atribut <code>href</code>”.
<li>Tento dotaz najde všechny elementy z Atom, které mají <code>href</code> s hodnotou <code>http://diveintomark.org/</code>.
<li>S využitím jednoduchého <a href=#strings-formatting-strings>formátovacího řetězce</a> (protože jinak by se tyto složené dotazy staly neúnosně dlouhé) získáme dotaz, který v prostoru Atom hledá elementy <code>author</code>, které mají mezi svými potomky element <code>uri</code>. Vrátí se jen dva elementy <code>author</code> &mdash; jen z prvního a druhého elementu <code>entry</code>. Element <code>author</code> v posledním <code>entry</code> obsahuje jen <code>name</code> &mdash; <code>uri</code> mu chybí.
</ol>

<p>Ještě toho nemáte dost? Do <code>lxml</code> je zahrnuta i podpora pro libovolné výrazy XPath 1.0. Nebudu se do hloubky zabývat syntaxí XPath. To by samo o sobě vydalo na celou knihu! Ale ukážeme si, jakým způsobem je podpora XPath do <code>lxml</code> zahrnuta.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import lxml.etree</kbd>
<samp class=p>>>> </samp><kbd class=pp>tree = lxml.etree.parse('examples/feed.xml')</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>NSMAP = {'atom': 'http://www.w3.org/2005/Atom'}</kbd>                    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>entries = tree.xpath("//atom:category[@term='accessibility']/..",</kbd>  <span class=u>&#x2461;</span></a>
<samp class=p>... </samp><kbd class=pp>    namespaces=NSMAP)</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>entries</kbd>                                                            <span class=u>&#x2462;</span></a>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}entry at e2b630>]</samp>
<samp class=p>>>> </samp><kbd class=pp>entry = entries[0]</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>entry.xpath('./atom:title/text()', namespaces=NSMAP)</kbd>               <span class=u>&#x2463;</span></a>
<samp class=pp>['Accessibility is a harsh mistress']</samp></pre>
<ol>
<li>Abychom mohli provádět dotazy XPath nad elementy z nějakého prostoru jmen, musíme definovat zobrazení prefixu na prostor jmen. Je to prostě pythonovský slovník.
<li>Tady máme dotaz v XPath. Výraz v XPath hledá elementy <code>category</code> (z prostoru jmen Atom), které obsahují atribut <code>term</code> s hodnotou <code>accessibility</code>. To ale ještě není výsledkem dotazu. Podívejte se na úplný konec řetězce dotazu. Všimli jste si úseku <code>/..</code>? Ten znamená „a vrať k právě nalezenému elementu <code>category</code> jeho rodičovský element“. Takže tento jediný dotaz XPath najde všechny elementy potomky <code>&lt;category term='accessibility'&gt;</code>.
<li>Funkce <code>xpath()</code> vrací seznam objektů třídy ElementTree. V tomto dokumentu se nachází jediný záznam obsahující <code>category</code>, jehož <code>term</code> má hodnotu <code>accessibility</code>.
<li>XPath výraz nevrací vždycky seznam elementů. <abbr>DOM</abbr> (<a href="http://cs.wikipedia.org/wiki/Document_Object_Model">Document Object Model</a>; objektový model dokumentu), který vznikl na základě zpracování (parsing) <abbr>XML</abbr> dokumentu, neobsahuje z technického hlediska elementy, ale <i>uzly</i>. Uzly mohou (podle typu) reprezentovat elementy, atributy nebo dokonce textový obsah. Výsledkem XPath dotazu je seznam uzlů. Tento dotaz vrací seznam textových uzlů: textový obsah (<code>text()</code>) elementu <code>title</code> (<code>atom:title</code>), který je potomkem aktuálního elementu (<code>./</code>).
</ol>

<p class=a>&#x2042;

<h2 id=xml-xml-generate>Generování XML</h2>

<p>Podpora <abbr>XML</abbr> v Pythonu není omezena na analýzu (parsing) existujících dokumentů. Můžeme také vytvářet <abbr>XML</abbr> dokumenty zcela od základů.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import xml.etree.ElementTree as etree</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>new_feed = etree.Element('{http://www.w3.org/2005/Atom}feed',</kbd>     <span class=u>&#x2460;</span></a>
<a><samp class=p>... </samp><kbd class=pp>    attrib={'{http://www.w3.org/XML/1998/namespace}lang': 'en'})</kbd>  <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>print(etree.tostring(new_feed))</kbd>                                   <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;ns0:feed xmlns:ns0='http://www.w3.org/2005/Atom' xml:lang='en'/></samp></pre>
<ol>
<li>Nový element vznikne vytvořením instance třídy <code>Element</code>. Jako první argument předáváme jméno elementu (prostor jmen + lokální jméno). Tímto příkazem se vytvoří element <code>feed</code> v prostoru jmen Atom. To bude kořenový element našeho nového dokumentu.
<li>Atributy k nově vytvořenému elementu přidáme předáním slovníku se jmény a hodnotami atributů argumentem <var>attrib</var>. Poznamenejme, že jména atributů musí být uvedena ve tvaru pro ElementTree &mdash; <code>{<var>prostor jmen</var>}<var>lokální jméno</var></code>.
<li>Kterýkoliv element (a jeho potomky) můžeme kdykoliv převést na řetězec (serializovat) voláním funkce <code>tostring()</code> z ElementTree.
</ol>

<p>Jste výsledkem serializace překvapeni? Způsob, jakým ElementTree serializuje <abbr>XML</abbr> elementy s prostorem jmen, je sice z technického hlediska přesný, ale není optimální. Vzorový <abbr>XML</abbr> dokument ze začátku této kapitoly definoval <i>výchozí prostor jmen</i> (<code>xmlns='http://www.w3.org/2005/Atom'</code>). U dokumentů, kde se všechny elementy nacházejí ve stejném prostoru jmen&nbsp;&mdash;&nbsp;jako u Atom feeds&nbsp;&mdash;&nbsp;je definice výchozího prostoru jmen užitečná, protože ji uvedeme jen jednou a elementy pak můžeme deklarovat jen jejich lokálním jménem (<code>&lt;feed&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;entry&gt;</code>). Pokud nepotřebujeme deklarovat elementy z jiného prostoru jmen, nemusíme prefixy uvádět.

<p><abbr>XML</abbr> parser „nevidí“ mezi <abbr>XML</abbr> dokumentem s výchozím prostorem jmen a mezi <abbr>XML</abbr> dokumentem s prefixovaným prostorem jmen žádný rozdíl. Výsledný <abbr>DOM</abbr> s následující serializací:

<pre class='nd pp'><code>&lt;ns0:feed xmlns:ns0='http://www.w3.org/2005/Atom' xml:lang='en'/></code></pre>

<p>je totožný s <abbr>DOM</abbr> s touto serializací:

<pre class='nd pp'><code>&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'/></code></pre>

<p>Jediný praktický rozdíl spočívá v tom, že druhá serializace je o pár znaků kratší. Kdybychom chtěli celý vzorek našeho obsahu (feed) přepsat s prefixem <code>ns0:</code> v každé počáteční a koncové značce, přidalo by to 4 znaky na každou značku × 79 značek + 4 znaky pro vlastní deklaraci prostoru jmen, to je celkem 320 znaků. Za předpokladu, že používáme <a href=#strings-byte-arrays>kódování UTF-8</a>, to je 320 bajtů navíc. (Po zabalení pomocí gzip se rozdíl zmenší na 21 bajtů, ale 21 bajtů je pořád 21 bajtů.) Pro vás to možná nic neznamená, ale pro něco takového jako je Atom feed, který může být stahován několikatisíckrát, kdykoliv dojde ke změně, se může úspora pár bajtů na dotaz rychle nasčítat.

<p>Zabudovaná knihovna ElementTree tak jemné ovládání serializace elementů z prostoru jmen nenabízí, ale <code>lxml</code> ano.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import lxml.etree</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>NSMAP = {None: 'http://www.w3.org/2005/Atom'}</kbd>                     <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>new_feed = lxml.etree.Element('feed', nsmap=NSMAP)</kbd>                <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>print(lxml.etree.tounicode(new_feed))</kbd>                             <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;feed xmlns='http://www.w3.org/2005/Atom'/></samp>
<a><samp class=p>>>> </samp><kbd class=pp>new_feed.set('{http://www.w3.org/XML/1998/namespace}lang', 'en')</kbd>  <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>print(lxml.etree.tounicode(new_feed))</kbd>
<samp class=pp>&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'/></samp></pre>
<ol>
<li>Začneme tím, že definujeme zobrazení prostorů jmen v podobě slovníku. Hodnotami slovníku jsou prostory jmen, klíči jsou požadované prefixy. Použitím <code>None</code> v roli klíče definujeme výchozí prostor jmen.
<li>Když teď při vytváření elementu předáme slovník argumentem <var>nsmap</var> (je specifický pro <code>lxml</code>), bude <code>lxml</code> respektovat prefixy prostorů jmen, které jsme definovali.
<li>Tato serializace podle očekávání definuje prostor jmen Atom jako výchozí prostor jmen a deklaruje element <code>feed</code> bez prefixu prostoru jmen.
<li>Jejda! Zapomněli jsme přidat atribut <code>xml:lang</code>. Libovolný atribut můžeme k libovolnému elementu přidat metodou <code>set()</code>. Přebírá dva argumenty: jméno atributu ve formátu pro ElementTree a hodnotu atributu. (Tato metoda není specifická pro <code>lxml</code>. Jedinou částí specifickou pro <code>lxml</code> byl v tomto příkladu argument <var>nsmap</var>, který v serializovaném výstupu ovládá prefixování prostorem jmen.)
</ol>

<p>Může se v <abbr>XML</abbr> dokumentech vyskytovat jen jeden element na dokument? Samozřejmě že ne. Snadno můžeme vytvořit i elementy potomků.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>title = lxml.etree.SubElement(new_feed, 'title',</kbd>          <span class=u>&#x2460;</span></a>
<a><samp class=p>... </samp><kbd class=pp>    attrib={'type':'html'})</kbd>                               <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>print(lxml.etree.tounicode(new_feed))</kbd>                     <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'>&lt;title type='html'/>&lt;/feed></samp>
<a><samp class=p>>>> </samp><kbd class=pp>title.text = 'dive into &amp;hellip;'</kbd>                         <span class=u>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>print(lxml.etree.tounicode(new_feed))</kbd>                     <span class=u>&#x2464;</span></a>
<samp class=pp>&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'>&lt;title type='html'>dive into &amp;amp;hellip;&lt;/title>&lt;/feed></samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(lxml.etree.tounicode(new_feed, pretty_print=True))</kbd>  <span class=u>&#x2465;</span></a>
<samp class=pp>&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'>
&lt;title type='html'>dive into&amp;amp;hellip;&lt;/title>
&lt;/feed></samp></pre>
<ol>
<li>Při vytváření dětského elementu k existujícímu elementu vytváříme instanci třídy <code>SubElement</code>. Jedinými povinnými argumenty jsou zde rodičovský element (v našem případě <var>new_feed</var>) a jméno nového elementu. Protože má dětský element dědit mapování (zobrazení) prostoru jmen od svého rodiče, nemusíme zde prostoj jmen nebo prefix znovu deklarovat.
<li>Můžeme také předat slovník atributů. Klíče hrají roli jmen atributů, hodnoty jsou hodnotami atributů.
<li>Podle očekávání byl v prostoru jmen Atom vytvořen element <code>title</code> a byl vložen jako potomek do elementu <code>feed</code>. Protože element <code>title</code> neobsahoval žádný text a neměl své vlastní potomky, serializuje jej <code>lxml</code> jako prázdný element (zkrácený zápis s <code>/&gt;</code> na konci).
<li>Pokud chceme elementu nastavit textový obsah, přiřadíme jej jednoduše do vlastnosti <code>.text</code>.
<li>Teď už se element <code>title</code> serializuje i se svým textovým obsahem. Každý text, který obsahuje znaky menší než nebo ampersand, musí být při serializaci převeden na speciální posloupnosti. <code>lxml</code> se o to postará automaticky.
<li>Při serializaci můžeme předepsat také „tisk v pěkném tvaru“. Za koncové značky a za počáteční značky elementů, které obsahují potomky, ale ne text, se vloží přechody na nový řádek. Vyjádřeno technickými pojmy, <code>lxml</code> přidá „nevýznamné bílé znaky“ za účelem zvýšení čitelnosti výstupu.
</ol>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Možná byste se chtěli mrknout také na <a href="http://github.com/galvez/xmlwitch/tree/master">xmlwitch</a>, což je další knihovna třetí strany pro generování <abbr>XML</abbr>. Aby byl kód pro generování <abbr>XML</abbr> čitelnější, široce se v ní využívá <a href=#special-method-names-context-managers>příkazu <code>with</code></a>.
</blockquote>

<p class=a>&#x2042;

<h2 id=xml-xml-custom-parser>Analýza porušeného XML</h2>

<p>Specifikace <abbr>XML</abbr> nařizuje, aby všechny <abbr>XML</abbr> parsery, které chtějí specifikaci vyhovět, používaly „drakonickou obsluhu chyb“. To znamená, že musí s výrazným efektem zastavit, jakmile v <abbr>XML</abbr> dokumentu narazí na jakýkoliv prohřešek proti korektní podobě. Prohřešky proti správné formě zahrnují nespárované počáteční a koncové značky, nedefinované entity (speciální posloupnosti pro znaky), nelegální Unicode znaky a řadu dalších esoterických pravidel. To je v příkrém kontrastu s jinými běžnými formáty, jako je například <abbr>HTML</abbr>. Váš prohlížeč nepřestane zobrazovat stránku, ve které zapomenete uvést uzavírací značku <abbr>HTML</abbr> nebo když zapomenete zapsat ampersand v atributu jako speciální sekvenci. (Běžným omylem je, že <abbr>HTML</abbr> nemá definováno ošetření chyb. <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#parsing">Ošetřování chyb v <abbr>HTML</abbr></a> je ve skutečnosti definováno velmi dobře, ale je výrazně komplikovanější, než <a href=#unit-testing-romantest2>„zastav a začni hořet“</a> v okamžiku, kdy se narazí na první chybu.)

<p>Někteří lidé věří (a já patřím mezi ně), že požadavek na drakonickou obsluhu chyb byl ze strany tvůrců <abbr>XML</abbr> nepřiměřený. Nechápejte mě špatně. Zjednodušení pravidel pro ošetření chyb má své kouzlo. Ale v praxi je koncepce „korektnosti formátu“ ošidnější, než to vypadá &mdash; zvlášť u <abbr>XML</abbr> (jako je Atom feeds), které jsou zveřejňovány na webu a zpřístupňovány protokolem <abbr>HTTP</abbr>. I přes vyzrálost formátu <abbr>XML</abbr>, který standardizoval drakonická pravidla pro ošetřování chyb v roce 1997, průzkumy stále ukazují, že významná část dokumentů Atom feeds nacházejících se na webu je zamořena chybami formátu.

<p>Takže mám jak teoretické, tak praktické důvody ke zpracování (parse) <abbr>XML</abbr> dokumentů „za každou cenu“. To znamená, že <em>nechci</em> s kraválem zastavit při prvním prohřešku proti korektnosti formátu. Pokud zjistíte, že to cítíte podobně, může vám pomoci <code>lxml</code>.

<p>Tady máme kousek porušeného <abbr>XML</abbr> dokumentu. Prohřešky proti korektnosti jsem zvýraznil.

<pre class='nd pp'><code>&lt;?xml version='1.0' encoding='utf-8'?>
&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'>
  &lt;title>dive into <mark>&amp;hellip;</mark>&lt;/title>
...
&lt;/feed></code></pre>

<p>Tak tohle je chyba, protože entita <code>&amp;hellip;</code> není v <abbr>XML</abbr> definována. (Je definována v <abbr>HTML</abbr>.) Pokud se takto porušený obsah (feed) pokusíte zpracovat (parse), <code>lxml</code> se zakucká na nedefinované entitě.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import lxml.etree</kbd>
<samp class=p>>>> </samp><kbd class=pp>tree = lxml.etree.parse('examples/feed-broken.xml')</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "lxml.etree.pyx", line 2693, in lxml.etree.parse (src/lxml/lxml.etree.c:52591)
  File "parser.pxi", line 1478, in lxml.etree._parseDocument (src/lxml/lxml.etree.c:75665)
  File "parser.pxi", line 1507, in lxml.etree._parseDocumentFromURL (src/lxml/lxml.etree.c:75993)
  File "parser.pxi", line 1407, in lxml.etree._parseDocFromFile (src/lxml/lxml.etree.c:75002)
  File "parser.pxi", line 965, in lxml.etree._BaseParser._parseDocFromFile (src/lxml/lxml.etree.c:72023)
  File "parser.pxi", line 539, in lxml.etree._ParserContext._handleParseResultDoc (src/lxml/lxml.etree.c:67830)
  File "parser.pxi", line 625, in lxml.etree._handleParseResult (src/lxml/lxml.etree.c:68877)
  File "parser.pxi", line 565, in lxml.etree._raiseParseError (src/lxml/lxml.etree.c:68125)
lxml.etree.XMLSyntaxError: Entity 'hellip' not defined, line 3, column 28</samp></pre>

<p>Abychom byli schopni takto porušený <abbr>XML</abbr> dokument zpracovat (navzdory prohřešku proti korektnímu formátu), musíme vytvořit vlastní <abbr>XML</abbr> parser.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>parser = lxml.etree.XMLParser(recover=True)</kbd>                  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>tree = lxml.etree.parse('examples/feed-broken.xml', parser)</kbd>  <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>parser.error_log</kbd>                                             <span class=u>&#x2462;</span></a>
<samp>examples/feed-broken.xml:3:28:FATAL:PARSER:ERR_UNDECLARED_ENTITY: Entity 'hellip' not defined</samp>
<samp class=p>>>> </samp><kbd class=pp>tree.findall('{http://www.w3.org/2005/Atom}title')</kbd>
<samp>[&lt;Element {http://www.w3.org/2005/Atom}title at ead510>]</samp>
<samp class=p>>>> </samp><kbd class=pp>title = tree.findall('{http://www.w3.org/2005/Atom}title')[0]</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>title.text</kbd>                                                   <span class=u>&#x2463;</span></a>
<samp class=pp>'dive into '</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(lxml.etree.tounicode(tree.getroot()))</kbd>                  <span class=u>&#x2464;</span></a>
<samp class=pp>&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'>
  &lt;title>dive into &lt;/title>
.
. [rest of serialization snipped for brevity]
.</samp></pre>
<ol>
<li>Uživatelský parser (syntaktický analyzátor) vznikne vytvořením instance třídy <code>lxml.etree.XMLParser</code>. Lze jí předat <a href="http://codespeak.net/lxml/parsing.html#parser-options">celou řadu pojmenovaných argumentů</a>. Nás momentálně zajímá argument <var>recover</var>. Pokud jej nastavíme na hodnotu <code>True</code>, <abbr>XML</abbr> parser udělá, co je v jeho silách, aby se z chyb proti korektnímu formátu „zotavil“.
<li>Náš <abbr>XML</abbr> dokument zpracujeme pomocí uživatelského parseru tak, že objekt <var>parser</var> předáme funkci <code>parse()</code> jako druhý argument. Všimněte si, že <code>lxml</code> kvůli nedefinované entitě <code>&amp;hellip;</code> nevyvolal žádnou výjimku.
<li>Syntaktický analyzátor veškeré prohřešky proti korektnímu formátu zaznamenává. (Ve skutečnosti je zaznamenává nezávisle na tom, zda jsme mu nastavili zotavovací režim po chybě nebo ne.)
<li>Protože nevěděl, co má s nedefinovanou entitou <code>&amp;hellip;</code> dělat, parser ji jednoduše vypustil. Takže textový obsah, který se nachází za elementem <code>title</code>, se změní na <code>'dive into '</code>.
<li>Jak vidíte ze serializované hodnoty, entita <code>&amp;hellip;</code> se nikam nepřesunula. Byla jednoduše vypuštěna.
</ol>

<p>Pokud používáme syntaktické analyzátory <abbr>XML</abbr> se „zotavením“, pak je nutné znovu zopakovat, že neexistuje <strong>žádná záruka vzájemné součinnosti</strong>. Jiný parser se mohl rozhodnout, že jde o entitu <code>&amp;hellip;</code> z <abbr>HTML</abbr>, a nahradí ji posloupností <code>&amp;amp;hellip;</code>. Je to „lepší“? Možná. Je to „správnější“? Ne. Oba případy jsou stejně nesprávné. Správné chování (podle specifikace <abbr>XML</abbr>) spočívá v tom, že parser <a href=#unit-testing-romantest2>„zastaví a začne hořet“</a>. Pokud jste se rozhodli, že to neuděláte, je to vaše věc.

<p class=a>&#x2042;

<h2 id=xml-furtherreading>Přečtěte si</h2>

<ul>
<li><a href="http://en.wikipedia.org/wiki/XML"><abbr>XML</abbr> na Wikipedia.org</a> (anglicky; <a href="http://cs.wikipedia.org/wiki/Extensible_Markup_Language">česky zde</a>)
<li><a href="http://docs.python.org/3.1/library/xml.etree.elementtree.html">The ElementTree <abbr>XML</abbr> API</a>
<li><a href="http://effbot.org/zone/element.htm">Elements and Element Trees</a>
<li><a href="http://effbot.org/zone/element-xpath.htm">XPath Support in ElementTree</a>
<li><a href="http://effbot.org/zone/element-iterparse.htm">The ElementTree iterparse Function</a>
<li><a href="http://codespeak.net/lxml/"><code>lxml</code></a>
<li><a href="http://codespeak.net/lxml/1.3/parsing.html">Parsing <abbr>XML</abbr> and <abbr>HTML</abbr> with <code>lxml</code></a>
<li><a href="http://codespeak.net/lxml/1.3/xpathxslt.html">XPath and <abbr>XSLT</abbr> with <code>lxml</code></a>
<li><a href="http://github.com/galvez/xmlwitch/tree/master">xmlwitch</a>
</ul>

</div>
<div id=chapter-serializing>
<h1>Serializace pythonovských objektů</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> Every Saturday since we’ve lived in this apartment, I have awakened at 6:15, poured myself a bowl of cereal, added<br>a quarter-cup of 2% milk, sat on <strong>this</strong> end of <strong>this</strong> couch, turned on BBC America, and watched Doctor Who. <span class="u">&#x275E;</span><br>(Každou sobotu, od té doby co žiji v tomto bytě, jsem vstal v 6.15, nasypal do sebe misku cereálií, přidal jsem hrnek<br>2% mléka, sedl jsem si na <strong>tento</strong> konec <strong>této</strong> pohovky, zapnul jsem BBC America a díval jsem se na Doctor Who.)<br>&mdash; Sheldon, <a href="http://en.wikiquote.org/wiki/The_Big_Bang_Theory#The_Dumpling_Paradox_.5B1.07.5D">The Big Bang Theory</a>
</blockquote>
<p>&nbsp;
<h2 id=serializing-divingin>Ponořme se</h2>
<p class=f>Myšlenka <dfn>serializace</dfn> vypadá na první pohled jednoduše. Máme datovou strukturu v paměti, kterou chceme uložit, znovu použít nebo zaslat někomu jinému. Jak bychom to udělali? Záleží to na tom, jak ji chceme uložit, jak ji chceme znovu použít a komu ji chceme poslat. Mnoho her umožňuje, abyste si při ukončení uložili stav a při příštím spuštění pokračovali od tohoto místa dál. (Ve skutečnosti to umožňuje i mnoho aplikací, které nemají s hrami nic společného.) V takovém případě musí být datová struktura, která zachycuje „váš dosavadní pokrok“, při ukončení uložena na disk a při opětném spuštění z disku načtena. Data jsou určena jen pro použití se stejným programem, který je vytvořil. Nikdy se neposílají po síti a nikdy je nečte nic jiného než program, který je vytvořil. To znamená, že záležitost součinnosti se omezuje pouze na to, aby byla následující verze programu schopna načíst data zapsaná předchozími verzemi.

<p>Pro tyto případy se ideálně hodí modul <code>pickle</code>. Je součástí pythonovské standardní knihovny, takže je kdykoliv k dispozici. Je rychlý. Jeho větší část je napsána v jazyce C, stejně jako vlastní interpret Pythonu. Dokáže uložit libovolně složité pythonovské datové struktury.

<p>Co vlastně modul <code>pickle</code> dokáže uložit?

<ul>
<li>Všechny Pythonem podporované <a href=#chapter-native-datatypes>přirozené datové typy</a>: boolean, celá i reálná čísla, komplexní čísla, řetězce, objekty typu <code>bytes</code>, pole bajtů a <code>None</code>.
<li>Seznamy, n-tice, slovníky a množiny, které obsahují libovolnou kombinaci přirozených datových typů.
<li>Seznamy, n-tice, slovníky a množiny, které obsahují libovolnou kombinaci seznamů, n-tic, slovníků a množin, které obsahují libovolnou kombinaci přirozených datových typů (a tak dále až do <a title="sys.getrecursionlimit()" href="http://docs.python.org/3.1/library/sys.html#sys.getrecursionlimit">maximální hloubky zanoření, kterou Python podporuje</a>).
<li>Funkce, třídy a instance tříd (s upozorněním na určitá nebezpečí).
</ul>

<p>A pokud se vám to zdá málo, modul <code>pickle</code> je navíc rozšiřitelný. Pokud vás možnost rozšiřitelnosti zajímá, podívejte se na odkazy v podkapitole <a href=#serializing-furtherreading>Přečtěte si</a> na konci kapitoly.

<h3 id=serializing-administrivia>Stručná poznámka k příkladům v této kapitole</h3>

<p>Tato kapitola vypráví příběh s dvěma pythonovskými shelly. Všechny příklady v kapitole jsou částí jedné linie příběhu. Během předvádění modulů <code>pickle</code> a <code>json</code> budeme přecházet z jednoho pythonovského shellu do druhého.

<p>Abychom oba od sebe poznali, otevřete jeden pythonovský shell a definujte následující proměnnou:

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>shell = 1</kbd></pre>

<p>Okno nechejte otevřené. Teď otevřete druhý pythonovský shell a definujte proměnnou:

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>shell = 2</kbd></pre>

<p>Během kapitoly budeme používat proměnnou <code>shell</code> k indikaci toho, který pythonovský shell se u každého příkladu používá.

<p class=a>&#x2042;

<h2 id=serializing-dump>Uložení dat do „pickle-souboru“</h2>

<p>Modul <code>pickle</code> pracuje s datovými strukturami. Jednu takovou si připravíme.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>shell</kbd>                                                                                              <span class=u>&#x2460;</span></a>
<samp class=pp>1</samp>
<a><samp class=p>>>> </samp><kbd class=pp>entry = {}</kbd>                                                                                         <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>entry['title'] = 'Dive into history, 2009 edition'</kbd>
<samp class=p>>>> </samp><kbd class=pp>entry['article_link'] = 'http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'</kbd>
<samp class=p>>>> </samp><kbd class=pp>entry['comments_link'] = None</kbd>
<samp class=p>>>> </samp><kbd class=pp>entry['internal_id'] = b'\xDE\xD5\xB4\xF8'</kbd>
<samp class=p>>>> </samp><kbd class=pp>entry['tags'] = ('diveintopython', 'docbook', 'html')</kbd>
<samp class=p>>>> </samp><kbd class=pp>entry['published'] = True</kbd>
<samp class=p>>>> </samp><kbd class=pp>import time</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>entry['published_date'] = time.strptime('Fri Mar 27 22:20:42 2009')</kbd>                                <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>entry['published_date']</kbd>
<samp class=pp>time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1)</samp></pre>
<ol>
<li>Budeme pracovat v pythonovském shellu č. 1.
<li>Základní myšlenka spočívá ve vytvoření pythonovského slovníku, který reprezentuje něco užitečného, jako například <a href=#xml-xml-structure>záznam v Atom feed</a>. Ale současně by měl obsahovat několik různých typů dat, abychom mohli modul <code>pickle</code> předvést. Nestudujte uvedené hodnoty zbytečně podrobně.
<li>Modul <code>time</code> definuje datovou strukturu (<code>struct_time</code>), která se používá k reprezentaci času (s přesností na milisekundy), a funkce, které s touto strukturou manipulují. Funkce <code>strptime()</code> přebírá formátovaný řetězec a převádí jej do podoby <code>struct_time</code>. Tento řetězec je ve výchozím tvaru, ale můžete jej ovlivnit formátovacími značkami. Podrobnosti hledejte <a href="http://docs.python.org/3.1/library/time.html">v dokumentaci k modulu <code>time</code></a>.
</ol>

<p>Takže tu máme krásně vypadající pythonovský slovník. Uložme jej do souboru.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>shell</kbd>                                    <span class=u>&#x2460;</span></a>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd class=pp>import pickle</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>with open('entry.pickle', 'wb') as f:</kbd>    <span class=u>&#x2461;</span></a>
<a><samp class=p>... </samp><kbd class=pp>    pickle.dump(entry, f)</kbd>                <span class=u>&#x2462;</span></a>
<samp class=p>... </samp></pre>
<ol>
<li>Pořád se nacházíme v pythonovském shellu č. 1.
<li>K otevření souboru použijeme funkci <code>open()</code>. Režim souboru nastavíme na <code>'wb'</code>, abychom jej otevřeli pro zápis <a href=#files-binary>v binárním režimu</a>. Zabalíme jej do <a href=#files-with>příkazu <code>with</code></a>, abychom zajistili, že se po dokončení prací sám zavře.
<li>Funkce <code>dump()</code> z modulu <code>pickle</code> přebírá pythonovskou serializovatelnou datovou strukturu, serializuje ji do binárního podoby (je specifická pro Python a používá poslední verzi protokolu pro pickle) a uloží ji do otevřeného souboru.
</ol>

<p>Poslední věta je velmi důležitá.

<ul>
<li>Modul <code>pickle</code> přebírá pythonovskou datovou strukturu a uloží ji do souboru.
<li>Aby to mohl udělat, <i>serializuje</i> datovou strukturu s využitím datového formátu zvaného „pickle protokol“. (Poznámka překladatele: Miluju anglicky mluvící tvůrce, kteří dávají konstrukcím a mechanismům „roztomilá“ jména. Pravděpodobně základním významem anglického pickle je „nálev“ a má také řadu dalších významů. Jenže zkuste to napasovat na český text věnovaný programovacímu jazyku. Jediné, co mi spolehlivě přichází na mysl, jsou úryvky písničky... „Kujme pikle, pikle kujme, spekulujme, intrikujme, lepšího nic není nad pořádný piklení.“ Kdo neví, gůůůglí.)
<li>Pickle protokol je specifický pro Python. Žádná záruka mezijazykové kompatibility neexistuje. Pravděpodobně není možné, abyste vzali soubor <code>entry.pickle</code>, který jsme zrovna vytvořili, a udělali s ním něco rozumného v Perlu, v <abbr>PHP</abbr>, v Javě nebo v nějakém jiném jazyce.
<li>Modul <code>pickle</code> nedokáže serializovat každou pythonovskou datovou strukturu. Pickle protokol se několikrát změnil s tím, jak byly do jazyka Python přidávány nové datové typy. Ale některá omezení přetrvávají.
<li>Výsledkem těchto změn je i to, že neexistuje žádná záruka kompatibility dokonce ani mezi různými verzemi Pythonu. Novější verze Pythonu podporují starší serializační formáty, ale starší verze Pythonu nepodporují nové formáty (protože nepodporují novější datové typy).
<li>Pokud neurčíte jinak, budou funkce z modulu <code>pickle</code> používat poslední verze pickle protokolu. Tím je zajištěna maximální pružnost z hlediska typů serializovatelných dat, ale také to znamená, že výsledný soubor nebude čitelný staršími verzemi Pythonu, které poslední verzi pickle protokolu nepodporují.
<li>Poslední verze pickle protokolu používá binární formát. Ujistěte se, že soubory pro „piklení“ otvíráte <a href=#files-binary>v binárním režimu</a>. V opačném případě dojde během zápisu k porušení dat.
</ul>

<p class=a>&#x2042;

<h2 id=serializing-load>Načítání dat z „pickle souboru“</h2>

<p>Teď se přepneme do druhého pythonovského shellu&nbsp;&mdash;&nbsp;tj. do toho, ve kterém jsme nevytvářeli slovník <code>entry</code>.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>shell</kbd>                                    <span class=u>&#x2460;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>entry</kbd>                                    <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
NameError: name 'entry' is not defined</samp>
<samp class=p>>>> </samp><kbd class=pp>import pickle</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>with open('entry.pickle', 'rb') as f:</kbd>    <span class=u>&#x2462;</span></a>
<a><samp class=p>... </samp><kbd class=pp>    entry = pickle.load(f)</kbd>               <span class=u>&#x2463;</span></a>
<samp class=p>... </samp>
<a><samp class=p>>>> </samp><kbd class=pp>entry</kbd>                                    <span class=u>&#x2464;</span></a>
<samp class=pp>{'comments_link': None,
 'internal_id': b'\xDE\xD5\xB4\xF8',
 'title': 'Dive into history, 2009 edition',
 'tags': ('diveintopython', 'docbook', 'html'),
 'article_link':
 'http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition',
 'published_date': time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1),
 'published': True}</samp></pre>
<ol>
<li>Tohle je pythonovský shell č. 2.
<li>Není zde definována žádná proměnná <var>entry</var>. Proměnnou <var>entry</var> jsme definovali v pythonovském shellu č. 1, ale ten se nachází v úplně jiném prostředí a udržuje svůj vlastní stav.
<li>Otevřeme soubor <code>entry.pickle</code>, který jsme vytvořili v pythonovském shellu č. 1. Modul <code>pickle</code> používá binární datový formát, takže byste jej měli vždy otvírat v binárním režimu.
<li>Funkce <code>pickle.load()</code> přebírá <a href=#files-file-objects>objekt typu stream</a>, čte z něj serializovaná data, vytváří nový pythonovský objekt, rekonstruuje v něm serializovaná data a nový pythonovský objekt vrací.
<li>Nyní proměnná <var>entry</var> obsahuje slovník s důvěrně známými klíči a hodnotami.
</ol>

<p>Kroky <code>pickle.dump() / pickle.load()</code> vedou k vytvoření nové datové struktury, která se shoduje s původní datovou strukturou.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>shell</kbd>                                    <span class=u>&#x2460;</span></a>
<samp class=pp>1</samp>
<a><samp class=p>>>> </samp><kbd class=pp>with open('entry.pickle', 'rb') as f:</kbd>    <span class=u>&#x2461;</span></a>
<a><samp class=p>... </samp><kbd class=pp>    entry2 = pickle.load(f)</kbd>              <span class=u>&#x2462;</span></a>
<samp class=p>... </samp>
<a><samp class=p>>>> </samp><kbd class=pp>entry2 == entry</kbd>                          <span class=u>&#x2463;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>entry2 is entry</kbd>                          <span class=u>&#x2464;</span></a>
<samp class=pp>False</samp>
<a><samp class=p>>>> </samp><kbd class=pp>entry2['tags']</kbd>                           <span class=u>&#x2465;</span></a>
<samp class=pp>('diveintopython', 'docbook', 'html')</samp>
<samp class=p>>>> </samp><kbd class=pp>entry2['internal_id']</kbd>
<samp class=pp>b'\xDE\xD5\xB4\xF8'</samp></pre>
<ol>
<li>Přepneme se zpět do pythonovského shellu č. 1.
<li>Otevřeme soubor <code>entry.pickle</code>.
<li>Načteme serializovaná data do nové proměnné <var>entry2</var>.
<li>Python potvrzuje, že se slovníky <var>entry</var> a <var>entry2</var> shodují. V tomto shellu jsme strukturu <var>entry</var> vybudovali od základů. Začali jsme prázdným slovníkem a ručně jsme jednotlivým klíčům přiřadili určité hodnoty. Slovník jsme serializovali a uložili do souboru <code>entry.pickle</code>. Teď jsme serializovaná data z uvedeného souboru načetli a vytvořili jsme perfektní repliku původní datové struktury.
<li>Shodnost ale nezaměňujme za totožnost. Řekl jsem, že jsme vytvořili <em>perfektní repliku</em> původní datové struktury, což je pravda. Ale pořád je to jen kopie.
<li>Z důvodů, které budou objasněny v této kapitole později, chci upozornit na to, že klíči <code>'tags'</code> byla přiřazena hodnota v podobě n-tice a klíči <code>'internal_id'</code> byl přiřazen objekt typu <code>bytes</code>.
</ol>

<p class=a>&#x2042;

<h2 id=serializing-dumps>„Piklení“ bez souboru</h2>

<p>Serializaci pythonovských objektů přímo do souboru na disk jsme si ukázali na příkladech v předchozí podkapitole. Ale co když soubor nechceme nebo nepotřebujeme? Serializaci můžeme provést také do objektu typu <code>bytes</code>, který se nachází v paměti.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>shell</kbd>
<samp class=pp>1</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b = pickle.dumps(entry)</kbd>     <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>type(b)</kbd>                     <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;class 'bytes'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>entry3 = pickle.loads(b)</kbd>    <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>entry3 == entry</kbd>             <span class=u>&#x2463;</span></a>
<samp class=pp>True</samp></pre>
<ol>
<li>Funkce <code>pickle.dumps()</code> (všimněte si <code>'s'</code> na konci jména funkce) provádí stejnou serializaci jako funkce <code>pickle.dump()</code>. Ale nepřevezme objekt typu stream a serializovaná data nezapíše do souboru na disk. Místo toho serializovaná data jednoduše vrátí.
<li>A protože pickle protokol používá binární datový formát, vrátí funkce <code>pickle.dumps()</code> objekt typu <code>bytes</code>.
<li>Funkce <code>pickle.loads()</code> (opět si všimněte <code>'s'</code> na konci jména funkce) provádí stejnou deserializaci jako funkce <code>pickle.load()</code>. Místo čtení serializovaných dat ze souboru (přes objekt typu stream) přebírá objekt typu <code>bytes</code>, který serializovaná data obsahuje &mdash; takový, jaký vrátila funkce <code>pickle.dumps()</code>.
<li>Konečný výsledek je stejný: perfektní replika původního slovníku.
</ol>

<p class=a>&#x2042;

<h2 id=serializing-protocol-versions>Bajty a řetězce znovu zvedají své ošklivé hlavy</h2>

<p>Pickle protokol se používá už celou řadu let a vyspíval spolu s dospíváním Pythonu. V současnosti existují <a href="http://docs.python.org/3.1/library/pickle.html#data-stream-format">čtyři různé verze</a> pickle protokolu.

<ul>
<li>Python 1.x používal dva pickle protokoly: textový formát („verze 0“) a binární formát („verze 1“).
<li>Python 2.3 zavedl nový pickle protokol („verze 2“), který se vyrovnával s novou funkčností v pythonovských objektech tříd. Jeho formát je binární.
<li>Python 3.0 zavedl další pickle protokol („verze 3“) s explicitní podporou pro objekty typu <code>bytes</code> a pro pole bajtů. Jeho formát je binární.
</ul>

<p>Pozor, <a href=#strings-byte-arrays>rozdíl mezi bajty a řetězci</a> zase vystrkuje svou ošklivou hlavu. (Pokud jste dávali pozor, nejste překvapeni.) V praxi to znamená, že zatímco Python 3 umí číst data serializovaná protokolem verze 2, Python 2 neumí číst data „zapiklená“ protokolem verze 3.

<p class=a>&#x2042;

<h2 id=serializing-debugging>Ladění „pickle souborů“</h2>

<p>Jak vlastně pickle protokol vypadá? Vyskočme na chvíli z pythonovského shellu a podívejme se na soubor <code>entry.pickle</code>, který jsme vytvořili. Z prostého pohledu v tom vidíme převážně blábol.

<pre class=screen>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>ls -l entry.pickle</kbd>
<samp>-rw-r--r-- 1 you  you  358 Aug  3 13:34 entry.pickle</samp>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>cat entry.pickle</kbd>
<samp>comments_linkqNXtagsqXdiveintopythonqXdocbookqXhtmlq?qX publishedq?
XlinkXJhttp://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition
q   Xpublished_dateq
ctime
struct_time
?qRqXtitleqXDive into history, 2009 editionqu.</samp></pre>

<p>No, moc nám to tedy nepomohlo. Vidíme řetězce, ale ostatní datové typy končí jako netisknutelné (nebo přinejmenším nečitelné) znaky. Pole zjevně nejsou oddělena mezerami nebo tabulátory. Není to zrovna formát, který bychom chtěli analyzovat sami.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>shell</kbd>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd class=pp>import pickletools</kbd>
<samp class=p>>>> </samp><kbd class=pp>with open('entry.pickle', 'rb') as f:</kbd>
<samp class=p>... </samp><kbd class=pp>    pickletools.dis(f)</kbd>
<samp>    0: \x80 PROTO      3
    2: }    EMPTY_DICT
    3: q    BINPUT     0
    5: (    MARK
    6: X        BINUNICODE 'published_date'
   25: q        BINPUT     1
   27: c        GLOBAL     'time struct_time'
   45: q        BINPUT     2
   47: (        MARK
   48: M            BININT2    2009
   51: K            BININT1    3
   53: K            BININT1    27
   55: K            BININT1    22
   57: K            BININT1    20
   59: K            BININT1    42
   61: K            BININT1    4
   63: K            BININT1    86
   65: J            BININT     -1
   70: t            TUPLE      (MARK at 47)
   71: q        BINPUT     3
   73: }        EMPTY_DICT
   74: q        BINPUT     4
   76: \x86     TUPLE2
   77: q        BINPUT     5
   79: R        REDUCE
   80: q        BINPUT     6
   82: X        BINUNICODE 'comments_link'
  100: q        BINPUT     7
  102: N        NONE
  103: X        BINUNICODE 'internal_id'
  119: q        BINPUT     8
  121: C        SHORT_BINBYTES 'ÞÕ´ø'
  127: q        BINPUT     9
  129: X        BINUNICODE 'tags'
  138: q        BINPUT     10
  140: X        BINUNICODE 'diveintopython'
  159: q        BINPUT     11
  161: X        BINUNICODE 'docbook'
  173: q        BINPUT     12
  175: X        BINUNICODE 'html'
  184: q        BINPUT     13
  186: \x87     TUPLE3
  187: q        BINPUT     14
  189: X        BINUNICODE 'title'
  199: q        BINPUT     15
  201: X        BINUNICODE 'Dive into history, 2009 edition'
  237: q        BINPUT     16
  239: X        BINUNICODE 'article_link'
  256: q        BINPUT     17
  258: X        BINUNICODE 'http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'
  337: q        BINPUT     18
  339: X        BINUNICODE 'published'
  353: q        BINPUT     19
  355: \x88     NEWTRUE
  356: u        SETITEMS   (MARK at 5)
  357: .    STOP
<mark>highest protocol among opcodes = 3</mark></samp></pre>

<p>Nejzajímavější informaci v tomto reverzním překladu najdeme na posledním řádku. Obsahuje totiž verzi pickle protokolu, kterým byl tento soubor vytvořen. Pickle protokol neobsahuje žádnou explicitní značku, která by určovala verzi. Abychom verzi protokolu určili, musíme prohlížet značky („operační kódy“) uvnitř serializovaných dat a řídit se podle toho, který operační kód byl zaveden jakou verzí pickle protokolu. Přesně to dělá funkce <code>pickletools.dis()</code>. Výsledek vytiskne na posledním řádku reverzního překladu. Tady máme funkci, která vrátí číslo verze, aniž by něco tiskla:

<p class=d>[<a href="examples/pickleversion.py">stáhnout <code>pickleversion.py</code></a>]
<pre class=pp><code>import pickletools

def protocol_version(file_object):
    maxproto = -1
    for opcode, arg, pos in pickletools.genops(file_object):
        maxproto = max(maxproto, opcode.proto)
    return maxproto</code></pre>

<p>A tady ji vidíme v akci:</p>

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import pickleversion</kbd>
<samp class=p>>>> </samp><kbd class=pp>with open('entry.pickle', 'rb') as f:</kbd>
<samp class=p>... </samp><kbd class=pp>    v = pickleversion.protocol_version(f)</kbd>
<samp class=p>>>> </samp><kbd class=pp>v</kbd>
<samp class=pp>3</samp></pre>

<p class=a>&#x2042;

<h2 id=serializing-json>Serializace pythonovských objektů pro čtení z jiných jazyků</h2>

<p>Datový formát používaný modulem <code>pickle</code> je specifický pro Python. Nijak se nepokouší o kompatibilitu s jinými programovacími jazyky. Pokud je vaším cílem mezijazyková kompatibilita, pak se musíte poohlédnout po jiných serializačních formátech. Jedním z nich je <a href="http://json.org/"><abbr>JSON</abbr></a>. Zkratka „<abbr>JSON</abbr>“ znamená „JavaScript Object Notation“, ale nenechte se tím jménem zmást. <abbr>JSON</abbr> je explicitně navržen pro použití napříč různými programovacími jazyky.

<p>V Pythonu 3 je modul <code>json</code> součástí standardní knihovny. Modul <code>json</code> má (stejně jako modul <code>pickle</code>) funkce pro serializaci datových struktur, pro ukládání serializovaných dat na disk, pro načítání serializovaných dat z disku a pro deserializaci dat zpět do podoby nového pythonovského objektu. Ale najdeme zde také důležité odlišnosti. Ze všeho nejdřív uveďme, že datový formát <abbr>JSON</abbr> je textový a ne binární. Formát <abbr>JSON</abbr> a způsob kódování různých typů dat je definován v <a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>. Například booleovská hodnota je uložena buď jako pětiznakový řetězec <code>'false'</code> nebo jako čtyřznakový řetězec <code>'true'</code>. Všechny hodnoty používané v <abbr>JSON</abbr> jsou citlivé na velikost písmen.

<p>Za druhé tu máme &mdash; jako u všech textových formátů &mdash; problém s bílými znaky (whitespace). <abbr>JSON</abbr> dovoluje, aby se mezi hodnotami vyskytovalo libovolné množství bílých znaků (mezery, tabulátory, návrat vozíku CR, přechod na nový řádek LF). Tyto bílé znaky jsou nevýznamné. To znamená, že kodéry <abbr>JSON</abbr> mohou přidat bílé znaky dle vlastního uvážení. Po dekodérech <abbr>JSON</abbr> se požaduje, aby bílé znaky mezi hodnotami ignorovaly. To umožňuje, aby byla <abbr>JSON</abbr> data „pěkně naformátována“ (pretty-print). Hodnoty mohou být pěkně vnořeny do jiných hodnot při použití různých úrovní odsazení, takže data budou dobře čitelná v textovém editoru nebo ve standardním prohlížeči. V pythonovském modulu <code>json</code> najdeme volbu, která při procesu kódování zajistí „pěkné formátování“.

<p>Za třetí tu máme přetrvávající problém s kódováním znaků. <abbr>JSON</abbr> kóduje hodnoty do podoby prostého textu, ale my už víme, že <a href=#chapter-strings>nic jako „prostý text“ neexistuje</a>. <abbr>JSON</abbr> musí být uložen v kódování Unicode (v UTF-32, v UTF-16 nebo ve výchozím <abbr>UTF-8</abbr>). <a href="http://www.ietf.org/rfc/rfc4627.txt">Sekce 3 dokumentu RFC 4627</a> definuje, jak máme říct, které kódování je použito.

<p class=a>&#x2042;

<h2 id=serializing-json-dump>Uložení dat do <abbr>JSON</abbr> souboru</h2>

<p><abbr>JSON</abbr> se nápadně podobá datovým strukturám, které byste mohli ručně definovat v JavaScriptu. Není to žádná náhoda. Ve skutečnosti můžete pro „dekódování“ dat serializovaných do <abbr>JSON</abbr> použít javascriptovou funkci <code>eval()</code>. (Platí zde obvyklá <a href=#advanced-iterators-eval>výstraha o nedůvěryhodných zdrojích</a>, ale věc se má tak, že <abbr>JSON</abbr> <em>opravdu je</em> platný JavaScript.) V tomto smyslu už se vám <abbr>JSON</abbr> může zdát důvěrně známý.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>shell</kbd>
<samp class=pp>1</samp>
<a><samp class=p>>>> </samp><kbd class=pp>basic_entry = {}</kbd>                                           <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>basic_entry['id'] = 256</kbd>
<samp class=p>>>> </samp><kbd class=pp>basic_entry['title'] = 'Dive into history, 2009 edition'</kbd>
<samp class=p>>>> </samp><kbd class=pp>basic_entry['tags'] = ('diveintopython', 'docbook', 'html')</kbd>
<samp class=p>>>> </samp><kbd class=pp>basic_entry['published'] = True</kbd>
<samp class=p>>>> </samp><kbd class=pp>basic_entry['comments_link'] = None</kbd>
<samp class=p>>>> </samp><kbd class=pp>import json</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>with open('basic.json', mode='w', encoding='utf-8') as f:</kbd>  <span class=u>&#x2461;</span></a>
<a><samp class=p>... </samp><kbd class=pp>    json.dump(basic_entry, f)</kbd>                              <span class=u>&#x2462;</span></a></pre>
<ol>
<li>Místo znovupoužití existující datové struktury <var>entry</var> si teď vytvoříme novou datovou strukturu. Později si v této kapitole ukážeme, co se stane, když se do <abbr>JSON</abbr> pokusíme zakódovat složitější datovou strukturu.
<li><abbr>JSON</abbr> je textový formát, což znamená, že soubor musíme otevřít v textovém režimu a musíme určit znakové kódování. Nikdy neuděláte chybu, když použijete <abbr>UTF-8</abbr>.
<li>Modul <code>json</code> (stejně jako modul <code>pickle</code>) definuje funkci <code>dump()</code>, která přebírá pythonovskou datovou strukturu a objekt typu stream připravený pro zápis. Funkce <code>dump()</code> serializuje pythonovskou datovou strukturu a zapíše ji do objektu typu stream. Vložením volání do příkazu <code>with</code> zajistíme, že po dokončení operace bude soubor korektně uzavřen.
</ol>

<p>Takže jak vlastně výsledek serializace do <abbr>JSON</abbr> vypadá?

<pre class=screen>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>cat basic.json</kbd>
<samp>{"published": true, "tags": ["diveintopython", "docbook", "html"], "comments_link": null,
"id": 256, "title": "Dive into history, 2009 edition"}</samp></pre>

<p>Tak tohle je určitě <a href=#serializing-debugging>mnohem čitelnější než „zapiklený“ soubor</a>. Navíc <abbr>JSON</abbr> může mezi hodnotami obsahovat libovolné bílé znaky a modul <code>json</code> nabízí snadný způsob, jak toho využít. Díky tomu můžeme vytvořit ještě mnohem čitelnější <abbr>JSON</abbr> soubory.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>shell</kbd>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd class=pp>with open('basic-pretty.json', mode='w', encoding='utf-8') as f:</kbd>
<a><samp class=p>... </samp><kbd class=pp>    json.dump(basic_entry, f, <mark style="display:inline">indent=2</mark>)</kbd>                            <span class=u>&#x2460;</span></a></pre>
<ol>
<li>Pokud funkci <code>json.dump()</code> předáme parametr <var>indent</var> (tj. odsazení), může být výsledný <abbr>JSON</abbr> soubor mnohem čitelnější &mdash; za cenu zvětšení velikosti souboru. Parametr <var>indent</var> je celé číslo. 0 znamená „umísti každou hodnotu na zvláštní řádek“. Číslo větší než 0 znamená „umísti každou hodnotu na zvláštní řádek a použij tento počet mezer pro odsazování zanořených datových struktur“.
</ol>

<p>A takhle vypadá výsledek:

<pre class=screen>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>cat basic-pretty.json</kbd>
<samp>{
  "published": true,
  "tags": [
    "diveintopython",
    "docbook",
    "html"
  ],
  "comments_link": null,
  "id": 256,
  "title": "Dive into history, 2009 edition"
}</samp></pre>

<p class=a>&#x2042;

<h2 id=serializing-json-types>Zobrazení pythonovských datových typů do <abbr>JSON</abbr></h2>

<p>Protože <abbr>JSON</abbr> není určen pro Python, najdeme při zobrazování pythonovských datových typů určité nesrovnalosti. Některé z nich jsou jen rozdíly v názvech, ale dva důležité pythonovské datové typy v něm úplně chybí. Schválně, jestli si jich všimnete:

<table>
<tr><th>Poznámky
<th>JSON
<th>Python 3
<tr><th>
<td>objekt
<td><a href=#native-datatypes-dictionaries>slovník</a>
<tr><th>
<td>pole
<td><a href=#native-datatypes-lists>seznam</a>
<tr><th>
<td>řetězec
<td><a href=#strings-divingin>řetězec</a>
<tr><th>
<td>integer
<td><a href=#native-datatypes-numbers>integer</a>
<tr><th>
<td>reálné číslo
<td><a href=#native-datatypes-numbers>float</a>
<tr><th>*
<td><code>true</code>
<td><a href=#native-datatypes-booleans><code>True</code></a>
<tr><th>*
<td><code>false</code>
<td><a href=#native-datatypes-booleans><code>False</code></a>
<tr><th>*
<td><code>null</code>
<td><code><a href=#native-datatypes-none>None</a></code>
<tfoot><tr><td colspan=3>* Všechny hodnoty používané v <abbr>JSON</abbr> jsou citlivé na velikost písmen.
</table>

<p>Všimli jste si, co chybí? N-tice a bajty! <abbr>JSON</abbr> definuje typ pole, které modul <code>json</code> zobrazuje na pythonovský seznam, ale nedefinuje oddělený typ pro „zmrazená pole“ (n-tice). A ačkoliv <abbr>JSON</abbr> docela pěkně podporuje řetězce, nepodporuje objekty typu <code>bytes</code> nebo pole bajtů.

<p class=a>&#x2042;

<h2 id=serializing-json-unknown-types>Serializace datových typů, které <abbr>JSON</abbr> nepodporuje</h2>

<p>I když <abbr>JSON</abbr> nemá žádnou zabudovanou podporu pro bajty, neznamená to, že bychom objekty typu <code>bytes</code> nemohli serializovat. Modul <code>json</code> poskytuje rozšiřující rozhraní (extensibility hooks) pro kódování a dekódování neznámých datových typů. (Slovem „neznámý“ rozumějme „nedefinovaný v <abbr>JSON</abbr>“. Modul <code>json</code> zjevně pole bajtů zná, ale je svázán omezeními specifikace <abbr>JSON</abbr>.) Pokud chceme zakódovat bajty nebo jiné datové typy, které <abbr>JSON</abbr> v základu nepodporuje, musíme pro ně dodat uživatelské kodéry a dekodéry.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>shell</kbd>
<samp class=pp>1</samp>
<a><samp class=p>>>> </samp><kbd class=pp>entry</kbd>                                                 <span class=u>&#x2460;</span></a>
<samp class=pp>{'comments_link': None,
 'internal_id': b'\xDE\xD5\xB4\xF8',
 'title': 'Dive into history, 2009 edition',
 'tags': ('diveintopython', 'docbook', 'html'),
 'article_link': 'http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition',
 'published_date': time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1),
 'published': True}</samp>
<samp class=p>>>> </samp><kbd class=pp>import json</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>with open('entry.json', 'w', encoding='utf-8') as f:</kbd>  <span class=u>&#x2461;</span></a>
<a><samp class=p>... </samp><kbd class=pp>    json.dump(entry, f)</kbd>                               <span class=u>&#x2462;</span></a>
<samp class=p>... </samp>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 5, in &lt;module>
  File "C:\Python31\lib\json\__init__.py", line 178, in dump
    for chunk in iterable:
  File "C:\Python31\lib\json\encoder.py", line 408, in _iterencode
    for chunk in _iterencode_dict(o, _current_indent_level):
  File "C:\Python31\lib\json\encoder.py", line 382, in _iterencode_dict
    for chunk in chunks:
  File "C:\Python31\lib\json\encoder.py", line 416, in _iterencode
    o = _default(o)
  File "C:\Python31\lib\json\encoder.py", line 170, in default
    raise TypeError(repr(o) + " is not JSON serializable")
<mark>TypeError: b'\xDE\xD5\xB4\xF8' is not JSON serializable</mark></samp></pre>
<ol>
<li>Nastal čas k tomu, abychom se znovu podívali na datovou strukturu <var>entry</var>. Obsahuje následující: booleovskou hodnotu, hodnotu <code>None</code>, řetězec, n-tici řetězců, objekt typu <code>bytes</code> a strukturu <code>time</code>.
<li>Já vím. Říkal jsem to už dříve, ale stojí to za zopakování: <abbr>JSON</abbr> je textový formát. <abbr>JSON</abbr> soubory se musí otvírat vždy v textovém režimu a se znakovým kódováním <abbr>UTF-8</abbr>.
<li>Hmm, <em>tohle</em> není dobré. Co se to vlastně stalo?
</ol>

<p>Stalo se následující: funkce <code>json.dump()</code> se pokusila o serializaci objektu typu <code>bytes</code> s hodnotou <code>b'\xDE\xD5\xB4\xF8'</code>, ale selhala, protože v <abbr>JSON</abbr> podpora objektů typu <code>bytes</code> chybí. Pokud je ale pro nás ukládání bajtů důležité, můžeme si definovat náš vlastní „miniserializační formát“.

<p class=d>[<a href="examples/customserializer.py">stáhnout <code>customserializer.py</code></a>]
<pre class=pp><code>
<a>def to_json(python_object):                                             <span class=u>&#x2460;</span></a>
<a>    if isinstance(python_object, bytes):                                <span class=u>&#x2461;</span></a>
<a>        return {'__class__': 'bytes',
                '__value__': list(python_object)}                       <span class=u>&#x2462;</span></a>
<a>    raise TypeError(repr(python_object) + ' is not JSON serializable')  <span class=u>&#x2463;</span></a></code></pre>
<ol>
<li>Abychom definovali vlastní „miniserializační formát“ pro datový typ, který <abbr>JSON</abbr> přirozeně nepodporuje, musíme definovat funkci, která přebírá pythonovský objekt jako parametr. Tímto pythonovským objektem bude skutečný objekt, který funkce <code>json.dump()</code> není schopna sama serializovat. V našem případě je to objekt typu <code>bytes</code> s hodnotou <code>b'\xDE\xD5\xB4\xF8'</code>.
<li>Naše uživatelská serializační funkce by měla zkontrolovat typ pythonovského objektu, který jí předala funkce <code>json.dump()</code>. Pokud funkce serializuje jen jeden datový typ, není to nezbytně nutné. Na druhou stranu se tím vyjasňuje, čím se funkce zabývá. A pokud budeme později potřebovat přidat serializaci pro více datových typů, půjde to snadněji.
<li>V tomto případě jsem se rozhodl převést objekt typu <code>bytes</code> na slovník. Klíč <code>__class__</code> bude obsahovat původní datový typ (v řetězcové podobě, <code>'bytes'</code>) a klíč <code>__value__</code> bude obsahovat aktuální hodnotu. Nemůže to, samozřejmě, být objekt typu <code>bytes</code>. Celý vtip spočívá v převodu na něco, co může být serializováno v <abbr>JSON</abbr>! Objekt typu <code>bytes</code> je posloupností celých čísel, kde každé číslo nabývá hodnot z rozsahu 0&ndash;255. Pro převod objektu typu <code>bytes</code> na seznam čísel můžeme použít funkci <code>list()</code>. Takže z <code>b'\xDE\xD5\xB4\xF8'</code> se stane <code>[222, 213, 180, 248]</code>. (Počítejte! Funguje to! Bajt zapsaný šestnáctkově <code>\xDE</code> je dekadicky 222, <code>\xD5</code> je 213 a tak dále.)
<li>Tento řádek je důležitý. Datová struktura, kterou serializujete, může obsahovat typy, které nejsou ani zabudované do serializátoru <abbr>JSON</abbr> a nezvládne je ani náš uživatelský serializátor. V takovém případě musí náš uživatelský serializátor vyvolat výjimku <code>TypeError</code>, aby se funkce <code>json.dump()</code> dozvěděla, že náš uživatelský serializátor daný typ nezná.
</ol>

<p>A to je vše. Nemusíme dělat nic jiného. Konkrétně tato uživatelská serializační funkce <em>vrací pythonovský slovník</em> a ne řetězec. Nemusíme sami realizovat celou „serializaci do <abbr>JSON</abbr>“. Provedeme pouze část „konverze na podporovaný datový typ“. Funkce <code>json.dump()</code> udělá zbytek.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>shell</kbd>
<samp class=pp>1</samp>
<a><samp class=p>>>> </samp><kbd class=pp>import customserializer</kbd>                                                             <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>with open('entry.json', 'w', encoding='utf-8') as f:</kbd>                                <span class=u>&#x2461;</span></a>
<a><samp class=p>... </samp><kbd class=pp>    json.dump(entry, f, <mark style="display:inline">default=customserializer.to_json</mark>)</kbd>                           <span class=u>&#x2462;</span></a>
<samp class=p>... </samp>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 9, in &lt;module>
    json.dump(entry, f, default=customserializer.to_json)
  File "C:\Python31\lib\json\__init__.py", line 178, in dump
    for chunk in iterable:
  File "C:\Python31\lib\json\encoder.py", line 408, in _iterencode
    for chunk in _iterencode_dict(o, _current_indent_level):
  File "C:\Python31\lib\json\encoder.py", line 382, in _iterencode_dict
    for chunk in chunks:
  File "C:\Python31\lib\json\encoder.py", line 416, in _iterencode
    o = _default(o)
  File "/Users/pilgrim/diveintopython3/examples/customserializer.py", line 12, in to_json
<a>    raise TypeError(repr(python_object) + ' is not JSON serializable')                     <span class=u>&#x2463;</span></a>
TypeError: time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1) is not JSON serializable</samp></pre>
<ol>
<li>Jméno <code>customserializer</code> patří modulu, ve kterém jsme (v předchozím příkladu) definovali funkci <code>to_json()</code>.
<li>Textový režim, kódování <abbr>UTF-8</abbr> atd., atd. (Jednou na to zapomenete! Já na to taky občas zapomenu! A všechno bude fungovat správně až do chvíle, kdy se to pokazí. Ale pak se to pokazí se vší parádou.)
<li>Tohle je důležitá část. Abychom navěsili svou převodní funkci na funkci <code>json.dump()</code>, předáme ji při volání funkce <code>json.dump()</code> jako hodnotu parametru <var>default</var>. (Hurá! <a href=#your-first-python-program-everythingisanobject>V Pythonu je objektem všechno</a>.)
<li>No dobrá, ono to všechno nefunguje. Ale podívejte se na výjimku. Funkce <code>json.dump()</code> už si nestěžuje na to, že není schopna serializovat objekt typu <code>bytes</code>. Teď už si stěžuje na úplně jiný objekt &mdash; <code>time.struct_time</code>.
</ol>

<p>Mohlo by se zdát, že výskyt jiné výjimky není známkou pokroku. Jenže on opravdu je známkou pokroku! Bude stačit jedno malé pošťouchnutí a překonáme i tohle.

<pre class=pp><code>
import time

def to_json(python_object):
<a>    if isinstance(python_object, time.struct_time):          <span class=u>&#x2460;</span></a>
<a>        return {'__class__': 'time.asctime',
                '__value__': time.asctime(python_object)}    <span class=u>&#x2461;</span></a>
    if isinstance(python_object, bytes):
        return {'__class__': 'bytes',
                '__value__': list(python_object)}
    raise TypeError(repr(python_object) + ' is not JSON serializable')</code></pre>
<ol>
<li>Při rozšiřování existující funkce <code>customserializer.to_json()</code> potřebujeme zkontrolovat, zda je pythonovský objekt (s kterým má funkce <code>json.dump()</code> potíže) typu <code>time.struct_time</code>.
<li>Pokud tomu tak je, uděláme podobný převod jako v případě objektu typu <code>bytes</code>. Objekt typu <code>time.struct_time</code> převedeme na slovník, který bude obsahovat pouze hodnoty, které lze serializovat do <abbr>JSON</abbr>. V našem případě je nejsnadnější způsob převodu data a času na hodnotu serializovatelnou do <abbr>JSON</abbr> založen na převodu na řetězec pomocí funkce <code>time.asctime()</code>. Funkce <code>time.asctime()</code> převádí odporně vypadající <code>time.struct_time</code> na řetězec <code>'Fri Mar 27 22:20:42 2009'</code>.
</ol>

<p>Při použití těchto dvou uživatelských konverzí proběhne serializace celé datové struktury <var>entry</var> do <abbr>JSON</abbr> bez dalších problémů.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>shell</kbd>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd class=pp>with open('entry.json', 'w', encoding='utf-8') as f:</kbd>
<samp class=p>... </samp><kbd class=pp>    json.dump(entry, f, default=customserializer.to_json)</kbd>
<samp class=p>... </samp></pre>

<pre class=screen>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>ls -l example.json</kbd>
<samp>-rw-r--r-- 1 you  you  391 Aug  3 13:34 entry.json</samp>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>cat example.json</kbd>
<samp>{"published_date": {"__class__": "time.asctime", "__value__": "Fri Mar 27 22:20:42 2009"},
"comments_link": null, "internal_id": {"__class__": "bytes", "__value__": [222, 213, 180, 248]},
"tags": ["diveintopython", "docbook", "html"], "title": "Dive into history, 2009 edition",
"article_link": "http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition",
"published": true}</samp></pre>

<p class=a>&#x2042;

<h2 id=serializing-json-load>Načítání dat z <abbr>JSON</abbr> souboru</h2>

<p>Modul <code>json</code> obsahuje (stejně jako modul <code>pickle</code>) funkci <code>load()</code>, která přebírá objekt typu stream, čte z něj data v notaci <abbr>JSON</abbr> a vytváří nový pythonovský objekt, který odráží datovou strukturu <abbr>JSON</abbr>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>shell</kbd>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>del entry</kbd>                                             <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>entry</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
NameError: name 'entry' is not defined</samp>
<samp class=p>>>> </samp><kbd class=pp>import json</kbd>
<samp class=p>>>> </samp><kbd class=pp>with open('entry.json', 'r', encoding='utf-8') as f:</kbd>
<a><samp class=p>... </samp><kbd class=pp>    entry = json.load(f)</kbd>                              <span class=u>&#x2461;</span></a>
<samp class=p>... </samp>
<a><samp class=p>>>> </samp><kbd class=pp>entry</kbd>                                                 <span class=u>&#x2462;</span></a>
<samp class=pp>{'comments_link': None,
 'internal_id': {'__class__': 'bytes', '__value__': [222, 213, 180, 248]},
 'title': 'Dive into history, 2009 edition',
 'tags': ['diveintopython', 'docbook', 'html'],
 'article_link': 'http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition',
 'published_date': {'__class__': 'time.asctime', '__value__': 'Fri Mar 27 22:20:42 2009'},
 'published': True}</samp></pre>
<ol>
<li>Pro demonstrační účely se přepneme do pythonovského shellu č. 2 a zrušíme tam datovou strukturu <var>entry</var>, kterou jsme v této kapitole vytvořili dříve, použitím modulu <code>pickle</code>.
<li>V nejjednodušším případě pracuje funkce <code>json.load()</code> stejně jako funkce <code>pickle.load()</code>. Předáme jí objekt typu stream a vrací nový pythonovský objekt.
<li>Mám pro vás dobrou a špatnou zprávu. Nejdříve tu dobrou. Funkce <code>json.load()</code> úspěšně přečetla soubor <code>entry.json</code>, který jsme vytvořili v pythonovském shellu č. 1, a vytvořila nový pythonovský objekt, který data obsahuje. Teď ta špatná zpráva. Nevznikla tím původní datová struktura <var>entry</var>. Hodnoty <code>'internal_id'</code> a <code>'published_date'</code> byly vytvořeny jako slovníky. Jde konkrétně o slovníky obsahující hodnoty slučitelné s <abbr>JSON</abbr>, které jsme vytvořili převodní funkcí <code>to_json()</code>.
</ol>

<p>Funkce <code>json.load()</code> neví nic o konverzních funkcích, které jste mohli předat funkci <code>json.dump()</code>. Potřebujeme vytvořit funkci, která je opakem k funkci <code>to_json()</code>. Potřebujeme funkci, která převezme uživatelsky převedený objekt <abbr>JSON</abbr> a konvertuje jej zpět na původní pythonovský datový typ.

<pre class=pp><code># do customserializer.py přidejte následující
<a>def from_json(json_object):                                   <span class=u>&#x2460;</span></a>
<a>    if '__class__' in json_object:                            <span class=u>&#x2461;</span></a>
        if json_object['__class__'] == 'time.asctime':
<a>            return time.strptime(json_object['__value__'])    <span class=u>&#x2462;</span></a>
        if json_object['__class__'] == 'bytes':
<a>            return bytes(json_object['__value__'])            <span class=u>&#x2463;</span></a>
    return json_object</code></pre>
<ol>
<li>Tato převodní funkce také přebírá jeden parametr a vrací jednu hodnotu. Ale parametrem není řetězec. Je jím pythonovský objekt, který je výsledkem deserializace řetězce v notaci <abbr>JSON</abbr> do pythonovského objektu.
<li>Potřebujeme pouze zkontrolovat, zda tento objekt obsahuje klíč <code>'__class__'</code>, který vytvořila funkce <code>to_json()</code>. Pokud tomu tak je, říká hodnota klíče <code>'__class__'</code>, jak máme hodnotu dekódovat zpět na původní pythonovský datový typ.
<li>K dekódování řetězce s časem, který vrátila funkce <code>time.asctime()</code>, použijeme funkci <code>time.strptime()</code>. Tato funkce přebírá naformátovaný řetězec s datem a časem (v upravitelném formátu, ale s výchozím tvarem stejným, jaký používá funkce <code>time.asctime()</code>) a vrací <code>time.struct_time</code>.
<li>Pro převod seznamu celých čísel na objekt typu <code>bytes</code> můžeme použít funkci <code>bytes()</code>.
</ol>

<p>A je to. Ve funkci <code>to_json()</code> se upravovaly jen dva datové typy. Stejné datové typy jsme teď zpracovali funkcí <code>from_json()</code>. A takhle vypadá výsledek:

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>shell</kbd>
<samp class=pp>2</samp>
<samp class=p>>>> </samp><kbd class=pp>import customserializer</kbd>
<samp class=p>>>> </samp><kbd class=pp>with open('entry.json', 'r', encoding='utf-8') as f:</kbd>
<a><samp class=p>... </samp><kbd class=pp>    entry = json.load(f, object_hook=customserializer.from_json)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>... </samp>
<a><samp class=p>>>> </samp><kbd class=pp>entry</kbd>                                                             <span class=u>&#x2461;</span></a>
<samp class=pp>{'comments_link': None,
 'internal_id': b'\xDE\xD5\xB4\xF8',
 'title': 'Dive into history, 2009 edition',
 'tags': ['diveintopython', 'docbook', 'html'],
 'article_link': 'http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition',
 'published_date': time.struct_time(tm_year=2009, tm_mon=3, tm_mday=27, tm_hour=22, tm_min=20, tm_sec=42, tm_wday=4, tm_yday=86, tm_isdst=-1),
 'published': True}</samp></pre>
<ol>
<li>Funkci <code>from_json()</code> k deserializačnímu procesu připojíme tím, že ji předáme jako parametr <var>object_hook</var> funkci <code>json.load()</code>. Funkce, která přebírá funkci. Jak šikovné!
<li>Datová struktura <var>entry</var> teď obsahuje klíč <code>'internal_id'</code>, jehož hodnotou je objekt typu <code>bytes</code>. Obsahuje také klíč <code>'published_date'</code>, jehož hodnotou je objekt typu <code>time.struct_time</code>.
</ol>

<p>Ale má to ještě jednu mouchu.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>shell</kbd>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd class=pp>import customserializer</kbd>
<samp class=p>>>> </samp><kbd class=pp>with open('entry.json', 'r', encoding='utf-8') as f:</kbd>
<samp class=p>... </samp><kbd class=pp>    entry2 = json.load(f, object_hook=customserializer.from_json)</kbd>
<samp class=p>... </samp>
<a><samp class=p>>>> </samp><kbd class=pp>entry2 == entry</kbd>                                                    <span class=u>&#x2460;</span></a>
<samp class=pp>False</samp>
<a><samp class=p>>>> </samp><kbd class=pp>entry['tags']</kbd>                                                      <span class=u>&#x2461;</span></a>
<samp class=pp>('diveintopython', 'docbook', 'html')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>entry2['tags']</kbd>                                                     <span class=u>&#x2462;</span></a>
<samp class=pp>['diveintopython', 'docbook', 'html']</samp></pre>
<ol>
<li>Dokonce ani po připojení funkce <code>to_json()</code> k serializaci a připojení funkce <code>from_json()</code> k deserializaci se nám stále nepodařilo vytvořit dokonalou repliku původní datové struktury. Proč tomu tak je?
<li>V původní datové struktuře <var>entry</var> byla hodnotou klíče <code>'tags'</code> n-tice tří řetězců (tedy trojice řetězců).
<li>Ale v datové struktuře <var>entry2</var>, kterou jsme dostali převodem tam a zase zpět, má klíč <code>'tags'</code> hodnotu <em>seznamu</em> těchto tří řetězců. <abbr>JSON</abbr> nedělá rozdíl mezi n-ticemi a seznamy. Zná jen jeden seznamu se podobající datový typ &mdash; typ pole. Modul <code>json</code> během serializace potichu konvertuje jak n-tice, tak seznamy na pole v <abbr>JSON</abbr>. Při většině použití můžete rozdíl mezi n-ticemi a seznamy ignorovat. Ale pokud pracujete s modulem <code>json</code>, měli byste na to myslet.
</ol>

<h2 id=serializing-furtherreading>Přečtěte si</h2>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Řada článků o modulu <code>pickle</code> se odkazuje na <code>cPickle</code>. V Pythonu 2 existovaly dvě implementace modulu <code>pickle</code>. Jedna byla napsána v Pythonu a druhá v jazyce C (ale dala se volat z Pythonu). V Pythonu 3 <a href=#porting-code-to-python-3-with-2to3-othermodules>byly tyto moduly spojeny</a>, takže pokaždé provádíme jen <code>import pickle</code>. Zmíněné články mohou být užitečné, ale informaci o <code>cPickle</code> (která je nyní zastaralá) byste měli ignorovat.
</blockquote>

<p>O „piklení“ s modulem <code>pickle</code>:

<ul>
<li><a href="http://docs.python.org/3.1/library/pickle.html"><code>pickle</code> module</a>
<li><a href="http://www.doughellmann.com/PyMOTW/pickle/"><code>pickle</code> and <code>cPickle</code>&nbsp;&mdash;&nbsp;Python object serialization</a>
<li><a href="http://wiki.python.org/moin/UsingPickle">Using <code>pickle</code></a>
<li><a href="http://www.ibm.com/developerworks/library/l-pypers.html">Python persistence management</a>
</ul>

<p>O <abbr>JSON</abbr> a o modulu <code>json</code>:

<ul>
<li><a href="http://www.doughellmann.com/PyMOTW/json/"><code>json</code>&nbsp;&mdash;&nbsp;JavaScript Object Notation Serializer</a>
<li><a href="http://blog.quaternio.net/2009/07/16/json-encoding-and-decoding-with-custom-objects-in-python/">JSON encoding and ecoding with custom objects in Python</a>
</ul>

<p>O rozšiřitelnosti modulu <code>pickle</code>:

<ul>
<li><a href="http://docs.python.org/3.1/library/pickle.html#pickling-class-instances">Pickling class instances</a>
<li><a href="http://docs.python.org/3.1/library/pickle.html#persistence-of-external-objects">Persistence of external objects</a>
<li><a href="http://docs.python.org/3.1/library/pickle.html#handling-stateful-objects">Handling stateful objects</a>
</ul>

</div>
<div id=chapter-http-web-services>
<h1>Webové služby nad HTTP</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> A ruffled mind makes a restless pillow. <span class="u">&#x275E;</span><br>(Rozbouřená mysl je nepohodlný polštář.)<br>&mdash; Charlotte Bronteová
</blockquote>
<p>&nbsp;
<h2 id=http-web-services-divingin>Ponořme se</h2>
<p class=f>Z filozofického hlediska můžeme webové služby nad HTTP (HyperText Transfer Protocol) popsat devíti slovy: výměna dat se vzdálenými servery pouze s použitím operací protokolu <abbr>HTTP</abbr>. Pokud chceme ze serveru získat data, použijeme <abbr>HTTP</abbr> <code>GET</code>. Pokud chceme nová data na server zaslat, použijeme <abbr>HTTP</abbr> <code>POST</code>. Některá pokročilejší aplikační rozhraní (<abbr>API</abbr>) webových služeb nad <abbr>HTTP</abbr> umožňují také vytváření, modifikaci a rušení dat použitím <abbr>HTTP</abbr> <code>PUT</code> a <abbr>HTTP</abbr> <code>DELETE</code>. To je vše. Žádné registry, žádné obálky, žádný obalující kód, žádné tunelování. „Slovesa“, která jsou součástí <abbr>HTTP</abbr> protokolu (<code>GET</code>, <code>POST</code>, <code>PUT</code> a <code>DELETE</code>) přímo odpovídají operacím na aplikační úrovni pro získávání, vytváření, modifikaci a rušení dat.

<p>Hlavní výhodou tohoto přístupu je jednoduchost a právě jednoduchost vedla k jeho oblibě. Data&nbsp;&mdash;&nbsp;obvykle <a href=#chapter-xml><abbr>XML</abbr></a> nebo <a href=#serializing-json><abbr>JSON</abbr></a>&nbsp;&mdash;&nbsp;mohou být vytvořena a uložena jako statická, nebo mohou být generována dynamicky, skriptem na straně serveru. Všechny hlavní programovací jazyky (samozřejmě včetně Pythonu) umožňují stahování těchto dat prostřednictvím svých <abbr>HTTP</abbr>-knihoven. Jednodušší je i ladění. Každý prostředek (resource) webové služby nad <abbr>HTTP</abbr> má jednoznačnou adresu v podobě <abbr>URL</abbr>. Po zadání do webového prohlížeče dojde k načtení a hned vidíte surová data.

<p>Příklady webových služeb nad <abbr>HTTP</abbr>:
<ul>
<li><a href="http://code.google.com/apis/gdata/">Aplikační rozhraní Google Data</a> vám umožní uživatelsky pracovat s celou řadou služeb Google, včetně <a href="http://www.blogger.com/">Blogger</a> a <a href="http://www.youtube.com/">YouTube</a>.
<li><a href="http://www.flickr.com/services/api/">Flickr Services</a> vám umožní odesílat a stahovat fotografie z <a href="http://www.flickr.com/">Flickr</a>.
<li><a href="http://apiwiki.twitter.com/">Twitter <abbr>API</abbr></a> vám umožní zveřejňovat krátké zprávy na <a href="http://twitter.com/">Twitter</a>.
<li><a href="http://www.programmableweb.com/apis/directory/1?sort=mashups">&hellip;a řada dalších</a>
</ul>

<p>Pro interakci s webovými službami nad <abbr>HTTP</abbr> jsou v Pythonu 3 k dispozici dvě různé knihovny:

<ul>
<li><a href="http://docs.python.org/3.1/library/http.client.html"><code>http.client</code></a> je nízkoúrovňová knihovna, která implementuje <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html"><abbr>RFC</abbr> 2616</a>, tedy <abbr>HTTP</abbr>-protokol.
<li><a href="http://docs.python.org/3.1/library/urllib.request.html"><code>urllib.request</code></a> je knihovna na vyšší úrovni abstrakce, vybudovaná nad <code>http.client</code>. Poskytuje standardní aplikační rozhraní pro zpřístupňování jak <abbr>HTTP</abbr>, tak <abbr>FTP</abbr> serverů, automaticky následuje přesměrování <abbr>HTTP</abbr> a podporuje některé běžné formy autentizace v <abbr>HTTP</abbr>.
</ul>

<p>Takže který mám použít? Z těchto dvou žádný. Místo toho byste měli použít <a href="http://code.google.com/p/httplib2/"><code>httplib2</code></a>, což je open source knihovna třetí strany, která implementuje <abbr>HTTP</abbr> do větších detailů než <code>http.client</code>. Současně používá lepší abstrakce než <code>urllib.request</code>.

<p>Abyste porozuměli tomu, proč je <code>httplib2</code> tou správnou volbou, musíte nejdříve porozumět <abbr>HTTP</abbr>.

<p class=a>&#x2042;

<h2 id=http-web-services-http-features>Vlastnosti HTTP</h2>

<p>Každý <abbr>HTTP</abbr> klient by měl podporovat pět důležitých vlastností.

<h3 id=http-web-services-caching>Používání mezipaměti</h3>

<p>Nejdůležitější věcí, které musíme v souvislosti s libovolným typem webové služby rozumět, je to, že přístup k síti je velmi drahý. Nemám na mysli cenu „v penězích“ (i když šířka přenosového pásma není zadarmo). Mám na mysli to, že hrozně dlouhou dobu zabere otevření spojení, odeslání požadavku a získání odezvy ze vzdáleného serveru. Dokonce i v případě nejrychlejšího dostupného spojení může být <i>latence</i> (tj. čas mezi zasláním požadavku a zahájením přijímání dat odpovědi) vyšší, než byste předpokládali. Směrovače mohou zafungovat divně, paket se ztratí, na mezilehlý server někdo zaútočil... Na veřejné internetové síti <a href="http://isc.sans.org/">není nikdy klidná chvilka</a> a nic s tím nenaděláte.

<aside><code>Cache-Control: max-age</code> znamená „neotravujte mě až do příštího týdne“.</aside>

<p>Při návrhu <abbr>HTTP</abbr> se počítalo s využíváním mezipaměti (cache). Existuje dokonce samostatná třída zařízení (zvaných „mezipaměťové proxy-servery“, anglicky „chaching proxies“), jejichž jedinou prací je ležet mezi vámi a zbytkem světa a minimalizovat zatěžování sítě. Vaše firma nebo váš poskytovatel připojení (<abbr>ISP</abbr>) téměř jistě mezipaměťové proxy-servery udržuje, i když si toho nemusíte být vědomi. Fungují, protože používání mezipaměti (caching) je součástí <abbr>HTTP</abbr> protokolu.

<p>Následuje konkrétní příklad toho, jak to funguje. Prostřednictvím svého prohlížeče navštívíte <a href="http://diveintomark.org/"><code>diveintomark.org</code></a>. Uvedená stránka používá pro pozadí obrázek <a href="http://wearehugh.com/m.jpg"><code>wearehugh.com/m.jpg</code></a>. Když váš prohlížeč obrázek stáhne, server k němu přiloží následující <abbr>HTTP</abbr> hlavičky:

<pre class=nd><code>HTTP/1.1 200 OK
Date: Sun, 31 May 2009 17:14:04 GMT
Server: Apache
Last-Modified: Fri, 22 Aug 2008 04:28:16 GMT
ETag: "3075-ddc8d800"
Accept-Ranges: bytes
Content-Length: 12405
<mark>Cache-Control: max-age=31536000, public</mark>
<mark>Expires: Mon, 31 May 2010 17:14:04 GMT</mark>
Connection: close
Content-Type: image/jpeg</code></pre>

<p>Hlavičky <code>Cache-Control</code> a <code>Expires</code> říkají vašemu prohlížeči (a všem mezipaměťovým proxy-serverům mezi vámi a serverem), že se tento obrázek může získávat z mezipaměti až jeden rok. <em>Celý rok!</em> A pokud někdy v příštím roce navštívíte jinou stránku, která také obsahuje odkaz na tento obrázek, váš prohlížeč jej načte ze své mezipaměti, <em>aniž by vyvolal jakoukoliv síťovou aktivitu</em>.

<p>Ale počkejte, bude to ještě lepší. Dejme tomu, že váš prohlížeč obrázek z lokální mezipaměti z nějakého důvodu odstraní. Možná mu došlo místo na disku, možná jste mezipaměť vyprázdnili ručně. Z jakéhokoliv důvodu. Ale <abbr>HTTP</abbr> hlavičky říkají, že tato data mohou být uchovávána veřejnými mezipaměťovými proxy-servery. (Z technického pohledu je důležité, co hlavičky <em>neříkají</em>. Hlavička <code>Cache-Control</code> neuvádí klíčové slovo <code>private</code>, takže data mohou být uložena v mezipaměti automaticky.) Mezipaměťové proxy-servery jsou navrženy tak, že mají k dispozici obrovské množství úložného prostoru &mdash; pravděpodobně ho mají mnohem více, než má vyhrazeno váš lokální prohlížeč.

<p>Pokud vaše firma nebo váš poskytovatel připojení spravuje mezipaměťový proxy-server, může se v jeho mezipaměti obrázek pořád ještě nacházet. Pokud navštívíte <code>diveintomark.org</code> znovu, podívá se váš prohlížeč po obrázku do lokální mezipaměti, ale nenajde jej. Takže vytvoří síťový požadavek a pokusí se obrázek stáhnout ze vzdáleného serveru. Pokud ale mezipaměťový proxy-server pořád má kopii uvedeného obrázku, váš požadavek zachytí a dodá vám obrázek ze <em>své</em> mezipaměti. To znamená, že se váš požadavek ke vzdálenému serveru nikdy nedostane. Ve skutečnosti nemusí opustit vaši firemní síť. Získání obrázku je rychlejší (méně skoků po síti) a vaše firma ušetří peníze (z vnějšího světa se stahuje méně dat).

<p>Použití mezipamětí v <abbr>HTTP</abbr> funguje, pokud všechny strany dělají, co mají. Na jedné straně musí servery v odpovědích posílat správné hlavičky. Na druhé straně musí klienti hlavičkám rozumět, respektovat je a nežádat stejná data dvakrát. Mezilehlé proxy-servery nejsou všelékem. Mohou být „chytré“ jen do té míry, do jaké jim to servery a klienti umožní.

<p>Standardní pythonovské knihovny pro <abbr>HTTP</abbr> používání mezipaměti nepodporují, ale <code>httplib2</code> ano.

<h3 id=http-web-services-last-modified>Kontrola Last-Modified</h3>

<p>Některá data se nemění nikdy, zatímco jiná data se mění pořád. A mezi tím je obrovské množství dat, která se <em>mohla</em> změnit, ale nezměnila se. Publikovaný obsah (feed) serveru CNN.com se mění každých pár minut, ale publikovaný obsah mého weblogu se nemusí změnit celé dny nebo týdny. I kdyby to byl ten druhý případ, nechci klientům říct, aby si můj publikovaný obsah brali z mezipaměti celé týdny, protože pokud bych doopravdy něco nového zveřejnil, lidé by se o tom celé týdny nedozvěděli (protože by respektovali mé hlavičky týkající se mezipaměti, které říkají „neobtěžujte se s kontrolou tohoto publikovaného obsahu po celé týdny“). Na druhou stranu zase nechci, aby klienti stahovali celý publikovaný obsah (feed) každou hodinu, pokud se vůbec nezměnil!

<aside><code>304: Not Modified</code> znamená „stejné nesmysly, jiný den“.</aside>

<p><abbr>HTTP</abbr> nabízí řešení i pro tento případ. Pokud o data žádáme poprvé, server může zpět poslat hlavičku <code>Last-Modified</code> (naposledy změněno). Je to přesně to, jak to vypadá: datum a čas, kdy se data naposledy změnila. Obrázek pozadí, na který vedl odkaz z <code>diveintomark.org</code>, doprovázela hlavička <code>Last-Modified</code>.

<pre class=nd><code>HTTP/1.1 200 OK
Date: Sun, 31 May 2009 17:14:04 GMT
Server: Apache
<mark>Last-Modified: Fri, 22 Aug 2008 04:28:16 GMT</mark>
ETag: "3075-ddc8d800"
Accept-Ranges: bytes
Content-Length: 12405
Cache-Control: max-age=31536000, public
Expires: Mon, 31 May 2010 17:14:04 GMT
Connection: close
Content-Type: image/jpeg
</code></pre>

<p>Pokud požadujeme stejná data podruhé (nebo potřetí nebo počtvrté), můžeme v dotazu poslat hlavičku <code>If-Modified-Since</code> (pokud bylo změněno od) s hodnotou data a času, které jsme od serveru dostali minule. Pokud se data od té doby změnila, pak server vrátí nová data doplněná o stavový kód <code>200</code>. Ale pokud se data od té doby <em>nezměnila</em>, server pošle zpět speciální stavový kód protokolu <abbr>HTTP</abbr> &mdash; <code>304</code>. Ten říká „od doby, kdy ses naposledy ptal, se tato data nezměnila“. Z příkazového řádku si to můžeme ověřit nástrojem <a href="http://curl.haxx.se/">curl</a>:

<pre class='nd screen'>
<samp class=p>you@localhost:~$ </samp><kbd>curl -I <mark>-H "If-Modified-Since: Fri, 22 Aug 2008 04:28:16 GMT"</mark> http://wearehugh.com/m.jpg</kbd>
<samp>HTTP/1.1 304 Not Modified
Date: Sun, 31 May 2009 18:04:39 GMT
Server: Apache
Connection: close
ETag: "3075-ddc8d800"
Expires: Mon, 31 May 2010 18:04:39 GMT
Cache-Control: max-age=31536000, public</samp></pre>

<p>A proč by to mělo být vylepšení? Protože když server pošle <code>304</code>, <em>neposílá data znovu</em>. Dostaneme pouze stavový kód. Kontrola poslední modifikace zajistí, že se nezměněná data nebudou stahovat podruhé i v případě, kdy došlo k vypršení platnosti kopie v lokální mezipaměti. (Jako bonus navíc obsahuje odpověď <code>304</code> také hlavičky pro mezipaměť. Proxy-servery si kopii dat drží, dokonce i když oficiálně „expirovala“, v naději, že se data <em>ve skutečnosti</em> nezměnila a že další požadavek povede k odpovědi se stavovým kódem <code>304</code> a s aktualizovanými informacemi pro mezipaměť.)

<p>Standardní pythonovské knihovny pro <abbr>HTTP</abbr> nepodporují kontrolu data poslední modifikace, ale <code>httplib2</code> ano.

<h3 id=http-web-services-etags>Kontrola ETag</h3>

<p>ETagy (tag = značka) představují alternativní způsob dosažení stejného efektu jako v případě <a href=#http-web-services-last-modified>kontroly last-modified</a>. Při použití ETagů posílá server spolu s požadovanými daty v hlavičce <code>ETag</code> s heš-kódem (hash). (Jak se přesně heš-hodnota určí, to závisí zcela na serveru. Jediný požadavek je takový, aby se změnila, pokud se změní data.) Obrázek pozadí, na který vedl odkaz z <code>diveintomark.org</code>, doprovázela hlavička <code>ETag</code>.

<pre class=nd><code>HTTP/1.1 200 OK
Date: Sun, 31 May 2009 17:14:04 GMT
Server: Apache
Last-Modified: Fri, 22 Aug 2008 04:28:16 GMT
<mark>ETag: "3075-ddc8d800"</mark>
Accept-Ranges: bytes
Content-Length: 12405
Cache-Control: max-age=31536000, public
Expires: Mon, 31 May 2010 17:14:04 GMT
Connection: close
Content-Type: image/jpeg
</code></pre>

<aside><code>ETag</code> vyjadřuje „nic nového pod sluncem“.</aside>

<p>Pokud stejná data požadujeme podruhé, přiložíme heš-hodnotu v hlavičce pořadavku <code>If-None-Match</code> (pokud žádná data neodpovídají). Pokud se data nezměnila, server pošle zpět stavový kód <code>304</code>. Server &mdash; stejně jako v případě kontroly založené na čase poslední modifikace &mdash; pošle zpět <em>pouze</em> stavový kód <code>304</code>. Stejná data znovu neposílá. Přiložením heš-hodnoty v ETagu při druhém požadavku serveru říkáme, že při shodě heše není nutné posílat stejná data znovu, protože je <a href=#http-web-services-caching>pořád máme schovaná od minula</a>.

<p>Opět vyzkoušíme pomocí <kbd>curl</kbd>:

<pre class='nd screen'>
<a><samp class=p>you@localhost:~$ </samp><kbd>curl -I <mark>-H "If-None-Match: \"3075-ddc8d800\""</mark> http://wearehugh.com/m.jpg</kbd>  <span class=u>&#x2460;</span></a>
<samp>HTTP/1.1 304 Not Modified
Date: Sun, 31 May 2009 18:04:39 GMT
Server: Apache
Connection: close
ETag: "3075-ddc8d800"
Expires: Mon, 31 May 2010 18:04:39 GMT
Cache-Control: max-age=31536000, public</samp></pre>
<ol>
<li>ETagy se běžně uzavírají do uvozovek, ale <em>tyto uvozovky jsou součástí hodnoty</em>. To znamená, že v hlavičce <code>If-None-Match</code> musíme serveru poslat zpět i uvozovky.
</ol>

<p>Standardní pythonovské knihovny pro <abbr>HTTP</abbr> používání ETagů nepodporují, ale <code>httplib2</code> ano.

<h3 id=http-web-services-compression>Komprese</h3>

<p>Pokud se bavíme o webových službách nad <abbr>HTTP</abbr>, pak se téměř vždy bavíme o přesunování textových dat po drátech tam a zase zpět. Možná jsou ve formátu <abbr>XML</abbr>, možná jsou v <abbr>JSON</abbr>, možná je to <a href=#strings-boring-stuff" title="nic jako „prostý“ text neexistuje>prostý text</a>. Text se dá dobře komprimovat nezávisle na použitém formátu. Příklad publikovaného obsahu (feed) z <a href=#chapter-xml>kapitoly XML</a> má nekomprimovaný 3070 bajtů, ale po kompresi algoritmem gzip má 941 bajtů. To je jen 30&nbsp;% původní velikosti!

<p><abbr>HTTP</abbr> podporuje <a href="http://www.iana.org/assignments/http-parameters">několik komprimačních algoritmů</a>. Mezi dva nejběžnější patří <a href="http://www.ietf.org/rfc/rfc1952.txt">gzip</a> a <a href="http://www.ietf.org/rfc/rfc1951.txt">deflate</a>. Pokud přes <abbr>HTTP</abbr> požadujeme nějaký prostředek (resource), můžeme serveru říci, aby ho poslal v komprimovaném formátu. Do požadavku vložíme hlavičku <code>Accept-encoding</code>, ve které vyjmenujeme námi podporované komprimační algoritmy. Pokud server některý z těchto algoritmů podporuje, pošle nám zpět komprimovaná data (s hlavičkou <code>Content-encoding</code>, která říká, jaký algoritmus byl použit). O dekompresi se už musíme postarat sami.

<blockquote class=note>
<p><span class="u">&#x261E;</span>Důležitý tip pro vývojáře kódu na straně serveru: Ujistěte se, že komprimovaná podoba zdroje dostane přidělenou jinou značku <a href=#http-web-services-etags>Etag</a> než nekomprimovaná verze. V opačném případě by došlo ke zmatení mezipaměťových proxy-serverů a ty by mohly klientům vracet komprimovanou verzi, se kterou by si klient nemusel poradit. Více detailů o této delikátní záležitosti si můžete přečíst v diskusi <a href="https://issues.apache.org/bugzilla/show_bug.cgi?id=39727">Apache bug 39727</a>.
</blockquote>

<p>Standardní pythonovské knihovny pro <abbr>HTTP</abbr> kompresi nepodporují, ale <code>httplib2</code> ano.

<h3 id=http-web-services-redirects>Přesměrování</h3>

<p><a href="http://www.w3.org/Provider/Style/URI">Senzační <abbr>URI</abbr> se nemění</a>, ale mnohá <abbr>URI</abbr> jsou opravdu&hellip; nesenzační. Webová místa se reorganizují, stránky se přesouvají na nové adresy. Dokonce i webové služby mohou být reorganizovány. Publikovaný obsah (syndicated feed) mohl být přesunut z <code>http://example.com/index.xml</code> do <code>http://example.com/xml/atom.xml</code>. Nebo se při rozšiřování a reorganizaci firmy mohla přesunout celá doména. Z <code>http://www.example.com/index.xml</code> se mění na <code>http://server-farm-1.example.com/index.xml</code>.

<aside><code>Location</code> znamená „podívej se támhle“!</aside>

<p>Pokaždé, když <abbr>HTTP</abbr> server požádáme o nějaký zdroj (resource), vrací v odpovědi stavový kód. Stavový kód <code>200</code> znamená „vše v pořádku, tady je požadovaná stránka“. Stavový kód <code>404</code> znamená „stránka nenalezena“. (Chybu 404 jste už asi při brouzdání po webu viděli.) Stavové kódy ve skupině 300 vyjadřují nějakou formu přesměrování.

<p><abbr>HTTP</abbr> nabízí několik způsobů, jakými se dá oznámit, že se požadované zdroje přesunuly. Dvě nejběžnější techniky používají stavové kódy <code>302</code> a <code>301</code>. Stavový kód <code>302</code> označuje <i>dočasné přesměrování</i>. Znamená „ejhle, je to dočasně přesunuté“ (a v hlavičce <code>Location</code> se vrátí dočasná adresa). Stavový kód <code>301</code> označuje <i>trvalé přesměrování</i>. Znamená „ejhle, je to trvale přesunuté“ (a v hlavičce <code>Location</code> se vrací nová adresa). Pokud obdržíte stavový kód <code>302</code> a novou adresu, pak máte podle specifikace <abbr>HTTP</abbr> pro požadovanou věc použít novou adresu. Ale až se budete na stejný zdroj informací ptát příště, máte to znovu zkusit s původní adresou. Pokud ale obdržíte stavový kód <code>301</code> a k němu novou adresu, očekává se od vás, že od toho okamžiku začnete používat novou adresu.

<p>Modul <code>urllib.request</code> při obdržení příslušného stavového kódu od <abbr>HTTP</abbr> serveru sice „následuje“ přesměrování, ale neřekne vám, že tato situace nastala. Dostanete data, která jste požadovali, ale nikdy se nedozvíte, že se použitá knihovna zachovala „užitečně“ a následovala přesměrování za vás. Takže pořád bušíte na staré adrese a pokaždé jste serverem přesměrováni na novou adresu a modul <code>urllib.request</code> pokaždé „užitečně“ následuje přesměrování. Jinými slovy, tato knihovna se k trvalému přesměrování chová stejně jako k dočasnému přesměrování. To znamená, že se místo jednoho kola provedou vždycky dvě. To je špatné jak pro server, tak pro vás.

<p>Knihovna <code>httplib2</code> trvalé přesměrování zvládá. Nejen že vám řekne, že nastalo trvalé přesměrování, ale lokálně si je poznamená a přesměrovaná <abbr>URL</abbr> automaticky přepíše dříve, než vznese příslušný požadavek.

<p class=a>&#x2042;

<h2 id=http-web-services-dont-try-this-at-home>Jak se nedostat k datům přes HTTP</h2>

<p>Dejme tomu, že přes <abbr>HTTP</abbr> chceme stáhnout informační zdroj, jako je například <a href=#chapter-xml>Atom feed</a>. Protože jde o publikovaný obsah (feed), nebudeme jej stahovat jen jednou. Budeme jej stahovat opakovaně, pořád dokola. (Většina čteček publikovaného obsahu (feed reader) kontroluje změny každou hodinu.) Nejdříve vyzkoušíme „rychlý a špinavý“ způsob a pak se podíváme, jak bychom to mohli provádět lépe.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import urllib.request</kbd>
<samp class=p>>>> </samp><kbd class=pp>a_url = 'http://diveintopython3.org/examples/feed.xml'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>data = urllib.request.urlopen(a_url).read()</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>type(data)</kbd>                                   <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;class 'bytes'></samp>
<samp class=p>>>> </samp><kbd class=pp>print(data)</kbd>
<samp class=pp>&lt;?xml version='1.0' encoding='utf-8'?>
&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'>
  &lt;title>dive into mark&lt;/title>
  &lt;subtitle>currently between addictions&lt;/subtitle>
  &lt;id>tag:diveintomark.org,2001-07-29:/&lt;/id>
  &lt;updated>2009-03-27T21:56:07Z&lt;/updated>
  &lt;link rel='alternate' type='text/html' href='http://diveintomark.org/'/>
  &hellip;
</samp></pre>
<ol>
<li>Stažení čehokoliv přes <abbr>HTTP</abbr> je v Pythonu neuvěřitelně jednoduché. Dá se to ve skutečnosti napsat na jeden řádek. Modul <code>urllib.request</code> nabízí šikovnou funkci <code>urlopen()</code>, která přebírá adresu požadované stránky a vrací objekt typu stream, ze kterého získáme celý obsah stránky prostým zavoláním metody <code>read()</code>. Už to asi nemůže být jednodušší.
<li>Metoda <code>urlopen().read()</code> vrací vždy <a href=#strings-byte-arrays>objekt typu <code>bytes</code> a ne řetězec</a>. Vzpomeňte si &mdash; bajty jsou bajty, znaky jsou abstrakce. <abbr>HTTP</abbr> servery nepracují s abstrakcemi. Kdykoliv požádáme o nějaký zdroj (resource), dostaneme bajty. Pokud z toho chceme udělat řetězec, musíme <a href="http://feedparser.org/docs/character-encoding.html">zjistit znakové kódování</a> a provést explicitní převod na řetězec.
</ol>

<p>A co na tom je špatného? Při rychlém, jednorázovém přístupu během ladění a vývoje na tom není špatného nic. Dělám to takhle pořád. Chtěl jsem publikovaný obsah (feed), dostal jsem publikovaný obsah. Stejná technika funguje pro libovolné webové stránky. Ale jakmile o tom začneme uvažovat z pohledu webové služby, která se má využívat pravidelně (tj. požadavek na získání publikovaného obsahu každou hodinu), pak by to bylo neefektivní a my bychom byli nezdvořilí.

<p class=a>&#x2042;

<h2 id=http-web-services-whats-on-the-wire>Co že to máme na drátě?</h2>

<p>Abychom viděli, proč je to neefektivní a nezdvořilé, obrátíme se na ladicí prostředky pythonovské knihovny pro <abbr>HTTP</abbr> a uvidíme, co běhá „po drátech“ (tj. co se přenáší v síti).

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>from http.client import HTTPConnection</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>HTTPConnection.debuglevel = 1</kbd>                                       <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>from urllib.request import urlopen</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>response = urlopen('http://diveintopython3.org/examples/feed.xml')</kbd>  <span class=u>&#x2461;</span></a>
<samp><a>send: b'GET /examples/feed.xml HTTP/1.1                                 <span class=u>&#x2462;</span></a>
<a>Host: diveintopython3.org                                               <span class=u>&#x2463;</span></a>
<a>Accept-Encoding: identity                                               <span class=u>&#x2464;</span></a>
<a>User-Agent: Python-urllib/3.1'                                          <span class=u>&#x2465;</span></a>
Connection: close
reply: 'HTTP/1.1 200 OK'
&hellip;further debugging information omitted&hellip;</samp></pre>
<ol>
<li>Jak už jsem se zmínil na začátku této kapitoly, <code>urllib.request</code> spoléhá na další standardní pythonovskou knihovnu, <code>http.client</code>. S knihovnou <code>http.client</code> za normálních okolností do přímého styku nepřicházíte. (Modul <code>urllib.request</code> ji importuje automaticky.) Ale my si ji importujeme ručně, abychom mohli nastavit příznak ladění u třídy <code>HTTPConnection</code>, kterou modul <code>urllib.request</code> používá pro připojení k <abbr>HTTP</abbr> serveru.
<li>Když teď máme ladicí příznak nastaven, budou se informace o <abbr>HTTP</abbr> požadavku a o odpovědi na něj tisknout v reálném čase. Když si vyžádáme Atom feed, je vidět, že modul <code>urllib.request</code> posílá serveru pět řádků.
<li>První řádek uvádí používané <abbr>HTTP</abbr> sloveso (metodu; zde <code>GET</code>) a cestu ke zdroji (bez uvedení jména domény).
<li>Druhý řádek uvádí doménu, ze které byl požadavek na feed vznesen.
<li>Třetí řádek uvádí komprimační algoritmy, které klient podporuje. Jak bylo uvedeno výše, <a href=#http-web-services-compression><code>urllib.request</code> standardně kompresi nepodporuje</a>.
<li>Čtvrtý řádek uvádí jméno knihovny, jejímž prostřednictvím byl požadavek vznesen. Výchozí hodnotou je <code>Python-urllib</code> a číslo verze. Jak <code>urllib.request</code>, tak <code>httplib2</code> podporují změnu identifikace zprostředkovatele tím, že se do požadavku jednoduše přidá hlavička <code>User-Agent</code>, která přepíše výchozí hodnotu.
</ol>

<aside>Stahovali jsme 3070 bajtů, i když bychom mohli stahovat pouhých 941.</aside>

<p>Teď se podívejme na to, jakou odpověď poslal server zpět.

<pre class=screen>
# pokračování předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>print(response.headers.as_string())</kbd>        <span class=u>&#x2460;</span></a>
<samp><a>Date: Sun, 31 May 2009 19:23:06 GMT            <span class=u>&#x2461;</span></a>
Server: Apache
<a>Last-Modified: Sun, 31 May 2009 06:39:55 GMT   <span class=u>&#x2462;</span></a>
<a>ETag: "bfe-93d9c4c0"                           <span class=u>&#x2463;</span></a>
Accept-Ranges: bytes
<a>Content-Length: 3070                           <span class=u>&#x2464;</span></a>
<a>Cache-Control: max-age=86400                   <span class=u>&#x2465;</span></a>
Expires: Mon, 01 Jun 2009 19:23:06 GMT
Vary: Accept-Encoding
Connection: close
Content-Type: application/xml</samp>
<a><samp class=p>>>> </samp><kbd class=pp>data = response.read()</kbd>                     <span class=u>&#x2466;</span></a>
<samp class=p>>>> </samp><kbd class=pp>len(data)</kbd>
<samp class=pp>3070</samp></pre>
<ol>
<li>Odpověď (<var>response</var>) vrácená funkcí <code>urllib.request.urlopen()</code> obsahuje všechny <abbr>HTTP</abbr> hlavičky, které server poslal zpět. Obsahuje také metody pro stahování skutečných dat. K tomu se dostaneme za minutku.
<li>Server říká, kdy zpracoval náš požadavek.
<li>Odpověď obsahuje i hlavičku <a href=#http-web-services-last-modified><code>Last-Modified</code></a>.
<li>Odpověď obsahuje také hlavičku <a href=#http-web-services-etags><code>ETag</code></a>.
<li>Data mají velikost 3070 bajtů. Všimněte si, že zde <em>není</em> hlavička <code>Content-encoding</code>. V požadavku jsme uvedli, že přijímáme jen nekomprimovaná data (<code>Accept-encoding: identity</code>), takže jsme tím pádem dostali nekomprimovaná data.
<li>V odpovědi se nacházejí hlavičky pro mezipaměti, které říkají, že publikovaný obsah (feed) může být brán z mezipaměti po dobu 24 hodin (86 400 sekund).
<li>A nakonec stáhneme skutečná data voláním <code>response.read()</code>. Z výsledku funkce <code>len()</code> vidíme, že se stáhlo všech 3070 bajtů najednou.
</ol>

<p>Jak sami vidíte, tento kód je už teď neefektivní. Požadoval (a obdržel) nekomprimovaná data. Určitě vím, že uvedený server podporuje <a href=#http-web-services-compression>kompresi gzip</a>, ale v <abbr>HTTP</abbr> se komprese zapíná na vyžádání. Nepožádali jsme o ni, tak jsme ji nedostali. To znamená, že jsme stahovali 3070 bajtů v situaci, kdy jsme mohli stahovat pouhých 941. Zlobivý pejsek, žádná sušenka.

<p>Ale moment, začíná to být ještě horší! Abychom viděli, jak neefektivní ten kód je, požádáme o stejný publikovaný obsah (feed) podruhé.

<pre class='nd screen'>
# pokračování <a href=#http-web-services-whats-on-the-wire>předchozího příkladu</a>
<samp class=p>>>> </samp><kbd class=pp>response2 = urlopen('http://diveintopython3.org/examples/feed.xml')</kbd>
<samp>send: b'GET /examples/feed.xml HTTP/1.1
Host: diveintopython3.org
Accept-Encoding: identity
User-Agent: Python-urllib/3.1'
Connection: close
reply: 'HTTP/1.1 200 OK'
&hellip;further debugging information omitted&hellip;</samp></pre>

<p>Všimli jste si na tom požadavku něčeho zvláštního? Vůbec se nezměnil! Je naprosto stejný jako ten předchozí. Žádná známka použití <a href=#http-web-services-last-modified>hlavičky <code>If-Modified-Since</code></a>. Žádná známka použití <a href=#http-web-services-etags>hlavičky <code>If-None-Match</code></a>. Žádný respekt k hlavičkám mezipaměti. Ještě pořád žádná komprese.

<p>A co se stane, když uděláme stejnou věc dvakrát? Dostaneme stejnou odpověď. Dvakrát.

<pre class=screen>
# pokračování předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>print(response2.headers.as_string())</kbd>     <span class=u>&#x2460;</span></a>
<samp>Date: Mon, 01 Jun 2009 03:58:00 GMT
Server: Apache
Last-Modified: Sun, 31 May 2009 22:51:11 GMT
ETag: "bfe-255ef5c0"
Accept-Ranges: bytes
Content-Length: 3070
Cache-Control: max-age=86400
Expires: Tue, 02 Jun 2009 03:58:00 GMT
Vary: Accept-Encoding
Connection: close
Content-Type: application/xml</samp>
<samp class=p>>>> </samp><kbd class=pp>data2 = response2.read()</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>len(data2)</kbd>                               <span class=u>&#x2461;</span></a>
<samp class=pp>3070</samp>
<a><samp class=p>>>> </samp><kbd class=pp>data2 == data</kbd>                            <span class=u>&#x2462;</span></a>
<samp class=pp>True</samp></pre>
<ol>
<li>Server pořád posílá stejné pole „chytrých“ hlaviček: <code>Cache-Control</code> a <code>Expires</code> pro mezipaměť (cache), <code>Last-Modified</code> a <code>ETag</code> pro sledování „nezměněného stavu“. A dokonce hlavičku <code>Vary: Accept-Encoding</code>, kterou server dává najevo, že by mohl podporovat kompresi, kdybychom si o ni řekli. Ale my jsme to neudělali.
<li>A ještě jednou, při získávání dat se stáhlo všech 3070 bajtů&hellip;
<li>&hellip;stejných 3070 bajtů, které jsme stáhli už minule.
</ol>

<p>Protokol <abbr>HTTP</abbr> je navržen, aby pracoval lepším způsobem. Knihovna <code>urllib</code> umí <abbr>HTTP</abbr> asi tak, jak já umím španělsky&nbsp;&mdash;&nbsp;dost na to, abych se dostal z problémů, ale ne dost k vedení konverzace. A <abbr>HTTP</abbr> se týká konverzace. Je čas přejít ke knihovně, která protokolem <abbr>HTTP</abbr> mluví plynule.

<p class=a>&#x2042;

<h2 id=http-web-services-introducing-httplib2>Představujeme <code>httplib2</code></h2>

<p>Než začneme knihovnu <code>httplib2</code> používat, musíme ji nainstalovat. Navštivte stránku <a href="http://code.google.com/p/httplib2/"><code>code.google.com/p/httplib2/</code></a> a stáhněte poslední verzi. <code>httplib2</code> je k dispozici pro Python 2.x a pro Python 3.x. Ujistěte se, že jde o verzi pro Python 3. Jmenuje se podobně jako <code>httplib2-python3-0.5.0.zip</code>. (V době překladu už to bylo jinak: <code>httplib2-0.6.0.zip</code>; uvnitř jsou obě verze.)

<p>Rozbalte archiv, otevřete terminálové okno a přejděte do nově vytvořeného adresáře <code>httplib2</code>. Pod Windows otevřete menu <code>Start</code>, vyberte <code>Run...</code>, napište <kbd>cmd.exe</kbd> a stiskněte <kbd>ENTER</kbd>.

<pre class=screen>
<samp class=p>c:\Users\pilgrim\Downloads> </samp><kbd><mark>dir</mark></kbd>
<samp> Volume in drive C has no label.
 Volume Serial Number is DED5-B4F8

 Directory of c:\Users\pilgrim\Downloads

07/28/2009  12:36 PM    &lt;DIR>          .
07/28/2009  12:36 PM    &lt;DIR>          ..
07/28/2009  12:36 PM    &lt;DIR>          httplib2-python3-0.5.0
07/28/2009  12:33 PM            18,997 httplib2-python3-0.5.0.zip
               1 File(s)         18,997 bytes
               3 Dir(s)  61,496,684,544 bytes free</samp>

<samp class=p>c:\Users\pilgrim\Downloads> </samp><kbd><mark>cd httplib2-python3-0.5.0</mark></kbd>
<samp class=p>c:\Users\pilgrim\Downloads\httplib2-python3-0.5.0> </samp><kbd><mark>c:\python31\python.exe setup.py install</mark></kbd>
<samp>running install
running build
running build_py
running install_lib
creating c:\python31\Lib\site-packages\httplib2
copying build\lib\httplib2\iri2uri.py -> c:\python31\Lib\site-packages\httplib2
copying build\lib\httplib2\__init__.py -> c:\python31\Lib\site-packages\httplib2
byte-compiling c:\python31\Lib\site-packages\httplib2\iri2uri.py to iri2uri.pyc
byte-compiling c:\python31\Lib\site-packages\httplib2\__init__.py to __init__.pyc
running install_egg_info
Writing c:\python31\Lib\site-packages\httplib2-python3_0.5.0-py3.1.egg-info</samp></pre>

<p>V Mac OS X spusťte aplikaci <code>Terminal.app</code>, kterou najdete ve složce <code>/Applications/Utilities/</code>. V Linuxu spusťte aplikaci <code>Terminal</code>, kterou obvykle najdete v menu <code>Applications</code> pod <code>Accessories</code> nebo <code>System</code>.

<pre class='screen cmdline'>
<samp class=p>you@localhost:~/Desktop$ </samp><kbd><mark>unzip httplib2-python3-0.5.0.zip</mark></kbd>
<samp>Archive:  httplib2-python3-0.5.0.zip
  inflating: httplib2-python3-0.5.0/README
  inflating: httplib2-python3-0.5.0/setup.py
  inflating: httplib2-python3-0.5.0/PKG-INFO
  inflating: httplib2-python3-0.5.0/httplib2/__init__.py
  inflating: httplib2-python3-0.5.0/httplib2/iri2uri.py</samp>
<samp class=p>you@localhost:~/Desktop$ </samp><kbd><mark>cd httplib2-python3-0.5.0/</mark></kbd>
<samp class=p>you@localhost:~/Desktop/httplib2-python3-0.5.0$ </samp><kbd><mark>sudo python3 setup.py install</mark></kbd>
<samp>running install
running build
running build_py
creating build
creating build/lib.linux-x86_64-3.1
creating build/lib.linux-x86_64-3.1/httplib2
copying httplib2/iri2uri.py -> build/lib.linux-x86_64-3.1/httplib2
copying httplib2/__init__.py -> build/lib.linux-x86_64-3.1/httplib2
running install_lib
creating /usr/local/lib/python3.1/dist-packages/httplib2
copying build/lib.linux-x86_64-3.1/httplib2/iri2uri.py -> /usr/local/lib/python3.1/dist-packages/httplib2
copying build/lib.linux-x86_64-3.1/httplib2/__init__.py -> /usr/local/lib/python3.1/dist-packages/httplib2
byte-compiling /usr/local/lib/python3.1/dist-packages/httplib2/iri2uri.py to iri2uri.pyc
byte-compiling /usr/local/lib/python3.1/dist-packages/httplib2/__init__.py to __init__.pyc
running install_egg_info
Writing /usr/local/lib/python3.1/dist-packages/httplib2-python3_0.5.0.egg-info</samp></pre>

<p>Abychom mohli <code>httplib2</code> používat, vytvoříme instanci třídy <code>httplib2.Http</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import httplib2</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>h = httplib2.Http('.cache')</kbd>                                                    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>response, content = h.request('http://diveintopython3.org/examples/feed.xml')</kbd>  <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>response.status</kbd>                                                                <span class=u>&#x2462;</span></a>
<samp class=pp>200</samp>
<a><samp class=p>>>> </samp><kbd class=pp>content[:52]</kbd>                                                                   <span class=u>&#x2463;</span></a>
<samp class=pp>b"&lt;?xml version='1.0' encoding='utf-8'?>\r\n&lt;feed xmlns="</samp>
<samp class=p>>>> </samp><kbd class=pp>len(content)</kbd>
<samp class=pp>3070</samp></pre>
<ol>
<li>Primárním rozhraním k <code>httplib2</code> je objekt třídy <code>Http</code>. Z důvodů, které si ukážeme v další podkapitole, bychom při vytváření objektu třídy <code>Http</code> měli vždy předávat jméno adresáře. Adresář nemusí existovat. V případě potřeby si jej <code>httplib2</code> vytvoří.
<li>Jakmile máme objekt třídy <code>Http</code> k dispozici, můžeme data získat jednoduše tím, že zavoláme metodu <code>request()</code> a předáme jí adresu dat. Pro dané <abbr>URL</abbr> se tím vytvoří požadavek <abbr>HTTP</abbr> <code>GET</code>. (Později v této kapitole si ukážeme, jak můžeme vytvořit jiné <abbr>HTTP</abbr> požadavky, jako například <code>POST</code>.)
<li>Metoda <code>request()</code> vrací dvě hodnoty. První hodnotou je objekt třídy <code>httplib2.Response</code>, který obsahuje všechny <abbr>HTTP</abbr> hlavičky vrácené serverem. Například hodnota stavového kódu (<code>status</code>) <code>200</code> indikuje, že byl dotaz proveden úspěšně.
<li>Proměnná <var>content</var> obsahuje data, která <abbr>HTTP</abbr> server vrátil. Data se vracejí jako <a href=#strings-byte-arrays>objekt typu <code>bytes</code>, nikoliv jako řetězec</a>. Pokud z toho chceme udělat řetězec, musíme <a href="http://feedparser.org/docs/character-encoding.html">zjistit znakové kódování</a> a převést si je sami.
</ol>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Pravděpodobně budete potřebovat jen jeden objekt třídy <code>httplib2.Http</code>. Existují rozumné důvody pro vytváření více než jednoho objektu, ale měli byste to dělat jen v případě, kdy víte, proč je potřebujete. „Potřebuji získávat data ze dvou různých <abbr>URL</abbr>“ takovým důvodem není. Použijte objekt třídy <code>Http</code> znovu &mdash; prostě zavolejte metodu <code>request()</code> dvakrát.
</blockquote>

<h3 id=http-web-services-why-bytes>Krátká odbočka vysvětlující, proč <code>httplib2</code> vrací bajty místo řetězců</h3>

<p>Bajty. Řetězce. To je bolest. Proč <code>httplib2</code> nemůže „jednoduše“ provést konverzi za nás? No, ono je to komplikované, protože pravidla pro zjištění znakového kódování jsou specifická v závislosti na tom, jaký zdroj (resource) požadujeme. Jak by mohla <code>httplib2</code> vědět, jaký druh zdroje požadujeme? Obvykle bývá uveden v <abbr>HTTP</abbr> hlavičce <code>Content-Type</code>, ale tato hlavička je v <abbr>HTTP</abbr> nepovinná a ne všechny <abbr>HTTP</abbr> servery ji vkládají. Pokud tato hlavička není součástí <abbr>HTTP</abbr> odpovědi, ponechává se odhad na klientovi. (Říká se tomu anglicky „content sniffing“ čili „čmuchání v obsahu“. Výsledek není nikdy perfektní.)

<p>Pokud víme, jaký druh dat očekáváme (v našem případě <abbr>XML</abbr> dokument), mohli bychom „jednoduše“ předat objekt typu <code>bytes</code> <a href=#xml-xml-parse>funkci <code>xml.etree.ElementTree.parse()</code></a>. To by fungovalo, kdyby <abbr>XML</abbr> dokument obsahoval informaci o svém vlastním kódování znaků (jako je tomu v tomto případě). Ale jde o nepovinný údaj a ne všechny <abbr>XML</abbr> dokumenty ho používají. Pokud <abbr>XML</abbr> dokument informaci o kódování neobsahuje, měl by se klient podívat na transportní obálku&nbsp;&mdash;&nbsp;tj. na <abbr>HTTP</abbr> hlavičku <code>Content-Type</code>, která by mohla parametr <code>charset</code> obsahovat.

<p class=ss><a style="border:0" href="http://www.cafepress.com/feedparser"><img src="http://feedparser.org/img/feedparser.jpg" alt="[Tričko podporuji RFC 3023]" width="150" height="150" /></a>

<p>Ale ono je to ještě horší. Teď už může být informace o kódování uvedena na dvou místech: uvnitř samotného <abbr>XML</abbr>dokumentu a uvnitř <abbr>HTTP</abbr> hlavičky <code>Content-Type</code>. Jenže když je tato informace uvedena <em>na obou</em> místech, které z nich vyhraje? Podle <a href="http://www.ietf.org/rfc/rfc3023.txt">RFC 3023</a> platí (a přísahám, to jsem si nevymyslel): pokud je v <abbr>HTTP</abbr> hlavičce <code>Content-Type</code> uveden typ média <code>application/xml</code>, <code>application/xml-dtd</code>, <code>application/xml-external-parsed-entity</code> nebo libovolný z podtypů <code>application/xml</code>, jako je <code>application/atom+xml</code> nebo <code>application/rss+xml</code> nebo dokonce <code>application/rdf+xml</code>, pak je kódování rovno

<ol>
<li>kódování zadanému parametrem <code>charset</code> v <abbr>HTTP</abbr> hlavičce <code>Content-Type</code> nebo
<li>kódování zadanému atributem <code>encoding</code> v <abbr>XML</abbr> deklaraci uvnitř dokumentu nebo
<li><abbr>UTF-8</abbr>
</ol>

<p>Na druhou stranu, pokud je v <abbr>HTTP</abbr> hlavičce <code>Content-Type</code> uveden typ média <code>text/xml</code>, <code>text/xml-external-parsed-entity</code> nebo podtyp jako <code>text/AnythingAtAll+xml</code>, pak se atribut uvádějící kódování v <abbr>XML</abbr> deklaraci uvnitř dokumentu zcela ignoruje a kódování je rovno

<ol>
<li>kódování zadanému parametrem charset v <abbr>HTTP</abbr> hlavičce <code>Content-Type</code> nebo
<li><code>us-ascii</code>
</ol>

<p>A to se bavíme jen o <abbr>XML</abbr> dokumentech. Pro <abbr>HTML</abbr> dokumenty vytvořily webové prohlížeče taková <a type="application/pdf" href="http://www.adambarth.com/papers/2009/barth-caballero-song.pdf">byzantská pravidla pro zjišťování obsahu (content-sniffing)</a> [<abbr>PDF</abbr>], že se <a href="http://www.google.com/search?q=barth+content-type+processing+model">stále ještě snažíme všechna zjistit</a>.

<p>„<a href="http://code.google.com/p/httplib2/source/checkout">Opravy jsou vítány</a>.“

<h3 id=http-web-services-httplib2-caching>Jak <code>httplib2</code> zachází s mezipamětí</h3>

<p>Vzpomínáte si, že jsem vás v předchozí podkapitole nabádal, abyste vždy vytvářeli objekt třídy <code>httplib2.Http</code> se zadaným jménem adresáře? Důvod se jmenuje mezipaměť (cache).

<pre class=screen>
# pokračování z <a href=#http-web-services-introducing-httplib2>předchozího příkladu</a>
<a><samp class=p>>>> </samp><kbd class=pp>response2, content2 = h.request('http://diveintopython3.org/examples/feed.xml')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>response2.status</kbd>                                                                 <span class=u>&#x2461;</span></a>
<samp class=pp>200</samp>
<a><samp class=p>>>> </samp><kbd class=pp>content2[:52]</kbd>                                                                    <span class=u>&#x2462;</span></a>
<samp class=pp>b"&lt;?xml version='1.0' encoding='utf-8'?>\r\n&lt;feed xmlns="</samp>
<samp class=p>>>> </samp><kbd class=pp>len(content2)</kbd>
<samp class=pp>3070</samp></pre>
<ol>
<li>Tohle by vás nemělo moc překvapit. Stejnou věc už jsme dělali naposledy s tou výjimkou, že výsledek ukládáme do dvou nových proměnných.
<li><abbr>HTTP</abbr> opět vrací stavový kód (<code>status</code>) <code>200</code>, jako minule.
<li>Stažený obsah je také stejný jako minule.
</ol>

<p>Takže&hellip; koho to zajímá? Ukončete pythonovský interaktivní shell a spusťte nové sezení. Hned vám to ukážu.

<pre class=screen>
# toto NENÍ pokračování z předchozího příkladu!
# Ukončete, prosím, interaktivní shell
# a spusťte nový.
<samp class=p>>>> </samp><kbd class=pp>import httplib2</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>httplib2.debuglevel = 1</kbd>                                                        <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>h = httplib2.Http('.cache')</kbd>                                                    <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>response, content = h.request('http://diveintopython3.org/examples/feed.xml')</kbd>  <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>len(content)</kbd>                                                                   <span class=u>&#x2463;</span></a>
<samp class=pp>3070</samp>
<a><samp class=p>>>> </samp><kbd class=pp>response.status</kbd>                                                                <span class=u>&#x2464;</span></a>
<samp class=pp>200</samp>
<a><samp class=p>>>> </samp><kbd class=pp>response.fromcache</kbd>                                                             <span class=u>&#x2465;</span></a>
<samp class=pp>True</samp></pre>
<ol>
<li>Zapněme ladění a podívejme se, <a href=#http-web-services-whats-on-the-wire>co nám lítá po drátech</a>. Takto se v <code>httplib2</code> zapíná ladicí režim (srovnejte se zapínáním v <code>http.client</code>). <code>httplib2</code> vytiskne všechna data, která se posílají na server, a některé klíčové informace, které se posílají zpět.
<li>Vytvoříme objekt třídy <code>httplib2.Http</code> se stejným jménem adresáře jako minule.
<li>Vyžádáme si stejné <abbr>URL</abbr> jako minule. <em>Zdá se, že se nic nestalo.</em> Přesněji řečeno, nic se neposílá na server a ze serveru se nic nevrací. Na síti nepozorujeme vůbec žádnou aktivitu.
<li>Přesto jsme nějaká data „přijali“&nbsp;&mdash;&nbsp;ve skutečnosti jsme dostali všechno.
<li>A „přijali“ jsme také stavový kód protokolu <abbr>HTTP</abbr>, který říká, že „požadavek“ byl úspěšný.
<li>Tady je důvod: „odpověď“ byla vygenerována z lokální mezipaměti <code>httplib2</code>. Adresář, jehož jméno jsme zadávali při vytváření objektu třídy <code>httplib2.Http</code>, slouží knihovně <code>httplib2</code> jako mezipaměť (cache) pro všechny operace, které se kdy provedly.
</ol>

<aside>Co se děje na drátě? Vůbec nic.</aside>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Pokud chcete v <code>httplib2</code> zapnout ladicí režim, musíte nastavit konstantu na úrovni modulu (<code>httplib2.debuglevel</code>) a potom vytvořit nový objekt třídy <code>httplib2.Http</code>. Pokud chcete ladicí režim vypnout, musíte změnit tutéž konstantu na úrovni modulu a potom vytvořit nový objekt třídy <code>httplib2.Http</code>.
</blockquote>

<p>Minule jsme požadovali data z konkrétního <abbr>URL</abbr>. Požadavek byl úspěšný (<code>status: 200</code>). Odpověď zahrnovala nejen data publikovaného obsahu, ale také množinu <a href=#http-web-services-caching>hlaviček pro mezipaměť</a> (caching headers). Ty každému příjemci říkají, že si tento zdroj může pamatovat po dobu až 24 hodin (<code>Cache-Control: max-age=86400</code>, což je 24 hodin v sekundách). <code>httplib2</code> hlavičkám pro mezipaměť rozumí a respektuje je. Předchozí odpověď byla uložena do adresáře <code>.cache</code> (jehož jméno jsme zadali při vytváření objektu třídy <code>Http</code>). Platnost obsahu mezipaměti zatím nevypršela, takže když data ze stejného <abbr>URL</abbr> požadujeme podruhé, <code>httplib2</code> jednoduše vrátí zapamatovaný výsledek, aniž by došlo ke komunikaci po síti.

<p>Říkám „jednoduše“, ale za touto jednoduchostí je evidentně skryto hodně složitostí. Knihovna <code>httplib2</code> zvládá používání mezipaměti v <abbr>HTTP</abbr> <em>automaticky</em> a <em>aniž se o to musíme starat</em>. Pokud z nějakého důvodu potřebujeme vědět, zda odpověď přichází z mezipaměti, můžeme zkontrolovat <code>response.fromcache</code>. Z jiného pohledu&hellip; prostě to funguje.

<p id=http-web-services-bypass-the-cache>Dejme tomu, že teď máme data v mezipaměti, ale chceme ji obejít a znovu si je vyžádat od vzdáleného serveru. Prohlížeče to někdy dělají, když si to uživatel vyžádá. Například stisk <kbd>F5</kbd> obnoví aktuální stránku, ale stiskem <kbd>Ctrl+F5</kbd> se obejde mezipaměť a aktuální stránka se znovu vyžádá ze vzdáleného serveru. Možná si myslíte „aha, prostě smažu data ze své lokální mezipaměti a provedu požadavek znovu“. Tohle byste udělat mohli. Ale vzpomeňte si, že se to může týkat více stran než jen vás a vzdáleného serveru. Což takhle mezilehlé proxy-servery? Ty jsou zcela mimo vaši kontrolu a pořád mohou uchovávat ona data ve své mezipaměti. A s radostí vám je vrátí, protože obsah jejich mezipaměti je (z jejich pohledu) stále platný.

<p>Takže místo toho, abyste manipulovali s lokální mezipamětí a doufali v nejlepší, měli byste využít vlastností <abbr>HTTP</abbr> k zajištění toho, že se váš požadavek skutečně dostal až ke vzdálenému serveru.

<pre class=screen>
# pokračování předchozího příkladu
<samp class=p>>>> </samp><kbd class=pp>response2, content2 = h.request('http://diveintopython3.org/examples/feed.xml',</kbd>
<a><samp class=p>... </samp><kbd class=pp>    headers={'cache-control':'no-cache'})</kbd>  <span class=u>&#x2460;</span></a>
<samp><a>connect: (diveintopython3.org, 80)             <span class=u>&#x2461;</span></a>
send: b'GET /examples/feed.xml HTTP/1.1
Host: diveintopython3.org
user-agent: Python-httplib2/$Rev: 259 $
accept-encoding: deflate, gzip
cache-control: no-cache'
reply: 'HTTP/1.1 200 OK'
&hellip;further debugging information omitted&hellip;</samp>
<samp class=p>>>> </samp><kbd class=pp>response2.status</kbd>
<samp class=pp>200</samp>
<a><samp class=p>>>> </samp><kbd class=pp>response2.fromcache</kbd>                        <span class=u>&#x2462;</span></a>
<samp class=pp>False</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(dict(response2.items()))</kbd>             <span class=u>&#x2463;</span></a>
<samp class=pp>{'status': '200',
 'content-length': '3070',
 'content-location': 'http://diveintopython3.org/examples/feed.xml',
 'accept-ranges': 'bytes',
 'expires': 'Wed, 03 Jun 2009 00:40:26 GMT',
 'vary': 'Accept-Encoding',
 'server': 'Apache',
 'last-modified': 'Sun, 31 May 2009 22:51:11 GMT',
 'connection': 'close',
 '-content-encoding': 'gzip',
 'etag': '"bfe-255ef5c0"',
 'cache-control': 'max-age=86400',
 'date': 'Tue, 02 Jun 2009 00:40:26 GMT',
 'content-type': 'application/xml'}</samp></pre>
<ol>
<li><code>httplib2</code> vám umožní přidat k jakémukoliv odcházejícímu požadavku libovolné <abbr>HTTP</abbr> hlavičky. Abychom obešli <em>všechny</em> mezipaměti (nejen lokální diskovou, ale také mezipaměťové proxy-servery mezi námi a vzdáleným serverem), přidáme do slovníku <var>headers</var> hlavičku <code>no-cache</code>.
<li>Teď vidíme, že <code>httplib2</code> zahajuje síťový požadavek. <code>httplib2</code> rozumí hlavičkám pro mezipaměť a respektuje je <em>v obou směrech</em>&nbsp;&mdash;&nbsp;jako součást přicházející odpovědi <em>i jako součást odcházejícího požadavku</em>. Knihovna si všimla, že jsme přidali hlavičku <code>no-cache</code>, takže úplně obešla své lokální mezipaměti. Potom ale nemá na výběr a musí odeslat požadavek na data do sítě.
<li>Tato odpověď <em>nebyla</em> generovaná z naší lokální mezipaměti. To samozřejmě víme, protože jsme viděli ladicí informaci týkající se odcházejícího požadavku. Ale je dobré, že si to můžeme ověřit v programu.
<li>Požadavek byl úspěšný. Opět jsme ze vzdáleného serveru stáhli celý publikovaný obsah (feed). Server samozřejmě poslal zpět s požadovanými daty (feed) i celou sadu <abbr>HTTP</abbr> hlaviček. Jsou mezi nimi i hlavičky pro mezipaměť, které <code>httplib2</code> použije pro aktualizaci své lokální mezipaměti v naději, že se při <em>příštím</em> požadavku na stejná data bude moci vyhnout přístupu na síť. Návrh používání mezipamětí v <abbr>HTTP</abbr> je zcela podřízen maximalizaci úspěšnosti mezipamětí (cache hit) a minimalizaci přístupu k síti. I když jsme tentokrát mezipaměti obešli, vzdálený server by opravdu ocenil, kdybychom si výsledek do mezipaměti uložili &mdash; s ohledem na příští možný dotaz.
</ol>

<h3 id=http-web-services-httplib2-etags>Jak <code>httplib2</code> zachází s hlavičkami <code>Last-Modified</code> a <code>ETag</code></h3>

<p><a href=#http-web-services-caching>Hlavičky mezipaměti</a> <code>Cache-Control</code> a <code>Expires</code> se nazývají <i>indikátory čerstvosti</i> (freshness indicators). Říkají mezipamětem jasným způsobem, že se do vypršení platnosti obsahu mezipaměti můžeme zcela vyhnout přístupu k síti. Přesně takové chování jsme viděli <a href=#http-web-services-httplib2-caching>v předchozí podkapitole</a>: pokud je indikována čerstvost, <code>httplib2</code> při vrácení dat z mezipaměti <em>negeneruje ani bajt síťové aktivity</em> (pokud ovšem explicitně nepředepíšeme <a href=#http-web-services-bypass-the-cache>obejití mezipaměti</a>).

<p>Ale jak to bude vypadat v případě, kdy se data <em>mohla</em> změnit, ale přitom se nezměnila? Pro tento účel <abbr>HTTP</abbr> definuje hlavičky <a href=#http-web-services-last-modified><code>Last-Modified</code></a> a <a href=#http-web-services-etags><code>Etag</code></a>. Těmto hlavičkám se říká <i>validátory</i>. Pokud už lokální mezipaměť není čerstvá, může klient s dalším dotazem zaslat validátory, aby si ověřil, zda se data skutečně změnila. Pokud se data nezměnila, server pošle zpět stavový kód <code>304</code> <em>a žádná data</em>. Takže tu sice stále dochází ke vzájemné komunikaci po síti, ale výsledkem je stahování menšího množství bajtů.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import httplib2</kbd>
<samp class=p>>>> </samp><kbd class=pp>httplib2.debuglevel = 1</kbd>
<samp class=p>>>> </samp><kbd class=pp>h = httplib2.Http('.cache')</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>response, content = h.request('http://diveintopython3.org/')</kbd>  <span class=u>&#x2460;</span></a>
<samp>connect: (diveintopython3.org, 80)
send: b'GET / HTTP/1.1
Host: diveintopython3.org
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $'
reply: 'HTTP/1.1 200 OK'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(dict(response.items()))</kbd>                                 <span class=u>&#x2461;</span></a>
<samp class=pp>{'-content-encoding': 'gzip',
 'accept-ranges': 'bytes',
 'connection': 'close',
 'content-length': '6657',
 'content-location': 'http://diveintopython3.org/',
 'content-type': 'text/html',
 'date': 'Tue, 02 Jun 2009 03:26:54 GMT',
<mark> 'etag': '"7f806d-1a01-9fb97900"',</mark>
<mark> 'last-modified': 'Tue, 02 Jun 2009 02:51:48 GMT',</mark>
 'server': 'Apache',
 'status': '200',
 'vary': 'Accept-Encoding,User-Agent'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(content)</kbd>                                                  <span class=u>&#x2462;</span></a>
<samp class=pp>6657</samp></pre>
<ol>
<li>Místo publikovaného obsahu (feed) budeme tentokrát stahovat domácí stránku webového místa (home page), která je v <abbr>HTML</abbr>. Protože tuto stránku požadujeme úplně poprvé, nemůže <code>httplib2</code> s požadavkem nic moc udělat a odešle s ním minimum hlaviček.
<li>Odpověď obsahuje velké množství <abbr>HTTP</abbr> hlaviček&hellip; ale žádné informace pro mezipaměť. Ale obsahuje jak hlavičku <code>ETag</code>, tak hlavičku <code>Last-Modified</code>.
<li>V době vytváření příkladu měla stránka 6657 bajtů. Od té doby už se pravděpodobně změnila, ale tím se nebudeme zatěžovat.
</ol>

<pre class=screen>
# pokračování z předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>response, content = h.request('http://diveintopython3.org/')</kbd>  <span class=u>&#x2460;</span></a>
<samp>connect: (diveintopython3.org, 80)
send: b'GET / HTTP/1.1
Host: diveintopython3.org
<a>if-none-match: "7f806d-1a01-9fb97900"                             <span class=u>&#x2461;</span></a>
<a>if-modified-since: Tue, 02 Jun 2009 02:51:48 GMT                  <span class=u>&#x2462;</span></a>
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $'
<a>reply: 'HTTP/1.1 304 Not Modified'                                <span class=u>&#x2463;</span></a></samp>
<a><samp class=p>>>> </samp><kbd class=pp>response.fromcache</kbd>                                            <span class=u>&#x2464;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>response.status</kbd>                                               <span class=u>&#x2465;</span></a>
<samp class=pp>200</samp>
<a><samp class=p>>>> </samp><kbd class=pp>response.dict['status']</kbd>                                       <span class=u>&#x2466;</span></a>
<samp class=pp>'304'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(content)</kbd>                                                  <span class=u>&#x2467;</span></a>
<samp class=pp>6657</samp></pre>
<ol>
<li>O stejnou stránku jsme požádali znovu, prostřednictvím stejného objektu třídy <code>Http</code> (a se stejnou lokální mezipamětí).
<li><code>httplib2</code> pošle serveru zpět validátor <code>ETag</code> jako obsah hlavičky <code>If-None-Match</code>.
<li><code>httplib2</code> pošle zpět serveru také validátor <code>Last-Modified</code> jako hodnotu hlavičky <code>If-Modified-Since</code>.
<li>Server se podívá na zaslané validátory, podívá se na požadovanou stránku a zjistí, že se stránka od posledního požadavku nezměnila. Proto pošle zpět stavový kód <code>304</code> <em>a žádná data</em>.
<li>A zpět ke klientovi. <code>httplib2</code> obdrží stavový kód <code>304</code> a načte obsah stránky ze své mezipaměti.
<li>Tohle může být trošku matoucí. Ve skutečnosti tu máme <em>dva</em> stavové kódy&nbsp;&mdash;&nbsp;<code>304</code> (který vrátil server teď a který způsobil, že <code>httplib2</code> použije svou mezipaměť) a <code>200</code> (který vrátil server <em>minule</em> a který je spolu s daty uložen v mezipaměti pro <code>httplib2</code>). <code>response.status</code> vrací stavový kód odpovědi z mezipaměti.
<li>Pokud chceme zjistit surový stavový kód vrácený serverem, můžeme jej zjistit nahlédnutím do <code>response.dict</code>, což je slovník aktuálních hlaviček vrácených serverem.
<li>Ať je to jakkoliv, data opět získáte v proměnné <var>content</var>. Obecně vzato, nepotřebujeme vědět, proč byl požadavek obsloužen z mezipaměti. (Dokonce nás nemusí vůbec zajímat, že byl obsloužen z mezipaměti. To je v pořádku. Knihovna <code>httplib2</code> je dost chytrá na to, abychom si mohli hrát na hlupáky.) V tomto okamžiku už metoda <code>request()</code> vrátila řízení volajícímu kódu. <code>httplib2</code> už aktualizovala svou mezipaměť a vrátila nám data.
</ol>

<h3 id=http-web-services-httplib2-compression>Jak <code>http2lib</code> pracuje s kompresí</h3>

<aside>“We have both kinds of music, country AND western.”<br>(Máme oba druhy hudby, country i western.)</aside>

<p><abbr>HTTP</abbr> podporuje <a href=#http-web-services-compression>několik typů komprese</a>. Dva nejpoužívanější typy jsou gzip a deflate. <code>httplib2</code> podporuje oba.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>response, content = h.request('http://diveintopython3.org/')</kbd>
<samp>connect: (diveintopython3.org, 80)
send: b'GET / HTTP/1.1
Host: diveintopython3.org
<a>accept-encoding: deflate, gzip                          <span class=u>&#x2460;</span></a>
user-agent: Python-httplib2/$Rev: 259 $'
reply: 'HTTP/1.1 200 OK'</samp>
<samp class=p>>>> </samp><kbd class=pp>print(dict(response.items()))</kbd>
<samp class=pp><a>{'-content-encoding': 'gzip',                           <span class=u>&#x2461;</span></a>
 'accept-ranges': 'bytes',
 'connection': 'close',
 'content-length': '6657',
 'content-location': 'http://diveintopython3.org/',
 'content-type': 'text/html',
 'date': 'Tue, 02 Jun 2009 03:26:54 GMT',
 'etag': '"7f806d-1a01-9fb97900"',
 'last-modified': 'Tue, 02 Jun 2009 02:51:48 GMT',
 'server': 'Apache',
 'status': '304',
 'vary': 'Accept-Encoding,User-Agent'}</samp></pre>
<ol>
<li>Pokaždé když <code>httplib2</code> odešle požadavek, vloží do něj hlavičku <code>Accept-Encoding</code>, kterou serveru oznámí, že zvládá jak kompresi <code>deflate</code>, tak <code>gzip</code>.
<li>V tomto případě server odpověděl daty komprimovanými algoritmem gzip. V tomto okamžiku metoda <code>request()</code> vrací řízení, <code>httplib2</code> dekomprimovala (rozbalila) tělo odpovědi a umístila je do proměnné <var>content</var>. Pokud jste zvědaví, jestli odpověď přišla komprimovaná, můžete zkontrolovat <var>response['-content-encoding']</var>. Ale jinak si s tím nemusíte dělat starosti.
</ol>

<h3 id=http-web-services-httplib2-redirects>Jak <code>httplib2</code> řeší přesměrování</h3>

<p><abbr>HTTP</abbr> definuje <a href=#http-web-services-redirects>dva druhy přesměrování</a>: dočasné a trvalé. U dočasných přesměrování se nedělá nic zvláštního až na to, že se mají následovat (follow), což <code>httplib2</code> provede automaticky.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import httplib2</kbd>
<samp class=p>>>> </samp><kbd class=pp>httplib2.debuglevel = 1</kbd>
<samp class=p>>>> </samp><kbd class=pp>h = httplib2.Http('.cache')</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>response, content = h.request('http://diveintopython3.org/examples/feed-302.xml')</kbd>  <span class=u>&#x2460;</span></a>
<samp>connect: (diveintopython3.org, 80)
<a>send: b'GET /examples/feed-302.xml HTTP/1.1                                            <span class=u>&#x2461;</span></a>
Host: diveintopython3.org
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $'
<a>reply: 'HTTP/1.1 302 Found'                                                            <span class=u>&#x2462;</span></a>
<a>send: b'GET /examples/feed.xml HTTP/1.1                                                <span class=u>&#x2463;</span></a>
Host: diveintopython3.org
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $'
reply: 'HTTP/1.1 200 OK'</samp></pre>
<ol>
<li>Na tomto <abbr>URL</abbr> není žádný publikovaný obsah. Nastavil jsem svůj server, aby signalizoval dočasné přesměrování na správnou adresu.
<li>Tady je náš požadavek.
<li>A tady je odpověď: <code>302 Found</code>. I když se to zde nezobrazuje, odpověď obsahuje také hlavičku <code>Location</code>, která ukazuje na skutečné <abbr>URL</abbr>.
<li><code>httplib2</code> se ihned otočí a „následuje“ přesměrování vydáním dalšího požadavku na <abbr>URL</abbr>, které je uvedeno v hlavičce <code>Location</code>: <code>http://diveintopython3.org/examples/feed.xml</code>
</ol>

<p>„Následování“ přesměrování není nic jiného, než co ukazuje tento příklad. <code>httplib2</code> pošle požadavek pro <abbr>URL</abbr>, které jsme požadovali. Server odvětí odpovědí, která říká: „Ne ne. Místo toho se podívejte támhle.“ <code>httplib2</code> odešle další požadavek pro nové <abbr>URL</abbr>.

<pre class=screen>
# pokračování z předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>response</kbd>                                                          <span class=u>&#x2460;</span></a>
<samp class=pp>{'status': '200',
 'content-length': '3070',
<a> 'content-location': 'http://diveintopython3.org/examples/feed.xml',  <span class=u>&#x2461;</span></a>
 'accept-ranges': 'bytes',
 'expires': 'Thu, 04 Jun 2009 02:21:41 GMT',
 'vary': 'Accept-Encoding',
 'server': 'Apache',
 'last-modified': 'Wed, 03 Jun 2009 02:20:15 GMT',
 'connection': 'close',
<a> '-content-encoding': 'gzip',                                         <span class=u>&#x2462;</span></a>
 'etag': '"bfe-4cbbf5c0"',
<a> 'cache-control': 'max-age=86400',                                    <span class=u>&#x2463;</span></a>
 'date': 'Wed, 03 Jun 2009 02:21:41 GMT',
 'content-type': 'application/xml'}</samp></pre>
<ol>
<li>Odpověď (<var>response</var>), kterou jste obdrželi z jediného volání metody <code>request()</code>, je odpovědí z konečného <abbr>URL</abbr>.
<li><code>httplib2</code> přidá konečné <abbr>URL</abbr> do slovníku <var>response</var> jako <code>content-location</code>. Nejde o hlavičku, která by přišla ze serveru. Je to záležitost specifická pro <code>httplib2</code>.
<li>Jen abych nezapomněl, tento feed je <a href=#http-web-services-httplib2-compression>komprimovaný</a>.
<li>A uchovatelný v mezipaměti (cacheable). (To je důležité &mdash; jak uvidíme za minutku.)
</ol>

<p>Slovník <var>response</var>, který se nám vrátí, poskytuje informace <em>o konečném</em> <abbr>URL</abbr>. A co když chceme informace o přechodných <abbr>URL</abbr>, tedy o těch, která byla přesměrována na konečné <abbr>URL</abbr>? <code>httplib2</code> nám umožní i to.

<pre class=screen>
# pokračování z předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>response.previous</kbd>                                                     <span class=u>&#x2460;</span></a>
<samp class=pp>{'status': '302',
 'content-length': '228',
 'content-location': 'http://diveintopython3.org/examples/feed-302.xml',
 'expires': 'Thu, 04 Jun 2009 02:21:41 GMT',
 'server': 'Apache',
 'connection': 'close',
 'location': 'http://diveintopython3.org/examples/feed.xml',
 'cache-control': 'max-age=86400',
 'date': 'Wed, 03 Jun 2009 02:21:41 GMT',
 'content-type': 'text/html; charset=iso-8859-1'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(response)</kbd>                                                        <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;class 'httplib2.Response'></samp>
<samp class=p>>>> </samp><kbd class=pp>type(response.previous)</kbd>
<samp class=pp>&lt;class 'httplib2.Response'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>response.previous.previous</kbd>                                            <span class=u>&#x2462;</span></a>
<samp class=p>>>></samp></pre>
<ol>
<li>Atribut <var>response.previous</var> uchovává referenci na předchozí objekt odpovědi, který <code>httplib2</code> následovala, aby získala současný objekt odpovědi.
<li>Jak <var>response</var>, tak <var>response.previous</var> jsou objekty třídy <code>httplib2.Response</code>.
<li>To znamená, že můžeme řetězec přesměrování sledovat zpětně ještě dál kontrolou <var>response.previous.previous</var>. (Scénář: jedno <abbr>URL</abbr> je přesměrováno na druhé <abbr>URL</abbr>, které je přesměrováno na třetí <abbr>URL</abbr>. To se opravdu může stát!) V tomto případě už jsme dosáhli začátku řetězce přesměrování, takže atribut má hodnotu <code>None</code>.
</ol>

<p>Co se stane, když si vyžádáme stejné <abbr>URL</abbr> znovu?

<pre class=screen>
# pokračování z předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>response2, content2 = h.request('http://diveintopython3.org/examples/feed-302.xml')</kbd>  <span class=u>&#x2460;</span></a>
<samp>connect: (diveintopython3.org, 80)
<a>send: b'GET /examples/feed-302.xml HTTP/1.1                                              <span class=u>&#x2461;</span></a>
Host: diveintopython3.org
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $'
<a>reply: 'HTTP/1.1 302 Found'                                                              <span class=u>&#x2462;</span></a></samp>
<a><samp class=p>>>> </samp><kbd class=pp>content2 == content</kbd>                                                                  <span class=u>&#x2463;</span></a>
<samp class=pp>True</samp></pre>
<ol>
<li>Stejné <abbr>URL</abbr>, stejný objekt třídy <code>httplib2.Http</code> (a tím pádem stejná mezipaměť).
<li>Odpověď <code>302</code> nebyla v mezipaměti, takže <code>httplib2</code> pošle pro stejné <abbr>URL</abbr> další požadavek.
<li>A ještě jednou, server odpovídá kódem <code>302</code>. Ale všimněte si, co se <em>nestalo</em>: chybí druhý dotaz na konečné <abbr>URL</abbr>, <code>http://diveintopython3.org/examples/feed.xml</code>. Tato odpověď byla v mezipaměti (vzpomeňte si na hlavičku <code>Cache-Control</code>, kterou jsme viděli v předchozím příkladu). Jakmile <code>httplib2</code> obdržela kód <code>302 Found</code>, <em>zkontrolovala si před vydáním dalšího požadavku obsah mezipaměti</em>. Mezipaměť obsahovala čerstvou kopii <code>http://diveintopython3.org/examples/feed.xml</code>, takže nebylo nutné žádat o data znovu.
<li>V tomto okamžiku dochází k návratu z metody <code>request()</code>. Přečetla data publikovaného obsahu (feed) z mezipaměti a vrátila je. Jde samozřejmě o stejná data, která jsme obdrželi minule.
</ol>

<p>Jinými slovy, při dočasném přesměrování nemusíme dělat nic zvláštního. <code>httplib2</code> je bude následovat automaticky. Skutečnost, že je jedno <abbr>URL</abbr> přesměrováno na jiné, nemá na <code>httplib2</code> žádné dopady z hlediska podpory komprese, použití mezipaměti, <code>ETag</code>ů nebo jakýchkoliv jiných rysů <abbr>HTTP</abbr>.

<p>Trvalá přesměrování jsou stejně jednoduchá.

<pre class=screen>
# pokračování z předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>response, content = h.request('http://diveintopython3.org/examples/feed-301.xml')</kbd>  <span class=u>&#x2460;</span></a>
<samp>connect: (diveintopython3.org, 80)
send: b'GET /examples/feed-301.xml HTTP/1.1
Host: diveintopython3.org
accept-encoding: deflate, gzip
user-agent: Python-httplib2/$Rev: 259 $'
<a>reply: 'HTTP/1.1 301 Moved Permanently'                                                <span class=u>&#x2461;</span></a></samp>
<a><samp class=p>>>> </samp><kbd class=pp>response.fromcache</kbd>                                                                 <span class=u>&#x2462;</span></a>
<samp class=pp>True</samp></pre>
<ol>
<li>Ještě jednou. Toto <abbr>URL</abbr> ve skutečnosti neexistuje. Nastavil jsem svůj server, aby produkoval trvalé přesměrování na <code>http://diveintopython3.org/examples/feed.xml</code>.
<li>A tady to máme: stavový kód <code>301</code>. Ale znovu si všimněte, co se <em>nestalo</em>: neobjevil se žádný požadavek na přesměrované <abbr>URL</abbr>. Proč ne? Protože už se nachází v lokální mezipaměti.
<li><code>httplib2</code> „následovala“ přesměrování přímo do své mezipaměti.
</ol>

<p>Ale počkejte! Ono je toho ještě víc!

<pre class=screen>
# pokračování z předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>response2, content2 = h.request('http://diveintopython3.org/examples/feed-301.xml')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>response2.fromcache</kbd>                                                                  <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>content2 == content</kbd>                                                                  <span class=u>&#x2462;</span></a>
<samp class=pp>True</samp>
</pre>
<ol>
<li>Tady je ten rozdíl mezi dočasným a trvalým přesměrováním: jakmile jednou <code>httplib2</code> následuje trvalé přesměrování, všechny další požadavky se stejným <abbr>URL</abbr> budou transparentně přepsány na cílové <abbr>URL</abbr> <em>aniž se kvůli originálnímu <abbr>URL</abbr> komunikuje po síti</em>. Připomeňme si, že ladicí režim je pořád zapnutý. Přesto nevidíme vůbec žádný výstup síťové aktivity.
<li>Ano, tato odpověď byla vytažena z lokální mezipaměti.
<li>Ano, dostali jsme celý publikovaný obsah (z mezipaměti).
</ol>

<p><abbr>HTTP</abbr>. Funguje.

<p class=a>&#x2042;

<h2 id=http-web-services-beyond-get>Za hranicemi HTTP GET</h2>

<p>Webové služby nad <abbr>HTTP</abbr> se neomezují jen na požadavky typu <code>GET</code>. Co kdybychom chtěli vytvořit něco nového? Kdykoliv přidáte komentář do diskusního fóra, aktualizujete weblog, upravujete svůj stav na mikroblogové službě, jakou je <a href="http://twitter.com/">Twitter</a> nebo <a href="http://identi.ca/">Identi.ca</a>, používáte pravděpodobně <abbr>HTTP</abbr> <code>POST</code>.

<p>Jak Twitter, tak Identi.ca nabízejí pro zveřejňování a aktualizaci vašeho stavu, popsaného 140 nebo méně znaky, jednoduché rozhraní založené na <abbr>HTTP</abbr>. Podívejme se na dokumentaci aplikačního rozhraní pro aktualizaci vašeho stavu <a href="http://laconi.ca/trac/wiki/TwitterCompatibleAPI">v systému Identi.ca</a>.

<blockquote class=pf>
<p><b>Identi.ca <abbr>REST</abbr> <abbr>API</abbr> Metoda: statuses/update</b><br>
Aktualizuje stav autentizovaného uživatele. Vyžaduje parametr <code>status</code>, popsaný níže. Požadavek musí být typu <code>POST</code>.

<dl>
<dt><abbr>URL</abbr>
<dd><code>https://identi.ca/api/statuses/update.<i><var>format</var></i></code>
<dt>Formáty
<dd><code>xml</code>, <code>json</code>, <code>rss</code>, <code>atom</code>
<dt><abbr>HTTP</abbr> metod(y)
<dd><code>POST</code>
<dt>Vyžaduje autentizaci
<dd>ano
<dt>Parametry
<dd><code>status</code>. Povinný. Text aktualizace vašeho stavu. Kódované <abbr>URL</abbr> podle potřeby.
</dl>
</blockquote>

<p>Jak to funguje? Když chceme na Identi.ca zveřejnit novou zprávu, musíme zaslat požadavek typu <abbr>HTTP</abbr> <code>POST</code> na <code>http://identi.ca/api/statuses/update.<i>format</i></code>. (Část <var>format</var> nepatří k <abbr>URL</abbr>. Nahrazuje se datovým formátem, v jakém nám má server vrátit odpověď na náš požadavek. Takže pokud požadujeme odpověď v <abbr>XML</abbr>, musíme zaslat požadavek na <code>https://identi.ca/api/statuses/update.xml</code>.) Požadavek musí obsahovat parametr nazvaný <code>status</code>, který obsahuje text pro aktualizaci našeho stavu. A požadavek musí být autentizován.

<p>Autentizován? Jistě. Když chceme na Identi.ca aktualizovat svůj stav, musíme prokázat svou totožnost. Identi.ca není jako wiki. Svůj vlastní stav můžeme aktualizovat jen my. Pro účel bezpečné a snadno použitelné autentizace používá Identi.ca <a href="http://en.wikipedia.org/wiki/Basic_access_authentication"><abbr>HTTP</abbr> Basic Authentication</a> (základní autentizaci; známou také jako <a href="http://www.ietf.org/rfc/rfc2617.txt">RFC 2617</a>) přes <abbr>SSL</abbr>. <code>httplib2</code> podporuje jak <abbr>SSL</abbr>, tak <abbr>HTTP</abbr> Basic Authentication, takže tahle část bude snadná.

<p>Požadavek <code>POST</code> se od požadavku <code>GET</code> liší, protože nese <i>náklad</i>. Nákladem jsou data, která chceme poslat na server. Částí dat, kterou toto aplikační rozhraní metody <em>vyžaduje</em>, je <code>status</code> (stav) a měl by mít podobu <i>kódovaného <abbr>URL</abbr></i>. Je to velmi jednoduchý serializační formát. Vstupem je množina dvojic klíč-hodnota (tj. <a href=#native-datatypes-dictionaries>slovník</a>) a výsledkem je řetězec.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>from urllib.parse import urlencode</kbd>              <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>data = {'status': 'Test update from Python 3'}</kbd>  <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>urlencode(data)</kbd>                                 <span class=u>&#x2462;</span></a>
<samp>'status=Test+update+from+Python+3'</samp></pre>
<ol>
<li>V Pythonu pro zakódování slovníku do podoby <abbr>URL</abbr> najdeme pomocnou funkci: <code>urllib.parse.urlencode()</code>.
<li>Aplikační rozhraní systému Identi.ca očekává zhruba takovýto slovník. Obsahuje jeden klíč, <code>status</code>, jehož hodnotou je text jedné aktualizace stavu.
<li>A takto vypadá řetězec kódovaného <abbr>URL</abbr>. To je <i>náklad</i>, který bude požadavkem <abbr>HTTP</abbr> <code>POST</code> odeslán „po drátě“ na server s aplikačním rozhraním Identi.ca.
</ol>

<p>

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>from urllib.parse import urlencode</kbd>
<samp class=p>>>> </samp><kbd class=pp>import httplib2</kbd>
<samp class=p>>>> </samp><kbd class=pp>httplib2.debuglevel = 1</kbd>
<samp class=p>>>> </samp><kbd class=pp>h = httplib2.Http('.cache')</kbd>
<samp class=p>>>> </samp><kbd class=pp>data = {'status': 'Test update from Python 3'}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>h.add_credentials('diveintomark', '<var>MY_SECRET_PASSWORD</var>', 'identi.ca')</kbd>    <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>resp, content = h.request('https://identi.ca/api/statuses/update.xml',</kbd>
<a><samp class=p>... </samp><kbd class=pp>    'POST',</kbd>                                                             <span class=u>&#x2461;</span></a>
<a><samp class=p>... </samp><kbd class=pp>    urlencode(data),</kbd>                                                    <span class=u>&#x2462;</span></a>
<a><samp class=p>... </samp><kbd class=pp>    headers={'Content-Type': 'application/x-www-form-urlencoded'})</kbd>      <span class=u>&#x2463;</span></a></pre>
<ol>
<li>Tímto způsobem <code>httplib2</code> pracuje s autentizací. Jméno a heslo uložíme metodou <code>add_credentials()</code>. Když se <code>httplib2</code> pokusí o vydání požadavku, server odpoví stavovým kódem <code>401 Unauthorized</code> (neautorizováno) a připojí seznam autentizačních metod, které podporuje (v hlavičce <code>WWW-Authenticate</code>). <code>httplib2</code> automaticky vytvoří hlavičku <code>Authorization</code> a pošle požadavek s <abbr>URL</abbr> znovu.
<li>Druhý parametr uvádí typ <abbr>HTTP</abbr> požadavku. V tomto případě je to <code>POST</code>.
<li>Třetím parametrem je <i>náklad</i>, který se serveru posílá. Posíláme slovník se stavovou zprávou zakódovaný do podoby <abbr>URL</abbr>.
<li>Nakonec musíme serveru říct, že náklad má podobu dat zakódovaných do podoby <abbr>URL</abbr>.
</ol>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Třetím parametrem metody <code>add_credentials()</code> je doména, ve které osobní údaje platí. Měli byste ji vždy uvádět! Pokud doménu vynecháte a později znovu použijete objekt třídy <code>httplib2.Http</code> pro jiné autentizované místo, mohla by <code>httplib2</code> způsobit únik jména a hesla z jednoho místa na druhé místo (site).
</blockquote>

<p>A o čem zpívají dráty:

<pre class=screen>
# pokračování z předchozího příkladu
<samp>send: b'POST /api/statuses/update.xml HTTP/1.1
Host: identi.ca
Accept-Encoding: identity
Content-Length: 32
content-type: application/x-www-form-urlencoded
user-agent: Python-httplib2/$Rev: 259 $

status=Test+update+from+Python+3'
<a>reply: 'HTTP/1.1 401 Unauthorized'                        <span class=u>&#x2460;</span></a>
<a>send: b'POST /api/statuses/update.xml HTTP/1.1            <span class=u>&#x2461;</span></a>
Host: identi.ca
Accept-Encoding: identity
Content-Length: 32
content-type: application/x-www-form-urlencoded
<a>authorization: Basic SECRET_HASH_CONSTRUCTED_BY_HTTPLIB2  <span class=u>&#x2462;</span></a>
user-agent: Python-httplib2/$Rev: 259 $

status=Test+update+from+Python+3'
<a>reply: 'HTTP/1.1 200 OK'                                  <span class=u>&#x2463;</span></a></samp></pre>
<ol>
<li>Po prvním požadavku odpoví server stavovým kódem <code>401 Unauthorized</code>. <code>httplib2</code> nikdy neposílá autentizační hlavičky, pokud si o ně server explicitně neřekne. Server si o ně říká tímto způsobem.
<li><code>httplib2</code> okamžitě zareaguje opakovaným odesláním požadavku se stejným <abbr>URL</abbr>.
<li>Tentokrát obsahuje jméno a heslo, která jsme přidali metodou <code>add_credentials()</code>.
<li>Funguje to!
</ol>

<p>A co vlastně server posílá po úspěšném požadavku zpět? To zcela závisí na aplikačním rozhraní příslušné webové služby. V některých protokolech (jako například <a href="http://www.ietf.org/rfc/rfc5023.txt">Atom Publishing Protocol</a>) posílá server zpět stavový kód <code>201 Created</code> spolu s umístěním nově vytvořeného zdroje (resource) v hlavičce <code>Location</code>. Identi.ca posílá zpět <code>200 OK</code> a <abbr>XML</abbr> dokument, který obsahuje informace o nově vytvořeném zdroji.

<pre class=screen>
# pokračování z předchozího příkladu
<a><samp class=p>>>> </samp><kbd class=pp>print(content.decode('utf-8'))</kbd>                             <span class=u>&#x2460;</span></a>
<samp class=pp>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;status>
<a> &lt;text>Test update from Python 3&lt;/text>                        <span class=u>&#x2461;</span></a>
 &lt;truncated>false&lt;/truncated>
 &lt;created_at>Wed Jun 10 03:53:46 +0000 2009&lt;/created_at>
 &lt;in_reply_to_status_id>&lt;/in_reply_to_status_id>
 &lt;source>api&lt;/source>
<a> &lt;id>5131472&lt;/id>                                              <span class=u>&#x2462;</span></a>
 &lt;in_reply_to_user_id>&lt;/in_reply_to_user_id>
 &lt;in_reply_to_screen_name>&lt;/in_reply_to_screen_name>
 &lt;favorited>false&lt;/favorited>
 &lt;user>
  &lt;id>3212&lt;/id>
  &lt;name>Mark Pilgrim&lt;/name>
  &lt;screen_name>diveintomark&lt;/screen_name>
  &lt;location>27502, US&lt;/location>
  &lt;description>tech writer, husband, father&lt;/description>
  &lt;profile_image_url>http://avatar.identi.ca/3212-48-20081216000626.png&lt;/profile_image_url>
  &lt;url>http://diveintomark.org/&lt;/url>
  &lt;protected>false&lt;/protected>
  &lt;followers_count>329&lt;/followers_count>
  &lt;profile_background_color>&lt;/profile_background_color>
  &lt;profile_text_color>&lt;/profile_text_color>
  &lt;profile_link_color>&lt;/profile_link_color>
  &lt;profile_sidebar_fill_color>&lt;/profile_sidebar_fill_color>
  &lt;profile_sidebar_border_color>&lt;/profile_sidebar_border_color>
  &lt;friends_count>2&lt;/friends_count>
  &lt;created_at>Wed Jul 02 22:03:58 +0000 2008&lt;/created_at>
  &lt;favourites_count>30768&lt;/favourites_count>
  &lt;utc_offset>0&lt;/utc_offset>
  &lt;time_zone>UTC&lt;/time_zone>
  &lt;profile_background_image_url>&lt;/profile_background_image_url>
  &lt;profile_background_tile>false&lt;/profile_background_tile>
  &lt;statuses_count>122&lt;/statuses_count>
  &lt;following>false&lt;/following>
  &lt;notifications>false&lt;/notifications>
&lt;/user>
&lt;/status></samp></pre>
<ol>
<li>Připomeňme si, že data vracená <code>httplib2</code> jsou vždy <a href=#strings-byte-arrays>bajty</a> a ne řetězce. Abychom je mohli převést na řetězec, musíme je dekódovat s použitím příslušného znakového kódování. Aplikační rozhraní systému Identi.ca vždy vrací výsledky v <abbr>UTF-8</abbr>. Takže tato část je snadná.
<li>Zde je text stavové zprávy, kterou jsme právě zveřejnili.
<li>Toto je unikátní identifikátor nové stavové zprávy. Identi.ca jej používá pro konstrukci <abbr>URL</abbr>, které se dá použít pro zobrazení zprávy na webu.
</ol>

<p>A tady ji máme:

<p class=c><img class="fr" src="i/identica-screenshot.png" alt="snímek obrazovky, který ukazuje zveřejněnou stavovou zprávu na Identi.ca" width="740" height="449" />

<p class=a>&#x2042;

<h2 id=http-web-services-beyond-post>Za hranicemi HTTP POST</h2>

<p><abbr>HTTP</abbr> se neomezuje jen na <code>GET</code> a <code>POST</code>. Nepochybně jde o nejběžnější typy dotazů, obzvlášť ze strany webových prohlížečů. Ale rozhraní webových služeb může jít za hranice <code>GET</code> a <code>POST</code> &mdash; a knihovna <code>httplib2</code> je na to připravená.

<pre class=screen>
# pokračování z předchozího příkladu
<samp class=p>>>> </samp><kbd class=pp>from xml.etree import ElementTree as etree</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>tree = etree.fromstring(content)</kbd>                                          <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>status_id = tree.findtext('id')</kbd>                                           <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>status_id</kbd>
<samp class=pp>'5131472'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>url = 'https://identi.ca/api/statuses/destroy/{0}.xml'.format(status_id)</kbd>  <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>resp, deleted_content = h.request(url, 'DELETE')</kbd>                          <span class=u>&#x2463;</span></a></pre>
<ol>
<li>Sever vrátil <abbr>XML</abbr>, že ano? A my už víme, <a href=#xml-xml-parse>jak <abbr>XML</abbr> zpracovat</a>.
<li>Metoda <code>findtext()</code> najde první objekt odpovídající zadanému výrazu a extrahuje jeho textový obsah. V tomto případě hledáme element <code>&lt;id&gt;</code>.
<li>Z textového obsahu elementu <code>&lt;id&gt;</code> můžeme zkonstruovat <abbr>URL</abbr> pro vymazání stavové zprávy, kterou jsme zrovna zveřejnili.
<li>Zprávu vymažeme tím, že pro zmíněné <abbr>URL</abbr> vytvoříme požadavek <abbr>HTTP</abbr> <code>DELETE</code>.
</ol>

<p>Po drátech běhá následující:

<pre class=screen>
<samp><a>send: b'DELETE /api/statuses/destroy/5131472.xml HTTP/1.1      <span class=u>&#x2460;</span></a>
Host: identi.ca
Accept-Encoding: identity
user-agent: Python-httplib2/$Rev: 259 $

'
<a>reply: 'HTTP/1.1 401 Unauthorized'                             <span class=u>&#x2461;</span></a>
<a>send: b'DELETE /api/statuses/destroy/5131472.xml HTTP/1.1      <span class=u>&#x2462;</span></a>
Host: identi.ca
Accept-Encoding: identity
<a>authorization: Basic SECRET_HASH_CONSTRUCTED_BY_HTTPLIB2       <span class=u>&#x2463;</span></a>
user-agent: Python-httplib2/$Rev: 259 $

'
<a>reply: 'HTTP/1.1 200 OK'                                       <span class=u>&#x2464;</span></a></samp>
<samp class=p>>>> </samp><kbd class=pp>resp.status</kbd>
<samp class=pp>200</samp></pre>
<ol>
<li>„Odstraň tuto stavovou zprávu.“
<li>„Je mi líto, Dave [dejve]. Obávám se, že to nemohu udělat.“
<li>„Neautorizováno <span class="u" title="kombinace vykřičníku s otazníkem!">&#8253;</span> Hmmm. Odstraň tu stavovou zprávu, <em>prosím</em>&hellip;
<li>&hellip;a tady je mé jméno a heslo.“
<li>„Považuj to za hotovou věc!“
</ol>

<p>Puf a je to pryč.

<p class=c><img class="fr" src="i/identica-deleted.png" alt="snímek obrazovky, který ukazuje odstraněnou zprávu na Identi.ca" width="740" height="449" />

<p class=a>&#x2042;

<h2 id=http-web-services-furtherreading>Přečtěte si</h2>

<p><code>httplib2</code>:

<ul>
<li><a href="http://code.google.com/p/httplib2/">Stránka projektu <code>httplib2</code></a> (anglicky)
<li><a href="http://code.google.com/p/httplib2/wiki/ExamplesPython3">Další příklady kódu využívajícího <code>httplib2</code></a> (anglicky)
<li><a href="http://www.xml.com/pub/a/2006/02/01/doing-http-caching-right-introducing-httplib2.html">Doing <abbr>HTTP</abbr> Caching Right: Introducing <code>httplib2</code></a> (anglický článek)
<li><a href="http://www.xml.com/pub/a/2006/03/29/httplib2-http-persistence-and-authentication.html"><code>httplib2</code>: <abbr>HTTP</abbr> Persistence and Authentication</a> (anglický článek)
</ul>

<p>Práce <abbr>HTTP</abbr> s mezipamětí:

<ul>
<li><a href="http://www.mnot.net/cache_docs/"><abbr>HTTP</abbr> Tutorial</a> &mdash; napsal Mark Nottingham
<li><a href="http://code.google.com/p/doctype/wiki/ArticleHttpCaching">How to control caching with <abbr>HTTP</abbr> headers</a> (anglický článek o Google Doctype)
</ul>

<p><abbr>RFC</abbr>:

<ul>
<li><a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616: <abbr>HTTP</abbr></a>
<li><a href="http://www.ietf.org/rfc/rfc2617.txt">RFC 2617: <abbr>HTTP</abbr> Basic Authentication</a>
<li><a href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951: deflate compression</a>
<li><a href="http://www.ietf.org/rfc/rfc1952.txt">RFC 1952: gzip compression</a>
</ul>

</div>
<div id=chapter-case-study-porting-chardet-to-python-3>
<h1>Případová studie: Přepis <code>chardet</code> pro Python 3</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Words, words. They&#8217;re all we have to go on. <span class=u>&#x275E;</span><br>(Slova, slova. Jsou vším, čeho se musíme držet.)<br>&mdash; <a href="http://www.imdb.com/title/tt0100519/quotes">Rosencrantz a Guildenstern jsou mrtvi</a>
</blockquote>
<p>&nbsp;
<h2 id=case-study-porting-chardet-to-python-3-divingin>Ponořme se</h2>
<p class=f>Otázka: Co je příčnou č. 1 vedoucí ke zmatenému textu na webu, ve vaší poštovní schránce a ve všech dokumentech, které kdy byly napsány, napříč všemi počítačovými systémy? Je to kódování znaků. V kapitole <a href=#chapter-strings>Řetězce</a> jsme se bavili o historii kódování znaků a o vytvoření Unicode &mdash; „jedno kódování vládne všem“. Moc bych si přál, kdybych se na webových stránkách nikdy víc nesetkával se zmatenými znaky, protože by všechny systémy pro vytváření textu ukládaly přesnou informaci o kódování a protože by byly všechny přenosové protokoly připravené na používání Unicode a každý systém pro zpracování textu by při konverzi mezi kódováními zachovával perfektní věrnost.
<p>Rád bych taky poníka.
<p>Unicode poníka.
<p>Kdyby to tak byl Uniponík.
<p>Budu si muset osedlat autodetekci znakového kódování.

<p class=a>&#x2042;

<h2 id=case-study-porting-chardet-to-python-3-faq.what>Co se rozumí autodetekcí znakového kódování?</h2>
<p>Rozumí se tím to, že vezmeme posloupnost bajtů v neznámém znakovém kódování a pokoušíme se kódování zjistit, abychom si text mohli přečíst. Podobá se to lámání kódu v situaci, kdy nemáme dešifrovací klíč.

<h3 id=case-study-porting-chardet-to-python-3-faq.impossible>Není to náhodou nemožné?</h3>
<p>Z obecného pohledu to opravdu je nemožné. Ale některá kódování jsou optimalizována pro určité jazyky a jazyky nejsou náhodné. Některé posloupnosti znaků se objevují neustále, zatímco jiné posloupnosti nedávají žádný smysl. Když osoba plynně ovládající angličtinu otevře noviny a najde „txzqJv 2!dasd0a QqdKjvz“, okamžitě pozná, že nejde o angličtinu (i když se text skládá pouze z písmen, která se v angličtině používají). Na základě studia velkého množství „typického“ textu může počítačový algoritmus simulovat zmíněný druh plynné znalosti a může provést kvalifikovaný odhad týkající se jazyka textu.
<p>Jinými slovy, detekce kódování je ve skutečnosti detekcí jazyka, která se kombinuje se znalostí tendence jazyka používat určité znakové kódování.

<h3 id=case-study-porting-chardet-to-python-3-faq.who>Existuje vůbec takový algoritmus?</h3>
<p>Jak se ukazuje, tak ano. Všechny nejpoužívanější prohlížeče mají autodetekci kódování zabudovanou, protože web je plný stránek, které neobsahují vůbec žádnou informaci o kódování. <a href="http://lxr.mozilla.org/seamonkey/source/extensions/universalchardet/src/base/">Mozilla Firefox obsahuje knihovnu pro autodetekci kódování</a>, která je open source. <a href="http://pypi.python.org/pypi/chardet/" title="Původní odkaz http://chardet.feedparser.org/ je nefunkční. Opraveno 23. 3. 2012." >Knihovnu jsem přenesl do Pythonu 2</a> a modul jsem nazval <code>chardet</code>. V této kapitole vás krok za krokem provedu procesem přepisování modulu <code>chardet</code> z Pythonu 2 pro Python 3.

<p class=a>&#x2042;

<h2 id=case-study-porting-chardet-to-python-3-divingin2>Úvod do modulu <code>chardet</code></h2>
<p>Než se do přepisu kódu pustíme, bylo by dobré, kdybyste rozuměli, jak funguje! Toto je stručná příručka pro usnadnění orientace ve vlastním kódu. Knihovna <code>chardet</code> je příliš velká na to, abych její kód vložil do textu této knihy. Ale můžete si ji <a href="http://chardet.feedparser.org/download/">stáhnout z <code>chardet.feedparser.org</code></a>.
<aside>Detekce kódování je ve skutečnosti v závěsu za detekcí jazyka.</aside>
<p>Hlavním vstupním bodem detekčního algoritmu je <code>universaldetector.py</code>. Obsahuje jednu třídu, <code>UniversalDetector</code>. (Možná jste mysleli, že hlavním vstupním bodem je funkce <code>detect</code> z <code>chardet/__init__.py</code>. To je ale jen funkce pro zvýšení pohodlí, která vytvoří objekt třídy <code>UniversalDetector</code>, zavolá jej a vrátí jeho výsledek.)
<p><code>UniversalDetector</code> zvládá pět kategorií kódování:
<ol>
<li><abbr>UTF-n</abbr> s Byte Order Mark (<abbr>BOM</abbr>; znak pro určení pořadí bajtů). Zahrnuje <abbr>UTF-8</abbr>, obě varianty <abbr>UTF-16</abbr> (Big-Endian a Little-Endian) a všechny 4 varianty pořadí bajtů <abbr>UTF-32</abbr>.
<li>Kódování s únikovými znaky (escape encodings), která jsou zcela kompatibilní se 7bitovým <abbr>ASCII</abbr>. Znaky spadající mimo <abbr>ASCII</abbr> začínají únikovými sekvencemi (escape sequence). Příklady: <abbr>ISO-2022-JP</abbr> (japonština) a <abbr>HZ-GB-2312</abbr> (čínština).
<li>Vícebajtová kódování, ve kterých je každý znak reprezentován proměnným počtem bajtů. Příklady: <abbr>Big5</abbr> (čínština), <abbr>SHIFT_JIS</abbr> (japonština), <abbr>EUC-KR</abbr> (korejština) a <abbr>UTF-8</abbr> bez <abbr>BOM</abbr>.
<li>Jednobajtová kódování, ve kterých je každý znak reprezentován jedním bajtem. Příklady: <abbr>KOI8-R</abbr> (ruština), <abbr>windows-1255</abbr> (hebrejština) a <abbr>TIS-620</abbr> (thajština).
<li><abbr>windows-1252</abbr>, která používají (zejména v Microsoft Windows) střední manažeři, kteří nerozpoznají znakové kódování od díry v zemi.
</ol>
<h3 id=case-study-porting-chardet-to-python-3-how.bom><abbr>UTF-n</abbr> s <abbr>BOM</abbr></h3>
<p>Pokud text začíná značkou <abbr>BOM</abbr>, můžeme rozumně předpokládat, že je zakódován v <abbr>UTF-8</abbr>, <abbr>UTF-16</abbr> nebo <abbr>UTF-32</abbr>. (Značka <abbr>BOM</abbr> nám přesně řekne, o které kódování jde. Byla pro tento účel navržena.) To se děje přímo v <code>UniversalDetector</code>u, který vrátí výsledek okamžitě, bez dalšího zpracovávání textu.
<h3 id=case-study-porting-chardet-to-python-3-how.esc>Kódování escape sekvencemi</h3>
<p>Pokud text obsahuje rozpoznatelné posloupnosti s únikovými znaky (escape sequence), může to být příznakem použití kódování, kterému se v angličtině říká escaped encoding. <code>UniversalDetector</code> vytvoří <code>EscCharSetProber</code> (je definován v <code>escprober.py</code>) a přivede do něj text.
<p><code>EscCharSetProber</code> vytvoří sadu konečných automatů, které vycházejí z modelů pro <abbr>HZ-GB-2312</abbr>, <abbr>ISO-2022-CN</abbr>, <abbr>ISO-2022-JP</abbr> a <abbr>ISO-2022-KR</abbr> (jsou definovány v <code>escsm.py</code>). <code>EscCharSetProber</code> přivádí text do každého z těchto konečných automatů &mdash; bajt po bajtu. Pokud některý z konečných automatů skončí s jednoznačnou identifikací kódování, vrátí <code>EscCharSetProber</code> okamžitě pozitivní výsledek objektu třídy <code>UniversalDetector</code>, který jej vrátí volajícímu. Pokud kterýkoliv z konečných automatů narazí na nepřípustnou posloupnost, je vyřazen a další zpracování pokračuje jen s ostatními konečnými automaty.
<h3 id=case-study-porting-chardet-to-python-3-how.mb>Vícebajtová kódování</h3>
<p>Za předpokladu, že není použita značka <abbr>BOM</abbr>, <code>UniversalDetector</code> zkontroluje, zda text obsahuje nějaké znaky s nastaveným osmým bitem. Pokud tomu tak je, vytvoří sérii „detekčních zařízení“ (prober) pro rozpoznání vícebajtových kódování, jednobajtových kódování a nakonec, jako poslední možnost, pro <code>windows-1252</code>.
<p>Detekční objekt pro vícebajtová kódování, <code>MBCSGroupProber</code> (třída je definována v <code>mbcsgroupprober.py</code>), je ve skutečnosti jen obálkou. Ovládá ostatní detekční objekty, po jednom pro každé vícebajtové kódování: <abbr>Big5</abbr>, <abbr>GB2312</abbr>, <abbr>EUC-TW</abbr>, <abbr>EUC-KR</abbr>, <abbr>EUC-JP</abbr>, <abbr>SHIFT_JIS</abbr> a <abbr>UTF-8</abbr>. <code>MBCSGroupProber</code> směřuje text do každého z těchto specializovaných detekčních objektů a kontroluje výsledky. Pokud nějaký detekční objekt hlásí, že nalezl nepřípustnou posloupnost bajtů, je vyřazen z dalšího zpracování (takže například libovolné následné volání metody <code>UniversalDetector</code>.<code>feed()</code> vyřazený detekční objekt přeskočí). Pokud detekční objekt hlásí, že si je poměrně jistý rozpoznáním kódování, oznámí <code>MBCSGroupProber</code> tento pozitivní výsledek objektu <code>UniversalDetector</code>, který oznámí výsledek volajícímu.
<p>Většina z detekčních objektů pro vícebajtová kódování je odvozena z <code>MultiByteCharSetProber</code> (definována v <code>mbcharsetprober.py</code>) a jednoduše se navěsí na příslušný konečný automat a analyzátor rozložení. Zbytek práce nechá na <code>MultiByteCharSetProber</code>. <code>MultiByteCharSetProber</code> prohání text přes konečné automaty specializované na jednotlivá kódování &mdash; bajt po bajtu. Vyhledává posloupnosti bajtů, které by indikovaly průkazné pozitivní nebo negativní výsledky. <code>MultiByteCharSetProber</code> současně posílá text do analyzátoru rozložení, který je specifický pro každé kódování.
<p>Analyzátory rozložení (jsou definovány v <code>chardistribution.py</code>) používají jazykově specifické modely nejčastěji se vyskytujících znaků. Jakmile <code>MultiByteCharSetProber</code> předá analyzátorům rozložení dostatečný objem textu, vypočítá ohodnocení spolehlivosti, které je založeno na počtu často používaných znaků, na celkovém počtu znaků a na jazykově závislém rozložení. Pokud je spolehlivost dostatečně velká, vrátí <code>MultiByteCharSetProber</code> výsledek do <code>MBCSGroupProber</code>, který jej vrátí do <code>UniversalDetector</code>u, který jej vrátí volajícímu.
<p>Případ japonštiny je obtížnější. Analýza rozložení podle jednotlivých znaků nevede vždy k rozlišení <code>EUC-JP</code> a <code>SHIFT_JIS</code>, takže <code>SJISProber</code> (definován v <code>sjisprober.py</code>) používá také dvojznakovou analýzu rozložení. <code>SJISContextAnalysis</code> a <code>EUCJPContextAnalysis</code> (definice se v obou případech nacházejí v <code>jpcntx.py</code> a obě třídy dědí ze společné třídy <code>JapaneseContextAnalysis</code>) v textu kontrolují frekvenci výskytů slabičných znaků hiragana. Jakmile bylo zpracováno dostatečné množství textu, vracejí úroveň spolehlivosti do <code>SJISProber</code>, který zkontroluje oba analyzátory a vrátí výsledek s vyšší úrovní spolehlivosti do <code>MBCSGroupProber</code>.
<h3 id=case-study-porting-chardet-to-python-3-how.sb>Jednobajtová kódování</h3>
<aside>Vážně, kde je můj Unicode poník?</aside>
<p>Detekční objekt pro jednobajtové kódování, <code>SBCSGroupProber</code> (třída je definována v <code>sbcsgroupprober.py</code>) je rovněž obálkou, která ovládá skupinu jiných detekčních objektů &mdash; jeden pro každou kombinaci jednobajtového kódování a jazyka: <code>windows-1251</code>, <code>KOI8-R</code>, <code>ISO-8859-5</code>, <code>MacCyrillic</code>, <code>IBM855</code> a <code>IBM866</code> (ruština); <code>ISO-8859-7</code> a <code>windows-1253</code> (řečtina); <code>ISO-8859-5</code> a <code>windows-1251</code> (bulharština); <code>ISO-8859-2</code> a <code>windows-1250</code> (čeština, maďarština, slovenština a další); <code>TIS-620</code> (thajština); <code>windows-1255</code> a <code>ISO-8859-8</code> (hebrejština).
<p><code>SBCSGroupProber</code> předává text do každého z těchto detekčních objektů a kontroluje výsledky. Všechny tyto detekční objekty jsou implementovány v jedné třídě, <code>SingleByteCharSetProber</code> (definována v <code>sbcharsetprober.py</code>), která prostřednictvím argumentu přebírá jazykový model. Jazykový model definuje, jak často se v typickém textu vyskytují dvojznakové posloupnosti. <code>SingleByteCharSetProber</code> zpracovává text a zjišťuje nejčastěji se vyskytující dvojznakové posloupnosti. Jakmile byl zpracován dostatečný objem textu, vypočítá úroveň spolehlivosti, která je založena na počtu často se vyskytujících posloupností, na celkovém počtu znaků a na jazykově závislém rozložení.
<p>Hebrejština se řeší jako zvláštní případ. Pokud se text na základě analýzy rozložení dvojznakových posloupností jeví jako hebrejština, snaží se <code>HebrewProber</code> (třída definována v <code>hebrewprober.py</code>) rozlišit mezi vizuální hebrejštinou (kdy je text uložen ve skutečnosti „pozpátku“ řádek po řádku a poté je zobrazen „normálně“, takže může být čten zprava doleva) a logickou hebrejštinou (kdy je zdrojový text uložen v pořadí čtení a klientský program ho vykresluje zprava doleva). Protože se některé znaky kódují jinak podle toho, zda se nacházejí uprostřed slova nebo na jeho konci, můžeme rozumně odhadnout směr zdrojového textu a vrátit příslušné kódování (<code>windows-1255</code> pro logickou hebrejštinu nebo <code>ISO-8859-8</code> pro vizuální hebrejštinu).
<h3 id=case-study-porting-chardet-to-python-3-how.windows1252><code>windows-1252</code></h3>
<p>Pokud <code>UniversalDetector</code> v textu detekuje znaky s nastaveným osmým bitem a žádný z vícebajtových nebo jednobajtových detekčních objektů nevrátil spolehlivý výsledek, vytvoří <code>Latin1Prober</code> (třída je definována v <code>latin1prober.py</code>) a snaží se detekovat anglický text v kódování <code>windows-1252</code>. Tato detekce je ze své podstaty nespolehlivá, protože anglické znaky se kódují stejným způsobem v mnoha různých kódováních. Jediný způsob, jak lze kódování <code>windows-1252</code> rozpoznat, je založen na běžně používaných symbolech, jako jsou střídavé uvozovky (smart quotes; knižní, jiný znak na začátku a jiný na konci), kulaté apostrofy, symbol copyright a podobně. <code>Latin1Prober</code> automaticky redukuje ohodnocení své spolehlivosti, aby umožnil přesnějším detektorům vyhrát, pokud je to vůbec možné.
<p class=a>&#x2042;

<h2 id=case-study-porting-chardet-to-python-3-running2to3>Spouštíme <code>2to3</code></h2>
<p>Jsme připraveni k přenesení modulu <code>chardet</code> z Pythonu 2 do Pythonu 3. Python 3 se dodává s pomocným skriptem nazvaným <code>2to3</code>, který jako vstup přebírá zdrojový kód napsaný pro Python 2 a automaticky převádí vše, co dovede, do podoby pro Python 3. V některých případech je to snadné&nbsp;&mdash;&nbsp;funkce se přejmenovala nebo se přesunula do jiného modulu&nbsp;&mdash;, ale v ostatních případech to může být docela složité. Abyste získali představu, co vše <em>umí</em> převést, podívejte se na přílohu <a href=#chapter-porting-code-to-python-3-with-2to3>Přepis kódu do Python 3 s využitím <code>2to3</code></a>. V této kapitole začneme spuštěním <code>2to3</code> pro balík <code>chardet</code>. Ale jak brzy uvidíte, po provedení kouzel automatickými nástroji nám zbude ještě spousta práce.
<p>Hlavní balík <code>chardet</code> je rozdělen do několika různých souborů. Všechny se nacházejí ve stejném adresáři. Skript <code>2to3</code> převod více souborů najednou usnadňuje. Jako argument na příkazovém řádku stačí předat jméno adresáře a <code>2to3</code> převede každý ze souborů, které se v něm nacházejí.
<pre class=screen><samp class=p>C:\home\chardet> </samp><kbd>python c:\Python30\Tools\Scripts\2to3.py -w chardet\</kbd>
<samp>RefactoringTool: Skipping implicit fixer: buffer
RefactoringTool: Skipping implicit fixer: idioms
RefactoringTool: Skipping implicit fixer: set_literal
RefactoringTool: Skipping implicit fixer: ws_comma
--- chardet\__init__.py (original)
+++ chardet\__init__.py (refactored)
@@ -18,7 +18,7 @@
 __version__ = "1.0.1"

 def detect(aBuf):
<del>-    import universaldetector</del>
<ins>+    from . import universaldetector</ins>
     u = universaldetector.UniversalDetector()
     u.reset()
     u.feed(aBuf)
--- chardet\big5prober.py (original)
+++ chardet\big5prober.py (refactored)
@@ -25,10 +25,10 @@
 # 02110-1301  USA
 ######################### END LICENSE BLOCK #########################

<del>-from mbcharsetprober import MultiByteCharSetProber</del>
<del>-from codingstatemachine import CodingStateMachine</del>
<del>-from chardistribution import Big5DistributionAnalysis</del>
<del>-from mbcssm import Big5SMModel</del>
<ins>+from .mbcharsetprober import MultiByteCharSetProber</ins>
<ins>+from .codingstatemachine import CodingStateMachine</ins>
<ins>+from .chardistribution import Big5DistributionAnalysis</ins>
<ins>+from .mbcssm import Big5SMModel</ins>

 class Big5Prober(MultiByteCharSetProber):
     def __init__(self):
--- chardet\chardistribution.py (original)
+++ chardet\chardistribution.py (refactored)
@@ -25,12 +25,12 @@
 # 02110-1301  USA
 ######################### END LICENSE BLOCK #########################

<del>-import constants</del>
<del>-from euctwfreq import EUCTWCharToFreqOrder, EUCTW_TABLE_SIZE, EUCTW_TYPICAL_DISTRIBUTION_RATIO</del>
<del>-from euckrfreq import EUCKRCharToFreqOrder, EUCKR_TABLE_SIZE, EUCKR_TYPICAL_DISTRIBUTION_RATIO</del>
<del>-from gb2312freq import GB2312CharToFreqOrder, GB2312_TABLE_SIZE, GB2312_TYPICAL_DISTRIBUTION_RATIO</del>
<del>-from big5freq import Big5CharToFreqOrder, BIG5_TABLE_SIZE, BIG5_TYPICAL_DISTRIBUTION_RATIO</del>
<del>-from jisfreq import JISCharToFreqOrder, JIS_TABLE_SIZE, JIS_TYPICAL_DISTRIBUTION_RATIO</del>
<ins>+from . import constants</ins>
<ins>+from .euctwfreq import EUCTWCharToFreqOrder, EUCTW_TABLE_SIZE, EUCTW_TYPICAL_DISTRIBUTION_RATIO</ins>
<ins>+from .euckrfreq import EUCKRCharToFreqOrder, EUCKR_TABLE_SIZE, EUCKR_TYPICAL_DISTRIBUTION_RATIO</ins>
<ins>+from .gb2312freq import GB2312CharToFreqOrder, GB2312_TABLE_SIZE, GB2312_TYPICAL_DISTRIBUTION_RATIO</ins>
<ins>+from .big5freq import Big5CharToFreqOrder, BIG5_TABLE_SIZE, BIG5_TYPICAL_DISTRIBUTION_RATIO</ins>
<ins>+from .jisfreq import JISCharToFreqOrder, JIS_TABLE_SIZE, JIS_TYPICAL_DISTRIBUTION_RATIO</ins>

 ENOUGH_DATA_THRESHOLD = 1024
 SURE_YES = 0.99
.
.
<mark>. (takto to chvíli pokračuje)</mark>
.
.
RefactoringTool: Files that were modified:
RefactoringTool: chardet\__init__.py
RefactoringTool: chardet\big5prober.py
RefactoringTool: chardet\chardistribution.py
RefactoringTool: chardet\charsetgroupprober.py
RefactoringTool: chardet\codingstatemachine.py
RefactoringTool: chardet\constants.py
RefactoringTool: chardet\escprober.py
RefactoringTool: chardet\escsm.py
RefactoringTool: chardet\eucjpprober.py
RefactoringTool: chardet\euckrprober.py
RefactoringTool: chardet\euctwprober.py
RefactoringTool: chardet\gb2312prober.py
RefactoringTool: chardet\hebrewprober.py
RefactoringTool: chardet\jpcntx.py
RefactoringTool: chardet\langbulgarianmodel.py
RefactoringTool: chardet\langcyrillicmodel.py
RefactoringTool: chardet\langgreekmodel.py
RefactoringTool: chardet\langhebrewmodel.py
RefactoringTool: chardet\langhungarianmodel.py
RefactoringTool: chardet\langthaimodel.py
RefactoringTool: chardet\latin1prober.py
RefactoringTool: chardet\mbcharsetprober.py
RefactoringTool: chardet\mbcsgroupprober.py
RefactoringTool: chardet\mbcssm.py
RefactoringTool: chardet\sbcharsetprober.py
RefactoringTool: chardet\sbcsgroupprober.py
RefactoringTool: chardet\sjisprober.py
RefactoringTool: chardet\universaldetector.py
RefactoringTool: chardet\utf8prober.py</samp></pre>
<p>Teď spustíme skript <code>2to3</code> na testovací skript <code>test.py</code>.
<pre class='nd screen'><samp class=p>C:\home\chardet> </samp><kbd>python c:\Python30\Tools\Scripts\2to3.py -w test.py</kbd>
<samp>RefactoringTool: Skipping implicit fixer: buffer
RefactoringTool: Skipping implicit fixer: idioms
RefactoringTool: Skipping implicit fixer: set_literal
RefactoringTool: Skipping implicit fixer: ws_comma
--- test.py (original)
+++ test.py (refactored)
@@ -4,7 +4,7 @@
 count = 0
 u = UniversalDetector()
 for f in glob.glob(sys.argv[1]):
<del>-    print f.ljust(60),</del>
<ins>+    print(f.ljust(60), end=' ')</ins>
     u.reset()
     for line in file(f, 'rb'):
         u.feed(line)
@@ -12,8 +12,8 @@
     u.close()
     result = u.result
     if result['encoding']:
<del>-        print result['encoding'], 'with confidence', result['confidence']</del>
<ins>+        print(result['encoding'], 'with confidence', result['confidence'])</ins>
     else:
<del>-        print '******** no result'</del>
<ins>+        print('******** no result')</ins>
     count += 1
<del>-print count, 'tests'</del>
<ins>+print(count, 'tests')</ins>
RefactoringTool: Files that were modified:
RefactoringTool: test.py</samp></pre>
<p>No vida. Nebylo to tak hrozné. Konvertovalo se jen pár importů a příkazů print. Když už o tom mluvíme, <em>jaký byl</em> problém se všemi těmi příkazy import? Abychom na to mohli odpovědět, musíme rozumět tomu, jak se modul <code>chardet</code> dělí na více souborů.

<p class=a>&#x2042;

<h2 id=case-study-porting-chardet-to-python-3-multifile-modules>Krátká odbočka k vícesouborovým modulům</h2>

<p><code>chardet</code> je <i>vícesouborový modul</i>. Mohl jsem se rozhodnout, že veškerý kód uložím do jednoho souboru (pojmenovaného <code>chardet.py</code>), ale neudělal jsem to. Místo toho jsem vytvořil adresář (pojmenovaný <code>chardet</code>) a v něm jsem vytvořil soubor <code>__init__.py</code>. <em>Pokud Python najde v adresáři soubor <code>__init__.py</code>, předpokládá, že všechny ostatní soubory ve stejném adresáři jsou součástí stejného modulu.</em> Jméno adresáře je jménem modulu. Soubory v adresáři se mohou odkazovat na ostatní soubory ve stejném adresáři nebo dokonce v jeho podadresářích. (Více si o tom řekneme za minutku.) Ale celá kolekce souborů se okolnímu pythonovskému kódu jeví jako jediný modul&nbsp;&mdash;&nbsp;jako kdyby všechny funkce a třídy byly definovány v jediném souboru s příponou <code>.py</code>.

<p>A co je vlastně v souboru<code>__init__.py</code>? Nic. Všechno. Něco mezi tím. Soubor <code>__init__.py</code> nemusí definovat vůbec nic. Může to být doslova prázdný soubor. Nebo jej můžeme použít k definici funkcí, které jsou našimi hlavními vstupními body. Nebo do něj můžeme umístit všechny naše funkce. Podstatná je jediná věc.

<blockquote class=note>
<p><span class="u">&#x261E;</span>Adresář se souborem <code>__init__.py</code> se vždy považuje za vícesouborový modul. Pokud v adresáři není umístěn soubor <code>__init__.py</code>, považuje se prostě za adresář, který nemá k souborům s příponou <code>.py</code> žádný vztah.
</blockquote>

<p>Podívejme se, jak to funguje v praxi.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import chardet</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>dir(chardet)</kbd>             <span class=u>&#x2460;</span></a>
<samp class=pp>['__builtins__', '__doc__', '__file__', '__name__',
 '__package__', '__path__', '__version__', 'detect']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>chardet</kbd>                  <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;module 'chardet' from 'C:\Python31\lib\site-packages\chardet\__init__.py'></samp></pre>
<ol>
<li>Pokud neuvažujeme obvyklé atributy tříd, najdeme v modulu <code>chardet</code> jedinou věc a tou je funkce <code>detect()</code>.
<li>Tady máme první stopu, která říká, že modul <code>chardet</code> je víc než jen obyčejným souborem: u slova „module“ se ve výpisu objevuje soubor <code>__init__.py</code> umístěný v adresáři <code>chardet/</code>.
</ol>

<p>Nahlédněme do souboru <code>__init__.py</code>.

<pre class=pp><code><a>def detect(aBuf):                              <span class=u>&#x2460;</span></a>
<a>    from . import universaldetector            <span class=u>&#x2461;</span></a>
    u = universaldetector.UniversalDetector()
    u.reset()
    u.feed(aBuf)
    u.close()
    return u.result</code></pre>
<ol>
<li>V souboru <code>__init__.py</code> je definována funkce <code>detect()</code>, která je hlavním bodem knihovny <code>chardet</code>.
<li>Ale funkce <code>detect()</code> neobsahuje skoro žádný kód! Ve skutečnosti pouze importuje modul <code>universaldetector</code> a začíná jej používat. Ale kde je definován <code>universaldetector</code>?
</ol>

<p>Odpověď je skryta v tomto divně vypadajícím příkazu <code>import</code>:

<pre class='nd pp'><code>from . import universaldetector</code></pre>

<p>V překladu do češtiny to znamená „importuj modul <code>universaldetector</code>, který je umístěn ve stejném adresáři, jako já“. Tím „já“ se myslí soubor <code>chardet/__init__.py</code>. Říká se tomu <i>relativní import</i>. Představuje způsob, jakým se mohou soubory ve vícesouborovém modulu na sebe vzájemně odkazovat, aniž by se musely starat o konflikty jmen s jinými moduly, které můžeme mít nainstalované v naší <a href=#your-first-python-program-importsearchpath>vyhledávací cestě pro import</a>. Uvedený příkaz <code>import</code> bude modul <code>universaldetector</code> hledat <em>pouze</em> uvnitř adresáře <code>chardet/</code>.

<p>Zmíněné dva koncepty&nbsp;&mdash;&nbsp;<code>__init__.py</code> a relativní importy&nbsp;&mdash;&nbsp;znamenají, že náš modul můžeme rozbít na tolik kousků, kolik si přejeme. Modul <code>chardet</code> se skládá z 36 souborů s příponou <code>.py</code>&nbsp;&mdash;&nbsp;z 36! A přitom vše, co musíme udělat, když jej chceme začít používat, je <code>import chardet</code>. Pak můžeme zavolat hlavní funkci <code>chardet.detect()</code>. Aniž o tom náš kód ví, funkce <code>detect()</code> je ve skutečnosti definována v souboru <code>chardet/__init__.py</code>. A aniž o tom musíme vědět my, funkce <code>detect()</code> používá k odkazu na třídu definovanou uvnitř <code>chardet/universaldetector.py</code> mechanismus relativního importu, který zase používá relativní import pěti dalších souborů, které se rovněž nacházejí v adresáři <code>chardet/</code>.

<blockquote class=note>
<p><span class="u">&#x261E;</span>Kdykoliv se přistihnete, že v Pythonu píšete rozsáhlou knihovnu (nebo, což je pravděpodobnější, když zjistíte, že se vaše malá knihovna rozrostla ve velkou), udělejte si čas na refaktorizaci a změňte ji na vícesouborový modul. Je to jedna z mnoha věcí, ve kterých je Python dobrý. Takže té výhody využijte.
</blockquote>

<p class=a>&#x2042;

<h2 id=case-study-porting-chardet-to-python-3-manual>Opravme, co <code>2to3</code> neumí</h2>
<h3 id=case-study-porting-chardet-to-python-3-falseisinvalidsyntax><code>False</code> je syntaktická chyba</h3>
<aside>Píšete testy, že?</aside>
<p>Teď zkusíme skutečný test. Spustíme testovací sadu (test suite) na zkušební skript (test harness). Protože je testovací sada navržena tak, aby pokryla všechny možné cesty, kudy se běh programu může kódem ubírat, jde o dobrý způsob, jak ověřit, že v našem přeneseném kódu někde nejsou skryté chyby.
<pre class='nd screen'><samp class=p>C:\home\chardet> </samp><kbd>python test.py tests\*\*</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "test.py", line 1, in &lt;module>
    from chardet.universaldetector import UniversalDetector
  File "C:\home\chardet\chardet\universaldetector.py", line 51
    self.done = constants.False
                              ^
SyntaxError: invalid syntax</samp></pre>
<p>Hmm, to je jen drobnost. V Pythonu 3 je <code>False</code> vyhrazeným slovem, takže je nemůžeme použít jako jméno proměnné. Podíváme se do <code>constants.py</code> na to, kde je proměnná definována. Tady máme původní verzi z <code>constants.py</code> předtím, než ji skript <code>2to3</code> změnil:
<pre class='nd pp'><code>import __builtin__
if not hasattr(__builtin__, 'False'):
    False = 0
    True = 1
else:
    False = __builtin__.False
    True = __builtin__.True</code></pre>
<p>Tento kus kódu byl navržen, aby knihovna běžela ve starších verzích Pythonu 2. Před Pythonem 2.3 neexistoval zabudovaný typ <code>bool</code>. Uvedený kód detekuje nepřítomnost zabudovaných konstant <code>True</code> a <code>False</code> a v případě potřeby je definuje.
<p>Ale v Pythonu 3 je typ <code>bool</code> přítomen vždy, takže je celý úryvek kódu zbytečný. Nejjednodušší řešení spočívá v nahrazení všech výskytů <code>constants.True</code> a <code>constants.False</code> hodnotami <code>True</code> a <code>False</code>. Pak z <code>constants.py</code> odstraníme onen mrtvý kód.
<p>Takže následující řádek v <code>universaldetector.py</code>
<pre class='nd pp'><code>self.done = constants.False</code></pre>
<p>se změní na
<pre class='nd pp'><code>self.done = False</code></pre>
<p>Ách, nebylo to uspokojující? Kód je teď kratší a čitelnější.
<h3 id=case-study-porting-chardet-to-python-3-nomodulenamedconstants>Nenalezen modul <code>constants</code></h3>
<p>Nastal čas spustit znovu <code>test.py</code>. Uvidíme, jak daleko se dostaneme.
<pre class='nd screen'><samp class=p>C:\home\chardet> </samp><kbd>python test.py tests\*\*</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "test.py", line 1, in &lt;module>
    from chardet.universaldetector import UniversalDetector
  File "C:\home\chardet\chardet\universaldetector.py", line 29, in &lt;module>
    import constants, sys
ImportError: No module named constants</samp></pre>
<p>Co to říká? Jaképak „No module named <code>constants</code>“ (doslova „žádný modul jménem <code>constants</code>“)? Modul <code>constants</code> tam samozřejmě je! Je přímo tady v <code>chardet/constants.py</code>.

<p>Vzpomínáte si, jak skript <code>2to3</code> opravil všechny ty příkazy import? Tato knihovna používá množství relativních importů&nbsp;&mdash;&nbsp;<a href=#case-study-porting-chardet-to-python-3-multifile-modules>moduly, které importují jiné moduly nacházející se uvnitř stejné knihovny</a>&nbsp;&mdash;, ale <em>v Pythonu 3 se změnila logika relativních importů</em>. V Pythonu 2 jsme mohli jednoduše provést <code>import constants</code> a Python by nejdříve prohledával adresář <code>chardet/</code>. V Pythonu 3 jsou <a href="http://www.python.org/dev/peps/pep-0328/">všechny příkazy import absolutní</a>. Pokud chceme v Pythonu 3 provést relativní import, musíme to říct explicitně:
<pre class='nd pp'><code>from . import constants</code></pre>
<p>No moment. Neměl se o tohle postarat skript <code>2to3</code> za nás? No, on to udělal. Ale tento konkrétní příkaz import kombinoval dva typy importu na jednom řádku: relativní import modulu <code>constants</code>, který se nachází uvnitř knihovny, a absolutní import modulu <code>sys</code>, který je předinstalován jako součást pythonovské standardní knihovny. V Pythonu 2 jsme je mohli zkombinovat do jednoho řádku příkazu import. V Pythonu 3 to nejde a skript <code>2to3</code> není dost chytrý na to, aby příkaz import rozdělil na dva.
<p>Řešení spočívá v ručním rozdělení příkazu import. Takže tento import „dva v jednom“&hellip;
<pre class='nd pp'><code>import constants, sys</code></pre>
<p>&hellip; musíme změnit na dva oddělené importy:
<pre class='nd pp'><code>from . import constants
import sys</code></pre>
<p>Variace tohoto problému jsou rozesety po celé knihovně <code>chardet</code>. Na některých místech je to „<code>import constants, sys</code>“, jinde je to „<code>import constants, re</code>“. Oprava je stejná. Ručně rozdělíme příkaz import na dva řádky. Na jednom uvedeme relativní import, na druhém absolutní import.
<p>Kupředu!
<h3 id=case-study-porting-chardet-to-python-3-namefileisnotdefined>Jméno <var>'file'</var> není definováno</h3>
<aside>open() je novým file(). <a href="http://en.wikipedia.org/wiki/Variations_of_orange#Papaya_whip">PapayaWhip</a> je nová černá.</aside>
<p>A zase jdeme na to. Spouštíme <code>test.py</code>, abychom provedli naše testovací případy&hellip;
<pre class='nd screen'><samp class=p>C:\home\chardet> </samp><kbd>python test.py tests\*\*</kbd>
<samp>tests\ascii\howto.diveintomark.org.xml</samp>
<samp class=traceback>Traceback (most recent call last):
  File "test.py", line 9, in &lt;module>
    for line in file(f, 'rb'):
NameError: name 'file' is not defined</samp></pre>
<p>Tak tohle mě překvapilo, protože tento obrat jsem používal, co mi paměť sahá. V Pythonu 2 byla globální funkce <code>file()</code> jiným jménem (alias) pro funkci <code>open()</code>, která představovala standardní způsob <a href=#files-reading>otvírání textových souborů pro čtení</a>. V Pythonu 3 už globální funkce <code>file()</code> neexistuje, ale funkce <code>open()</code> je tu nadále.
<p>Takže nejjednodušší řešení problému chybějící funkce <code>file()</code> spočívá v jejím nahrazení voláním funkce <code>open()</code>:
<pre class='nd pp'><code>for line in open(f, 'rb'):</code></pre>
<p>A to je vše, co o tom můžu říct.
<h3 id=case-study-porting-chardet-to-python-3-cantuseastringpattern>Řetězcový vzorek nelze použít pro bajtové objekty</h3>
<p>Teď se začnou dít zajímavé věci. Slůvkem „zajímavé“ rozumím „pekelně matoucí“.
<pre class='nd screen'><samp class=p>C:\home\chardet> </samp><kbd>python test.py tests\*\*</kbd>
<samp>tests\ascii\howto.diveintomark.org.xml</samp>
<samp class=traceback>Traceback (most recent call last):
  File "test.py", line 10, in &lt;module>
    u.feed(line)
  File "C:\home\chardet\chardet\universaldetector.py", line 98, in feed
    if self._highBitDetector.search(aBuf):
TypeError: can't use a string pattern on a bytes-like object</samp></pre>
<p>Abychom to odladili, podívejme se, co je <var>self._highBitDetector</var>. Je to definováno v metodě <var>__init__</var> třídy <var>UniversalDetector</var>:
<pre class='nd pp'><code>class UniversalDetector:
    def __init__(self):
        self._highBitDetector = re.compile(r'[\x80-\xFF]')</code></pre>
<p>Jde o předkompilovaný regulární výraz, který má hledat znaky mimo <abbr>ASCII</abbr>, tj. v rozsahu 128&ndash;255 (0x80&ndash;0xFF). Počkat, tohle není úplně správně. Musíme použít přesnější terminologii. Tento vzorek je navržen pro hledání <em>bajtů</em> s hodnotou mimo <abbr>ASCII</abbr>, tedy v rozsahu 128&ndash;255.
<p>A v tom je ten problém.
<p>V Pythonu 2 byl řetězec polem bajtů. Jeho kódování znaků bylo zachyceno odděleně. Pokud jsme po Pythonu 2 chtěli, aby znakové kódování udržoval u řetězce, museli jsme použít Unicode řetězec (<code>u''</code>). Ale v Pythonu 3 je řetězec vždy tím, co Python 2 nazýval Unicode řetězec&nbsp;&mdash;&nbsp;to znamená polem Unicode znaků (které mohou být vyjádřeny různým počtem bajtů). A protože je tento regulární výraz definován řetězcovým vzorkem, může být použit jen pro prohledávání řetězců, což je pole znaků. Ale my nechceme prohledávat řetězec. Prohledáváme pole bajtů. Pohledem na trasovací výpis zjistíme, že k chybě došlo v <code>universaldetector.py</code>:
<pre class='nd pp'><code>def feed(self, aBuf):
    .
    .
    .
    if self._mInputState == ePureAscii:
        if self._highBitDetector.search(aBuf):</code></pre>
<p>A co je to <var>aBuf</var>? Podívejme se ještě o kousek zpět, na místo, kde se volá <code>UniversalDetector.feed()</code>. Jedno z míst, kde se volá, se nachází v testovacím kódu (test harness) <code>test.py</code>.
<pre class='nd pp'><code>u = UniversalDetector()
.
.
.
for line in open(f, 'rb'):
    u.feed(line)</code></pre>
<aside>Není to pole znaků, ale pole bajtů.</aside>
<p>A tady máme odpověď: <var>aBuf</var> je řádek načítaný v metodě <code>UniversalDetector.feed()</code> ze souboru na disku. Podívejte se pořádně na parametry, které se používají při otvírání souboru: <code>'rb'</code>. <code>'r'</code> znamená „read“ (čtení). No dobrá, to je toho. Čteme ze souboru. No jo! <a href=#files-binary><code>'b'</code> znamená „binárně“.</a> Bez příznaku <code>'b'</code> by cyklus <code>for</code> četl soubor po řádcích a každý řádek by převáděl na řetězec&nbsp;&mdash;&nbsp;tedy na pole Unicode znaků&nbsp;&mdash;&nbsp;s využitím systémového výchozího znakového kódování. Ale s příznakem <code>'b'</code> čte cyklus <code>for</code> ze souboru po řádcích a každý řádek ukládá do pole bajtů přesně v takovém tvaru, v jakém se nachází v souboru. Výsledné pole bajtů se předává do <code>UniversalDetector.feed()</code> a nakonec se dostane až k předkompilovanému regulárnímu výrazu <var>self._highBitDetector</var>, aby se našly osmibitové&hellip; znaky. Ale my nemáme znaky. My máme bajty. A do prčic.
<p>Potřebujeme, aby tento regulární výraz nehledal v poli znaků, ale v poli bajtů.
<p>Když už jsme na to přišli, bude náprava jednoduchá. Regulární výrazy definované řetězci mohou hledat v řetězcích. Regulární výrazy definované poli bajtů mohou hledat v polích bajtů. Abychom definovali vzorek polem bajtů, jednoduše změníme typ argumentu, který používáme pro definici regulárního výrazu, na pole bajtů. (Hned na následujícím řádku je další případ téhož problému.)
<pre class='nd pp'><code>  class UniversalDetector:
      def __init__(self):
<del>-         self._highBitDetector = re.compile(r'[\x80-\xFF]')</del>
<del>-         self._escDetector = re.compile(r'(\033|~{)')</del>
<ins>+         self._highBitDetector = re.compile(b'[\x80-\xFF]')</ins>
<ins>+         self._escDetector = re.compile(b'(\033|~{)')</ins>
          self._mEscCharSetProber = None
          self._mCharSetProbers = []
          self.reset()</code></pre>
<p>Když necháme ve všech zdrojových textech vyhledat použití modulu <code>re</code>, objevíme další dva případy v <code>charsetprober.py</code>. Jde opět o případy, kdy jsou regulární výrazy definovány jako řetězce, ale používáme je pro <var>aBuf</var>, což je pole bajtů. Řešení je stejné: definujeme vzorky regulárních výrazů jako pole bajtů.
<pre class='nd pp'><code>  class CharSetProber:
      .
      .
      .
      def filter_high_bit_only(self, aBuf):
<del>-         aBuf = re.sub(r'([\x00-\x7F])+', ' ', aBuf)</del>
<ins>+         aBuf = re.sub(b'([\x00-\x7F])+', b' ', aBuf)</ins>
          return aBuf

      def filter_without_english_letters(self, aBuf):
<del>-         aBuf = re.sub(r'([A-Za-z])+', ' ', aBuf)</del>
<ins>+         aBuf = re.sub(b'([A-Za-z])+', b' ', aBuf)</ins>
          return aBuf</code></pre>

<h3 id=case-study-porting-chardet-to-python-3-cantconvertbytesobject>Objekt typu <code>'bytes'</code> nelze implicitně převést na <code>str</code></h3>
<p>Divoucnější a divoucnější&hellip;
<pre class='nd screen'><samp class=p>C:\home\chardet> </samp><kbd>python test.py tests\*\*</kbd>
<samp>tests\ascii\howto.diveintomark.org.xml</samp>
<samp class=traceback>Traceback (most recent call last):
  File "test.py", line 10, in &lt;module>
    u.feed(line)
  File "C:\home\chardet\chardet\universaldetector.py", line 100, in feed
    elif (self._mInputState == ePureAscii) and self._escDetector.search(self._mLastChar + aBuf):
TypeError: Can't convert 'bytes' object to str implicitly</samp></pre>
<p>Zde dochází k nešťastné kolizi mezi stylem zápisu zdrojového textu a interpretem Pythonu. Chyba <code>TypeError</code> se může vázat na kteroukoliv část řádku, ale trasovací výpis nám neříká, kde přesně je. Může to být v první nebo v druhé části podmínky, ale z trasovacího výpisu se to nepozná. Abychom prostor pro hledání zúžili, měli bychom řádek rozdělit:
<pre class='nd pp'><code>elif (self._mInputState == ePureAscii) and \
    self._escDetector.search(self._mLastChar + aBuf):</code></pre>
<p>A znovu spustíme test:
<pre class='nd screen'><samp class=p>C:\home\chardet> </samp><kbd>python test.py tests\*\*</kbd>
<samp>tests\ascii\howto.diveintomark.org.xml</samp>
<samp class=traceback>Traceback (most recent call last):
  File "test.py", line 10, in &lt;module>
    u.feed(line)
  File "C:\home\chardet\chardet\universaldetector.py", line 101, in feed
    self._escDetector.search(self._mLastChar + aBuf):
TypeError: Can't convert 'bytes' object to str implicitly</samp></pre>
<p>Aha! Problém se nevyskytoval v první části podmínky (<code>self._mInputState == ePureAscii</code>), ale v druhé. Takže co zde vlastně způsobuje chybu <code>TypeError</code>? Možná si myslíte, že metoda <code>search()</code> očekává hodnotu odlišného typu. To by ale nevygenerovalo takový trasovací výpis. Pythonovské funkce mohou přebírat libovolné hodnoty. Pokud předáme správný počet argumentů, funkce se provede. Pokud bychom předali hodnotu jiného typu, než funkce očekává, mohla by <em>havarovat</em>. Ale pokud by se tak stalo, trasovací výpis by ukazoval na místo někde uvnitř funkce. Jenže tento trasovací výpis říká, že se nikdy nedošlo tak daleko, aby se metoda <code>search()</code> zavolala. Takže problém musí být skryt v operaci <code>+</code>, protože ta se snaží o zkonstruování hodnoty, která bude nakonec předána metodě <code>search()</code>.
<p><a href=#case-study-porting-chardet-to-python-3-cantuseastringpattern>Z předchozího ladění</a> víme, že <var>aBuf</var> je polem bajtů. A co je tedy <code>self._mLastChar</code>? Jde o členskou proměnnou definovanou v metodě <code>reset()</code>, která je ve skutečnosti volána z metody <code>__init__()</code>.
<pre class='nd pp'><code>class UniversalDetector:
    def __init__(self):
        self._highBitDetector = re.compile(b'[\x80-\xFF]')
        self._escDetector = re.compile(b'(\033|~{)')
        self._mEscCharSetProber = None
        self._mCharSetProbers = []
<mark>        self.reset()</mark>

    def reset(self):
        self.result = {'encoding': None, 'confidence': 0.0}
        self.done = False
        self._mStart = True
        self._mGotData = False
        self._mInputState = ePureAscii
<mark>        self._mLastChar = ''</mark></code></pre>
<p>A tady máme odpověď. Vidíte to? <var>self._mLastChar</var> je řetězec, ale <var>aBuf</var> je pole bajtů. Konkatenaci (zřetězení, spojení) nelze provádět pro řetězec a pole bajtů&nbsp;&mdash;&nbsp;ani když jde o řetězec nulové délky.
<p>No dobrá, ale k čemu je tedy <var>self._mLastChar</var>? V metodě <code>feed()</code>, jen pár řádků pod místem označeným v trasovacím výpisu, vidíme&hellip;
<pre class='nd pp'><code>if self._mInputState == ePureAscii:
    if self._highBitDetector.search(aBuf):
        self._mInputState = eHighbyte
    elif (self._mInputState == ePureAscii) and \
            self._escDetector.search(self._mLastChar + aBuf):
        self._mInputState = eEscAscii

<mark>self._mLastChar = aBuf[-1]</mark></code></pre>
<p>Volající funkce volá metodu <code>feed()</code> pořád dokola s tím, že jí pokaždé předá pár bajtů. Metoda zpracuje zadané bajty (dostává je v <var>aBuf</var>) a potom uloží poslední bajt do <var>self._mLastChar</var> pro případ, že by jej potřebovala při dalším volání. (Při použití vícebajtového kódování by metoda <code>feed()</code> mohla být zavolána pro polovinu znaku a pak by mohla být volána pro jeho druhou polovinu.) Ale protože je teď <var>aBuf</var> místo řetězce polem bajtů, musíme udělat pole bajtů i z <var>self._mLastChar</var>. Takže:
<pre class='nd pp'><code>  def reset(self):
      .
      .
      .
<del>-     self._mLastChar = ''</del>
<ins>+     self._mLastChar = b''</ins></code></pre>
<p>Když ve všech zdrojových souborech vyhledáme „<code>mLastChar</code>“, najdeme podobný problém v <code>mbcharsetprober.py</code>. Ale místo uchovávání posledního znaku se uchovávají poslední <em>dva</em> znaky. Třída <code>MultiByteCharSetProber</code> používá k uchovávání posledních dvou znaků seznam jednoznakových řetězců. V Pythonu 3 musíme použít seznam celých čísel, protože ve skutečnosti neuchováváme znaky, ale bajty. (Bajty jsou prostě celá čísla v intervalu <code>0‒255</code>.)
<pre class='nd pp'><code>  class MultiByteCharSetProber(CharSetProber):
      def __init__(self):
          CharSetProber.__init__(self)
          self._mDistributionAnalyzer = None
          self._mCodingSM = None
<del>-         self._mLastChar = ['\x00', '\x00']</del>
<ins>+         self._mLastChar = [0, 0]</ins>

      def reset(self):
          CharSetProber.reset(self)
          if self._mCodingSM:
              self._mCodingSM.reset()
          if self._mDistributionAnalyzer:
              self._mDistributionAnalyzer.reset()
<del>-         self._mLastChar = ['\x00', '\x00']</del>
<ins>+         self._mLastChar = [0, 0]</ins></code></pre>
<h3 id=case-study-porting-chardet-to-python-3-unsupportedoperandtypeforplus>Nepodporované typy operandů pro +: <code>'int'</code> a <code>'bytes'</code></h3>
<p>Mám jednu dobrou a jednu špatnou zprávu. Ta dobrá je, že děláme pokroky&hellip;
<pre class='nd screen'><samp class=p>C:\home\chardet> </samp><kbd>python test.py tests\*\*</kbd>
<samp>tests\ascii\howto.diveintomark.org.xml</samp>
<samp class=traceback>Traceback (most recent call last):
  File "test.py", line 10, in &lt;module>
    u.feed(line)
  File "C:\home\chardet\chardet\universaldetector.py", line 101, in feed
    self._escDetector.search(self._mLastChar + aBuf):
TypeError: unsupported operand type(s) for +: 'int' and 'bytes'</samp></pre>
<p>&hellip; Ta špatná je, že to někdy tak nevypadá.
<p>Ale on to je pokrok! Opravdu! I když trasovací výpis označuje stejný řádek kódu, je to jiná chyba, než se hlásila dříve. Pokrok! Takže kdepak máme problém teď? Když jsme to kontrolovali minule, nesnažil se tento řádek řetězit <code>int</code> s polem bajtů (<code>bytes</code>). Ve skutečnosti jsme strávili dost času tím, abychom <a href=#case-study-porting-chardet-to-python-3-cantconvertbytesobject>zajistili, že <var>self._mLastChar</var> bude pole bajtů</a>. Jak se mohlo změnit na <code>int</code>?
<p>Odpověď není skrytá v předchozích řádcích kódu, ale v následujících.
<pre class='nd pp'><code>if self._mInputState == ePureAscii:
    if self._highBitDetector.search(aBuf):
        self._mInputState = eHighbyte
    elif (self._mInputState == ePureAscii) and \
            self._escDetector.search(self._mLastChar + aBuf):
        self._mInputState = eEscAscii

<mark>self._mLastChar = aBuf[-1]</mark></code></pre>
<aside>Každý prvek řetězce je řetězcem. Každý prvek z pole bajtů je celé číslo.</aside>
<p>Tato chyba se nevyskytne při prvním volání metody <code>feed()</code>. Vyskytne se <em>při druhém volání</em> poté, co byl proměnné <var>self._mLastChar</var> přiřazen poslední bajt <var>aBuf</var>. No a v čem je tedy problém? Když z bajtového pole získáme jeden prvek, dostaneme celé číslo a ne bajtové pole. Abychom ten rozdíl viděli, ukážeme si to v interaktivním shellu:
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>aBuf = b'\xEF\xBB\xBF'</kbd>         <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>len(aBuf)</kbd>
<samp class=pp>3</samp>
<samp class=p>>>> </samp><kbd class=pp>mLastChar = aBuf[-1]</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>mLastChar</kbd>                      <span class=u>&#x2461;</span></a>
<samp class=pp>191</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(mLastChar)</kbd>                <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;class 'int'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>mLastChar + aBuf</kbd>               <span class=u>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: unsupported operand type(s) for +: 'int' and 'bytes'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>mLastChar = aBuf[-1:]</kbd>          <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>mLastChar</kbd>
<samp class=pp>b'\xbf'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>mLastChar + aBuf</kbd>               <span class=u>&#x2465;</span></a>
<samp class=pp>b'\xbf\xef\xbb\xbf'</samp></pre>
<ol>
<li>Definujeme pole bajtů o délce 3.
<li>Poslední prvek pole bajtů má hodnotu 191.
<li>Je to celé číslo (integer).
<li>Zřetězení pole bajtů s celým číslem nefunguje. Právě jsme navodili chybu, kterou jsme pozorovali v <code>universaldetector.py</code>.
<li>A tady máme nápravu. Místo získávání posledního prvku z pole bajtů použijeme <a href=#native-datatypes-slicinglists>operaci pro získání výřezu</a> (slicing). Vytvoříme jí nové pole bajtů, které obsahuje jen poslední prvek. To znamená, že začneme posledním prvkem a pokračujeme v tvorbě výřezu (slice), dokud nedosáhneme konce pole bajtů. Teď je <var>mLastChar</var> polem bajtů o délce 1.
<li>Zřetězením pole bajtů o délce 1 s polem bajtů o délce 3 dostaneme nové pole bajtů o délce 4.
</ol>
<p>Takže abychom zajistili, že bude metoda <code>feed()</code> v <code>universaldetector.py</code> pokračovat v činnosti nezávisle na tom, jak často je volána, musíme <a href=#case-study-porting-chardet-to-python-3-cantconvertbytesobject>inicializovat <var>self._mLastChar</var> polem bajtů o nulové délce</a> a potom <em>musíme zajistit, aby tato proměnná zůstala polem bajtů</em>.
<pre class='nd pp'><code>              self._escDetector.search(self._mLastChar + aBuf):
          self._mInputState = eEscAscii

<del>- self._mLastChar = aBuf[-1]</del>
<ins>+ self._mLastChar = aBuf[-1:]</ins></code></pre>
<h3 id=case-study-porting-chardet-to-python-3-ordexpectedstring>funkce <code>ord()</code> očekávala řetězec o délce 1, ale byl nalezen <code>int</code></h3>
<p>Jste už unaveni? Už to máme skoro hotové&hellip;
<pre class='nd screen'><samp class=p>C:\home\chardet> </samp><kbd>python test.py tests\*\*</kbd>
<samp>tests\ascii\howto.diveintomark.org.xml                       ascii with confidence 1.0
tests\Big5\0804.blogspot.com.xml</samp>
<samp class=traceback>Traceback (most recent call last):
  File "test.py", line 10, in &lt;module>
    u.feed(line)
  File "C:\home\chardet\chardet\universaldetector.py", line 116, in feed
    if prober.feed(aBuf) == constants.eFoundIt:
  File "C:\home\chardet\chardet\charsetgroupprober.py", line 60, in feed
    st = prober.feed(aBuf)
  File "C:\home\chardet\chardet\utf8prober.py", line 53, in feed
    codingState = self._mCodingSM.next_state(c)
  File "C:\home\chardet\chardet\codingstatemachine.py", line 43, in next_state
    byteCls = self._mModel['classTable'][ord(c)]
TypeError: ord() expected string of length 1, but int found</samp></pre>
<p>OK, takže <var>c</var> je typu <code>int</code>, ale funkce <code>ord()</code> očekávala jednoznakový řetězec. No dobrá. Kde je definována proměnná <var>c</var>?
<pre class='nd pp'><code># codingstatemachine.py
def next_state(self, c):
    # for each byte we get its class
    # if it is first byte, we also get byte length
    byteCls = self._mModel['classTable'][ord(c)]</code></pre>
<p>To nám nepomůže. Tady se jen předává funkci. Podívejme se hlouběji do zásobníku.
<pre class='nd pp'><code># utf8prober.py
def feed(self, aBuf):
    for c in aBuf:
        codingState = self._mCodingSM.next_state(c)</code></pre>
<p>Vidíte to? V Pythonu 2 byla proměnná <var>aBuf</var> řetězcem, takže proměnná <var>c</var> byla jednoznakovým řetězcem. (Ten dostáváme, když iterujeme přes řetězec&nbsp;&mdash;&nbsp;všechny znaky, jeden po druhém.) Ale teď je <var>aBuf</var> polem bajtů, takže <var>c</var> je typu <code>int</code> a ne jednoznakový řetězec. Jinými slovy, už nepotřebujeme volat funkci <code>ord()</code>, protože <var>c</var> už je typu <code>int</code>!
<p>Takže:
<pre class='nd pp'><code>  def next_state(self, c):
      # for each byte we get its class
      # if it is first byte, we also get byte length
<del>-     byteCls = self._mModel['classTable'][ord(c)]</del>
<ins>+     byteCls = self._mModel['classTable'][c]</ins></code></pre>
<p>Vyhledáním „<code>ord(c)</code>“ ve všech zdrojových textech odhalíme podobné problémy v <code>sbcharsetprober.py</code>&hellip;
<pre class='nd pp'><code># sbcharsetprober.py
def feed(self, aBuf):
    if not self._mModel['keepEnglishLetter']:
        aBuf = self.filter_without_english_letters(aBuf)
    aLen = len(aBuf)
    if not aLen:
        return self.get_state()
    for c in aBuf:
<mark>        order = self._mModel['charToOrderMap'][ord(c)]</mark></code></pre>
<p>&hellip; a v <code>latin1prober.py</code>&hellip;
<pre class='nd pp'><code># latin1prober.py
def feed(self, aBuf):
    aBuf = self.filter_with_english_letters(aBuf)
    for c in aBuf:
<mark>        charClass = Latin1_CharToClass[ord(c)]</mark></code></pre>
<p>Proměnná <var>c</var> iteruje přes <var>aBuf</var>, což znamená, že v ní bude celé číslo a ne jednoznakový řetězec. Řešení je stejné: <code>ord(c)</code> změníme na prosté <code>c</code>.
<pre class='nd pp'><code>  # sbcharsetprober.py
  def feed(self, aBuf):
      if not self._mModel['keepEnglishLetter']:
          aBuf = self.filter_without_english_letters(aBuf)
      aLen = len(aBuf)
      if not aLen:
          return self.get_state()
      for c in aBuf:
<del>-         order = self._mModel['charToOrderMap'][ord(c)]</del>
<ins>+         order = self._mModel['charToOrderMap'][c]</ins>

  # latin1prober.py
  def feed(self, aBuf):
      aBuf = self.filter_with_english_letters(aBuf)
      for c in aBuf:
<del>-         charClass = Latin1_CharToClass[ord(c)]</del>
<ins>+         charClass = Latin1_CharToClass[c]</ins>
</code></pre>
<h3 id=case-study-porting-chardet-to-python-3-unorderabletypes>Neuspořádatelné datové typy: <code>int()</code> >= <code>str()</code></h3>
<p>A spusťme to znovu.
<pre class='nd screen'><samp class=p>C:\home\chardet> </samp><kbd>python test.py tests\*\*</kbd>
<samp>tests\ascii\howto.diveintomark.org.xml                       ascii with confidence 1.0
tests\Big5\0804.blogspot.com.xml</samp>
<samp class=traceback>Traceback (most recent call last):
  File "test.py", line 10, in &lt;module>
    u.feed(line)
  File "C:\home\chardet\chardet\universaldetector.py", line 116, in feed
    if prober.feed(aBuf) == constants.eFoundIt:
  File "C:\home\chardet\chardet\charsetgroupprober.py", line 60, in feed
    st = prober.feed(aBuf)
  File "C:\home\chardet\chardet\sjisprober.py", line 68, in feed
    self._mContextAnalyzer.feed(self._mLastChar[2 - charLen :], charLen)
  File "C:\home\chardet\chardet\jpcntx.py", line 145, in feed
    order, charLen = self.get_order(aBuf[i:i+2])
  File "C:\home\chardet\chardet\jpcntx.py", line 176, in get_order
    if ((aStr[0] >= '\x81') and (aStr[0] &lt;= '\x9F')) or \
TypeError: unorderable types: int() >= str()</samp></pre>
<p>A co se děje zase tady? „Unorderable types“ čili neuspořádatelné typy? (Neuspořádatelné ve smyslu, že mezi těmito hodnotami nelze určit pořadí.) A rozdíl mezi bajty a řetězci znovu vystrkuje svou ošklivou hlavu. Ale podívejte se na kód:
<pre class='nd pp'><code>class SJISContextAnalysis(JapaneseContextAnalysis):
    def get_order(self, aStr):
        if not aStr: return -1, 1
        # find out current char's byte length
<mark>        if ((aStr[0] >= '\x81') and (aStr[0] &lt;= '\x9F')) or \</mark>
           ((aStr[0] >= '\xE0') and (aStr[0] &lt;= '\xFC')):
            charLen = 2
        else:
            charLen = 1</code></pre>
<p>A odkud se vzala proměnná <var>aStr</var>? Podívejme se hlouběji do zásobníku:
<pre class='nd pp'><code>def feed(self, aBuf, aLen):
    .
    .
    .
    i = self._mNeedToSkipCharNum
    while i &lt; aLen:
<mark>        order, charLen = self.get_order(aBuf[i:i+2])</mark></code></pre>
<p>Hele, podívejme. To je náš starý přítel <var>aBuf</var>. Jak už jste mohli odhadnout ze všech předchozích problémů, se kterými jsme se v této kapitole setkali, <var>aBuf</var> je pole bajtů. V tomto místě je metoda <code>feed()</code> nepředává jako celek. Vytváří z něj výřez. Ale jak jsme viděli <a href=#case-study-porting-chardet-to-python-3-unsupportedoperandtypeforplus>v této kapitole o něco dříve</a>, výřezem z pole bajtů vznikne pole bajtů. Takže parametr <var>aStr</var>, který přebírá metoda <code>get_order()</code>, je pořád pole bajtů. 
<p>A co se tento kód s <var>aStr</var> pokouší dělat? Získává první prvek z pole bajtů a srovnává jej s jednoznakovým řetězcem. V Pythonu 2 to fungovalo, protože <var>aStr</var> a <var>aBuf</var> byly řetězce a <var>aStr[0]</var> by byl taky řetězec. U řetězců můžeme zjišťovat, zda jsou různé. Ale v Pythonu 3 jsou proměnné <var>aStr</var> a <var>aBuf</var> poli bajtů a <var>aStr[0]</var> je celé číslo. Číslo a řetězec nemůžeme porovnávat na neshodu, aniž jednu z hodnot explicitně nepřevedeme na stejný typ. 
<p>V tomto případě nemusíme kód komplikovat přidáváním explicitního převodu typu. <var>aStr[0]</var> je celé číslo. Vše, s čím ho srovnáváme, jsou konstanty. Můžeme je změnit z jednoznakových řetězců na čísla. A když už to děláme, změňme také identifikátor <var>aStr</var> na <var>aBuf</var>, protože to ve skutečnosti není řetězec (string). 
<pre class='nd pp'><code>  class SJISContextAnalysis(JapaneseContextAnalysis):
<del>-     def get_order(self, aStr):</del>
<del>-      if not aStr: return -1, 1</del>
<ins>+     def get_order(self, aBuf):</ins>
<ins>+      if not aBuf: return -1, 1</ins>
          # find out current char's byte length
<del>-         if ((aStr[0] >= '\x81') and (aStr[0] &lt;= '\x9F')) or \</del>
<del>-            ((aBuf[0] >= '\xE0') and (aBuf[0] &lt;= '\xFC')):</del>
<ins>+         if ((aBuf[0] >= 0x81) and (aBuf[0] &lt;= 0x9F)) or \</ins>
<ins>+            ((aBuf[0] >= 0xE0) and (aBuf[0] &lt;= 0xFC)):</ins>
              charLen = 2
          else:
              charLen = 1

          # return its order if it is hiragana
<del>-      if len(aStr) > 1:</del>
<del>-             if (aStr[0] == '\202') and \</del>
<del>-                (aStr[1] >= '\x9F') and \</del>
<del>-                (aStr[1] &lt;= '\xF1'):</del>
<del>-                return ord(aStr[1]) - 0x9F, charLen</del>
<ins>+      if len(aBuf) > 1:</ins>
<ins>+             if (aBuf[0] == 202) and \</ins>
<ins>+                (aBuf[1] >= 0x9F) and \</ins>
<ins>+                (aBuf[1] &lt;= 0xF1):</ins>
<ins>+                return aBuf[1] - 0x9F, charLen</ins>

          return -1, charLen

  class EUCJPContextAnalysis(JapaneseContextAnalysis):
<del>-     def get_order(self, aStr):</del>
<del>-      if not aStr: return -1, 1</del>
<ins>+     def get_order(self, aBuf):</ins>
<ins>+      if not aBuf: return -1, 1</ins>
          # find out current char's byte length
<del>-         if (aStr[0] == '\x8E') or \</del>
<del>-           ((aStr[0] >= '\xA1') and (aStr[0] &lt;= '\xFE')):</del>
<ins>+         if (aBuf[0] == 0x8E) or \</ins>
<ins>+           ((aBuf[0] >= 0xA1) and (aBuf[0] &lt;= 0xFE)):</ins>
              charLen = 2
<del>-         elif aStr[0] == '\x8F':</del>
<ins>+         elif aBuf[0] == 0x8F:</ins>
              charLen = 3
          else:
              charLen = 1

        # return its order if it is hiragana
<del>-    if len(aStr) > 1:</del>
<del>-           if (aStr[0] == '\xA4') and \</del>
<del>-              (aStr[1] >= '\xA1') and \</del>
<del>-              (aStr[1] &lt;= '\xF3'):</del>
<del>-                 return ord(aStr[1]) - 0xA1, charLen</del>
<ins>+    if len(aBuf) > 1:</ins>
<ins>+           if (aBuf[0] == 0xA4) and \</ins>
<ins>+              (aBuf[1] >= 0xA1) and \</ins>
<ins>+              (aBuf[1] &lt;= 0xF3):</ins>
<ins>+               return aBuf[1] - 0xA1, charLen</ins>

        return -1, charLen</code></pre>
<p>Hledáním výskytu funkce <code>ord()</code> ve zdrojových textech odkryjeme stejný problém v <code>chardistribution.py</code> (konkrétně ve třídách <code>EUCTWDistributionAnalysis</code>, <code>EUCKRDistributionAnalysis</code>, <code>GB2312DistributionAnalysis</code>, <code>Big5DistributionAnalysis</code>, <code>SJISDistributionAnalysis</code> a <code>EUCJPDistributionAnalysis</code>). Ve všech případech se oprava podobá změnám, které jsme provedli v třídách <code>EUCJPContextAnalysis</code> a <code>SJISContextAnalysis</code> v souboru <code>jpcntx.py</code>. 

<h3 id=case-study-porting-chardet-to-python-3-reduceisnotdefined>Globální jméno <code>'reduce'</code> není definováno</h3> 
<p>Ještě jedna trhlina&hellip; 
<pre class='nd screen'><samp class=p>C:\home\chardet> </samp><kbd>python test.py tests\*\*</kbd>
<samp>tests\ascii\howto.diveintomark.org.xml                       ascii with confidence 1.0
tests\Big5\0804.blogspot.com.xml</samp>
<samp class=traceback>Traceback (most recent call last):
  File "test.py", line 12, in &lt;module>
    u.close()
  File "C:\home\chardet\chardet\universaldetector.py", line 141, in close
    proberConfidence = prober.get_confidence()
  File "C:\home\chardet\chardet\latin1prober.py", line 126, in get_confidence
    total = reduce(operator.add, self._mFreqCounter)
NameError: global name 'reduce' is not defined</samp></pre>
<p>Podle oficiálního průvodce <a href="http://docs.python.org/3.0/whatsnew/3.0.html#builtins">What’s New In Python 3.0</a> byla funkce <code>reduce()</code> vyňata z globálního prostoru jmen a přesunuta do modulu <code>functools</code>. Citujme z průvodce: „Pokud opravdu potřebujete <code>functools.reduce()</code>, použijte ji. Ale v 99 procentech případů je explicitní cyklus <code>for</code> čitelnější.“ O tomto rozhodnutí se dočtete více na weblogu Guida van Rossuma: <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196">The fate of reduce() in Python 3000</a> (Osud reduce v Pythonu 3000).
<pre class='nd pp'><code>def get_confidence(self):
    if self.get_state() == constants.eNotMe:
        return 0.01
  
<mark>    total = reduce(operator.add, self._mFreqCounter)</mark></code></pre>
<p>Funkce <code>reduce()</code> přebírá dva argumenty&nbsp;&mdash;&nbsp;funkci a seznam (přesněji řečeno, může to být libovolný iterovatelný objekt)&nbsp;&mdash;&nbsp;a kumulativně aplikuje zadanou funkci na každý z prvků seznamu. Jinými slovy, jde o efektní a nepřímý způsob realizace součtu všech prvků seznamu. 
<p>Tato obludnost byla tak běžná, že byla do Pythonu přidána globální funkce <code>sum()</code>. 
<pre class='nd pp'><code>  def get_confidence(self):
      if self.get_state() == constants.eNotMe:
          return 0.01
  
<del>-     total = reduce(operator.add, self._mFreqCounter)</del>
<ins>+     total = sum(self._mFreqCounter)</ins></code></pre>
<p>Protože jsme přestali používat modul <code>operator</code>, můžeme také ze začátku souboru odstranit příslušný příkaz <code>import</code>. 
<pre class='nd pp'><code>  from .charsetprober import CharSetProber
  from . import constants
<del>- import operator</del></code></pre>
<p>A tož, možeme to otestovať? 
<pre class='nd screen'><samp class=p>C:\home\chardet> </samp><kbd>python test.py tests\*\*</kbd>
<samp>tests\ascii\howto.diveintomark.org.xml                       ascii with confidence 1.0
tests\Big5\0804.blogspot.com.xml                             Big5 with confidence 0.99
tests\Big5\blog.worren.net.xml                               Big5 with confidence 0.99
tests\Big5\carbonxiv.blogspot.com.xml                        Big5 with confidence 0.99
tests\Big5\catshadow.blogspot.com.xml                        Big5 with confidence 0.99
tests\Big5\coolloud.org.tw.xml                               Big5 with confidence 0.99
tests\Big5\digitalwall.com.xml                               Big5 with confidence 0.99
tests\Big5\ebao.us.xml                                       Big5 with confidence 0.99
tests\Big5\fudesign.blogspot.com.xml                         Big5 with confidence 0.99
tests\Big5\kafkatseng.blogspot.com.xml                       Big5 with confidence 0.99
tests\Big5\ke207.blogspot.com.xml                            Big5 with confidence 0.99
tests\Big5\leavesth.blogspot.com.xml                         Big5 with confidence 0.99
tests\Big5\letterlego.blogspot.com.xml                       Big5 with confidence 0.99
tests\Big5\linyijen.blogspot.com.xml                         Big5 with confidence 0.99
tests\Big5\marilynwu.blogspot.com.xml                        Big5 with confidence 0.99
tests\Big5\myblog.pchome.com.tw.xml                          Big5 with confidence 0.99
tests\Big5\oui-design.com.xml                                Big5 with confidence 0.99
tests\Big5\sanwenji.blogspot.com.xml                         Big5 with confidence 0.99
tests\Big5\sinica.edu.tw.xml                                 Big5 with confidence 0.99
tests\Big5\sylvia1976.blogspot.com.xml                       Big5 with confidence 0.99
tests\Big5\tlkkuo.blogspot.com.xml                           Big5 with confidence 0.99
tests\Big5\tw.blog.xubg.com.xml                              Big5 with confidence 0.99
tests\Big5\unoriginalblog.com.xml                            Big5 with confidence 0.99
tests\Big5\upsaid.com.xml                                    Big5 with confidence 0.99
tests\Big5\willythecop.blogspot.com.xml                      Big5 with confidence 0.99
tests\Big5\ytc.blogspot.com.xml                              Big5 with confidence 0.99
tests\EUC-JP\aivy.co.jp.xml                                  EUC-JP with confidence 0.99
tests\EUC-JP\akaname.main.jp.xml                             EUC-JP with confidence 0.99
tests\EUC-JP\arclamp.jp.xml                                  EUC-JP with confidence 0.99
.
.
.
316 tests</samp></pre>
<p>No to mě podrž, ono to funguje! <em><a href="http://www.hampsterdance.com/">/me si trošku zatancuju</a></em> 
<p class=a>&#x2042; 

<h2 id=case-study-porting-chardet-to-python-3-summary>Shrnutí</h2>
<p>Co jsme se naučili? 
<ol>
<li>Přepisování jakéhokoliv netriviálního kódu z Pythonu 2 do Pythonu 3 bude bolestivé. Nedá se to obejít. Je to obtížné. 
<li><a href=#chapter-porting-code-to-python-3-with-2to3>Automatický nástroj <code>2to3</code></a> nám částečně pomůže, ale postará se jen o snadnější části&nbsp;&mdash;&nbsp;přejmenování funkcí, přejmenování modulů, úpravy syntaxe. Jde o impozantní kus inženýrské práce, ale koneckonců jde jen o inteligentního robota provádějícího vyhledávání a náhrady. 
<li>Problémem č. 1 při přepisování této knihovny byl rozdíl mezi řetězci a bajty. V tomto případě se to zdá být zřejmé, protože hlavním účelem knihovny <code>chardet</code> je převod proudu bajtů na řetězec. Ale „s proudem bajtů“ se setkáváme častěji, než byste si mysleli. Čtete soubor v „binárním“ režimu? Dostáváte proud bajtů. Získáváte obsah webovské stránky? Voláte webové aplikační rozhraní? Také se vrací proud bajtů. 
<li>Programu musíte rozumět <em>vy</em>. Skrz naskrz. Především protože jste ho napsali, ale musíte se vyrovnat se všemi jeho triky a zatuchlými kouty. Chyby jsou všude. 
<li>Testovací případy jsou nepostradatelné. Pokud je nemáte, nic nepřepisujte. <em>Jediný</em> důvod, proč věřím tomu, že <code>chardet</code> funguje v Pythonu 3, spočívá v tom, že jsem začal s testovací sadou, která prověřovala všechny hlavní cesty, kudy se kód ubírá. Pokud žádné testy nemáte, napište je dříve, než začnete přenos do Pythonu 3 realizovat. Pokud máte jen pár testů, napište jich víc. Pokud máte hodně testů, pak teprve může začít opravdová legrace.
</ol>

</div>
<div id=chapter-packaging>
<h1>Balení pythonovských knihoven</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> You’ll find the shame is like the pain; you only feel it once. <span class="u">&#x275E;</span><br>(Zjistíte, že stud je jako bolest; ale cítíte ho jen jednou.)<br>&mdash; Markýza de Merteuil, <a href="http://www.imdb.com/title/tt0094947/quotes"><cite>Dangerous Liaisons</cite></a> (<a href="http://cs.wikipedia.org/wiki/Nebezpe%C4%8Dn%C3%A9_zn%C3%A1mosti"><cite>Nebezpečné známosti</cite></a>)
</blockquote>
<p>&nbsp;
<h2 id=packaging-divingin>Ponořme se</h2>
<p class=f>Opravdoví umělci prodávají. Alespoň takhle to říká Steve Jobs. Chcete vydat pythonovský skript, knihovnu, rámec (framework) nebo aplikaci? Výborně. Svět potřebuje více pythonovského kódu. Python 3 se dodává s rámcem pro vytváření balíčků zvaným Distutils. Distutils v sobě skrývá mnoho věcí: nástroj pro sestavení (build tool; pro vás), instalační nástroj (pro vaše uživatele), formát metadat balíčků (pro vyhledávače) a další. Tvoří celek s <a href="http://pypi.python.org/">Python Package Index</a> („PyPI“), což je centrální archiv pythonovských open-source knihoven.

<p>Všechny uvedené stránky nástroje Distutils jsou soustředěny kolem <i>instalačního skriptu</i>, který se tradičně nazývá <code>setup.py</code>. Ve skutečnosti už jste v této knize několik instalačních skriptů vytvořených nástrojem Distutils viděli. Distutils jste použili k instalaci <code>httplib2</code> v kapitole <a href=#http-web-services-introducing-httplib2>Webové služby nad HTTP</a> a znovu k instalaci <code>chardet</code> v <a href=#chapter-case-study-porting-chardet-to-python-3>Případové studii: Přepis <code>chardet</code> pro Python 3</a>.

<p>V této kapitole si prostudujeme, jak instalační skripty pro <code>chardet</code> a pro <code>httplib2</code> pracují, a projdeme si procesem vydání vašeho vlastního pythonovského softwaru.

<pre class=pp><code># chardet's setup.py
from distutils.core import setup
setup(
    name = "chardet",
    packages = ["chardet"],
    version = "1.0.2",
    description = "Universal encoding detector",
    author = "Mark Pilgrim",
    author_email = "mark@diveintomark.org",
    url = "http://chardet.feedparser.org/",
    download_url = "http://chardet.feedparser.org/download/python3-chardet-1.0.1.tgz",
    keywords = ["encoding", "i18n", "xml"],
    classifiers = [
        "Programming Language :: Python",
        "Programming Language :: Python :: 3",
        "Development Status :: 4 - Beta",
        "Environment :: Other Environment",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)",
        "Operating System :: OS Independent",
        "Topic :: Software Development :: Libraries :: Python Modules",
        "Topic :: Text Processing :: Linguistic",
        ],
    long_description = """\
Universal character encoding detector
-------------------------------------

Detects
 - ASCII, UTF-8, UTF-16 (2 variants), UTF-32 (4 variants)
 - Big5, GB2312, EUC-TW, HZ-GB-2312, ISO-2022-CN (Traditional and Simplified Chinese)
 - EUC-JP, SHIFT_JIS, ISO-2022-JP (Japanese)
 - EUC-KR, ISO-2022-KR (Korean)
 - KOI8-R, MacCyrillic, IBM855, IBM866, ISO-8859-5, windows-1251 (Cyrillic)
 - ISO-8859-2, windows-1250 (Hungarian)
 - ISO-8859-5, windows-1251 (Bulgarian)
 - windows-1252 (English)
 - ISO-8859-7, windows-1253 (Greek)
 - ISO-8859-8, windows-1255 (Visual and Logical Hebrew)
 - TIS-620 (Thai)

This version requires Python 3 or later; a Python 2 version is available separately.
"""
)</code></pre>

<blockquote class=note>
<p><span class="u">&#x261E;</span><code>chardet</code> a <code>httplib2</code> jsou open source, ale neexistuje žádný požadavek na to, abyste své vlastní pythonovské knihovny vydávali pod nějakou konkrétní licencí. Proces popisovaný v této kapitole bude fungovat pro libovolný pythonovský software, nezávisle na licenci.
</blockquote>

<p class=a>&#x2042;

<h2 id=packaging-cantdo>Věci, které za nás Distutils neudělají</h2>

<p>Vypuštění vašeho prvního pythonovského balíčku je skličující proces. (Uvolnění vašeho druhého balíčku je o něco snazší.) Distutils se celý proces snaží zautomatizovat, jak jen to je možné. Ale některé věci prostě musíte udělat sami.

<ul>
<li><b>Vybrat licenci</b>. Tohle je komplikované téma, zatížené politikou a rizikem. Pokud svůj software chcete zveřejnit jako open source, skromně doporučuji pět následujících rad:

<ol>
<li>Nepište svou vlastní licenci.
<li>Nepište svou vlastní licenci.
<li>Nepište svou vlastní licenci.
<li>Nemusí to být zrovna <abbr>GPL</abbr>, ale <a href="http://www.dwheeler.com/essays/gpl-compatible.html">měla by být s <abbr>GPL</abbr> slučitelná</a>.
<li>Nepište svou vlastní licenci.
</ol>
<li><b>Zařaďte svůj software</b> pomocí klasifikačního systému PyPI. Později v této kapitole vysvětlím, co to znamená.
<li><b>Napište soubor „read me“ (čti mne)</b>. Tohle neodflákněte. Vaši uživatelé by se z něj měli dozvědět přinejmenším to, co váš software dělá a jak se instaluje.
</ul>

<p class=a>&#x2042;

<h2 id=packaging-structure>Struktura adresáře</h2>

<p>Vytváření balíčku pro váš pythonovský software začíná tím, že si musíte udělat pořádek v souborech a v adresářích. Adresář <code>httplib2</code> vypadá takto:

<pre class=screen>
<a>httplib2/                 <span class=u>&#x2460;</span></a>
|
<a>+--README.txt             <span class=u>&#x2461;</span></a>
|
<a>+--setup.py               <span class=u>&#x2462;</span></a>
|
<a>+--httplib2/              <span class=u>&#x2463;</span></a>
   |
   +--__init__.py
   |
   +--iri2uri.py</pre>
<ol>
<li>Vytvořte kořenový adresář, ve kterém bude všechno. Dejte mu stejné jméno, jaké má váš pythonovský modul.
<li>Abyste se přizpůsobili uživatelům Windows, měl by váš soubor „read me“ použít příponu <code>.txt</code> a měl by používat windowsovské konce řádků. To, že <em>vy</em> používáte nějaký fantastický editor, který se dá spouštět z příkazového řádku a má i svůj makro jazyk, neznamená, že byste měli ztěžovat život svým uživatelům. (Vaši uživatelé používají „Notepad“, česky „Poznámkový blok“. Je to smutné, ale je to tak.) Váš oblíbený editor má nepochybně volbu pro ukládání souborů s windowsovskými konci řádků &mdash; i když pracujete v Linuxu nebo s Mac OS X.
<li>Váš instalační skript využívající Distutils by měl být pojmenován <code>setup.py</code> &mdash; pokud nemáte dobrý důvod pro to, aby se jmenoval jinak. A vy nemáte dobrý důvod, aby se jmenoval jinak.
<li>Pokud se váš pythonovský software skládá z jediného souboru s příponou <code>.py</code>, měli byste jej umístit do kořenového adresáře spolu se svým souborem „read me“ a se svým instalačním skriptem. Ale <code>httplib2</code> se neskládá z jediného <code>.py</code> souboru. Je to <a href=#case-study-porting-chardet-to-python-3-multifile-modules>vícesouborový modul</a>. Ale to je v pořádku! Adresář <code>httplib2</code> umístěte do kořenového adresáře, takže budete mít soubor <code>__init__.py</code> umístěn v adresáři <code>httplib2/</code> v kořenovém adresáři <code>httplib2/</code>. Nehledejte v tom problém. Ve skutečnosti to zjednoduší proces vytváření balíčku.
</ol>

<p>Adresář <code>chardet</code> vypadá trochu jinak. Stejně jako u <code>httplib2</code> jde o <a href=#case-study-porting-chardet-to-python-3-multifile-modules>vícesouborový modul</a>, takže tu máme adresář <code>chardet/</code> uvnitř kořenového adresáře <code>chardet/</code>. K souboru <code>README.txt</code> má <code>chardet</code> navíc <abbr>HTML</abbr> dokumentaci, umístěnou v adresáři <code>docs/</code>. Adresář <code>docs/</code> obsahuje několik souborů s příponami <code>.html</code> a <code>.css</code> a podadresář <code>images/</code>, který obsahuje několik souborů s příponami <code>.png</code> a <code>.gif</code>. (To bude důležité později.) V souladu s konvencemi pro software s licencí <abbr>(L)GPL</abbr> obsahuje také samostatný soubor zvaný <code>COPYING.txt</code>, který obsahuje kompletní text <abbr>LGPL</abbr>.

<pre class=nd><code>
chardet/
|
+--COPYING.txt
|
+--setup.py
|
+--README.txt
|
+--docs/
|  |
|  +--index.html
|  |
|  +--usage.html
|  |
|  +--images/ ...
|
+--chardet/
   |
   +--__init__.py
   |
   +--big5freq.py
   |
   +--...
</code></pre>

<p class=a>&#x2042;

<h2 id=packaging-setuppy>Píšeme svůj instalační skript</h2>

<p>Instalační skript pro Distutils je pythonovský skript. Teoreticky by mohl dělat vše, co lze dělat v pythonovských skriptech. Prakticky by toho měl dělat co nejméně a co nejstandardnějším způsobem. Instalační skript by měl být nudný. Čím exotičtější bude váš instalační proces, tím exotičtější budou hlášení o chybách.

<p>První řádek každého instalačního skriptu pro Distutils je vždycky stejný:

<pre class='nd pp'><code>from distutils.core import setup</code></pre>

<p>Importujeme funkci <code>setup()</code>, která je hlavním vstupním bodem rámce Distutils. 95&nbsp;% všech distutilsovských skriptů se skládá z jediného volání funkce <code>setup()</code> a z ničeho jiného. (Tuhle statistiku jsem si právě vymyslel, ale pokud váš distutilsovský skript dělá něco víc než volání funkce <code>setup()</code> z Distutils, měli byste pro to mít dobrý důvod. A máte pro to dobrý důvod? Myslím, že ne.)

<p>Funkce <code>setup()</code> <a href="http://docs.python.org/3.1/distutils/apiref.html#distutils.core.setup">přebírá celou řadu parametrů</a>. V zájmu zachování duševního zdraví všech zúčastněných musíte pro každý parametr používat <a href=#your-first-python-program-optional-arguments>pojmenované argumenty</a>. Není to jen nějaká konvence. Je to tvrdý požadavek. Pokud se pokusíte o volání funkce <code>setup()</code> s nepojmenovanými argumenty, váš instalační skript zhavaruje.

<p>Následující pojmenované argumety jsou povinné:

<ul>
<li><b>name</b> &mdash; jméno balíčku.
<li><b>version</b> &mdash; verze balíčku.
<li><b>author</b> &mdash; vaše celé jméno.
<li><b>author_email</b> &mdash; vaše e-mailová adresa.
<li><b>url</b> &mdash; domácí stránka vašeho projektu. Pokud pro projekt nemáte vyhrazen zvláštní webový server, můžete zde uvést stránku svého balíčku v <a href="http://pypi.python.org/">PyPI</a>.
</ul>

<p>Ačkoliv to není povinné, doporučuji, abyste ve svém instalačním skriptu uvedli také následující:

<ul>
<li><b>description</b>, jednořádkový popis projektu.
<li><b>long_description</b>, víceřádkový řetězec ve formátu <a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>. <a href="http://pypi.python.org/">PyPI</a> ho převede do <abbr>HTML</abbr> a zobrazí ho na stránce pro váš balíček.
<li><b>classifiers</b>, seznam zvláštním způsobem formátovaných řetězců, které si popíšeme v následující podkapitole.
</ul>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Metadata instalačního skriptu jsou definována v <a href="http://www.python.org/dev/peps/pep-0314/"><abbr>PEP</abbr> 314</a>.
</blockquote>

<p>Teď se podíváme na instalační skript pro <code>chardet</code>. Používá všechny zmíněné povinné a doporučené parametry a ještě jeden, o kterém jsem se zatím nezmínil: <code>packages</code>.

<pre class='nd pp'><code>from distutils.core import setup
setup(
    name = 'chardet',
    <mark>packages = ['chardet']</mark>,
    version = '1.0.2',
    description = 'Universal encoding detector',
    author='Mark Pilgrim',
    ...
)</code></pre>

<p>Parametr <code>packages</code> zvýrazňuje jedno nešťastné překrývání významů slov během distribučního procesu. O slově „balíček/balík“ (package) jsme se bavili jako o něčem, co vytváříme (a co se potenciálně vypisuje v seznamu PyPI). Jenže to není tím, na co se parametr <code>packages</code> odkazuje. Vztahuje se ke skutečnosti, že <code>chardet</code> je <a href=#case-study-porting-chardet-to-python-3-multifile-modules>vícesouborovým modulem</a>, kterému se také někdy říká&hellip; „package“ (balíček). Parametr <code>packages</code> nástroji Distutils říká, aby do procesu zahrnul adresář <code>chardet/</code>, jeho soubor <code>__init__.py</code> a všechny ostatní soubory s příponou <code>.py</code>, ze kterých se modul <code>chardet</code> skládá. To je docela důležité. Veškerá radostná rozprava o dokumentaci a metadatech je k ničemu, pokud zapomenete přibalit skutečný kód!

<p class=a>&#x2042;

<h2 id=packaging-trove>Přidáváme klasifikaci našeho balíčku</h2>

<p>The Python Package Index („PyPI“) obsahuje tisíce pythonovských knihoven. Ostatní lidé najdou váš balíček snadněji, když použijete správná klasifikační metadata. PyPI vám umožní <a href="http://pypi.python.org/pypi?:action=browse">prohlížet balíčky uspořádané podle klasifikátorů</a>. Pro zúžení nabídky při vyhledávání můžete vybrat dokonce více klasifikátorů. Klasifikátory prostě nejsou jen neviditelná metadata, která byste mohli ignorovat!

<p>Klasifikaci svého softwaru provedete předáním parametru <code>classifiers</code> distutilovské funkci <code>setup()</code>. Parametr <code>classifiers</code> má podobu seznamu řetězců. Ale tyto řetězce <em>nemají</em> volný formát. Všechny klasifikační řetězce by měly pocházet z <a href="http://pypi.python.org/pypi?:action=list_classifiers">tohoto seznamu na PyPI</a>.

<p>Klasifikátory jsou nepovinné. Můžete napsat distutilovský instalační skript bez jakýchkoliv klasifikátorů. <strong>Nedělejte to.</strong> Měli byste <em>vždy</em> uvést alespoň následující klasifikátory:

<ul>
<li><b>Programming Language</b> (programovací jazyk). Konkrétně by měl zahrnovat jak <code>"Programming Language :: Python"</code>, tak <code>"Programming Language :: Python :: 3"</code>. Pokud je neuvedete, nebude se váš balíček ukazovat <a href="http://pypi.python.org/pypi?:action=browse&amp;c=533&amp;show=all">v tomto seznamu knihoven kompatibilních s Pythonem 3</a>, na který se dostanete přes odkaz uvedený v bočním sloupku na každé stránce z <code>pypi.python.org</code>.
<li><b>License</b> (licence). Pokud zkouším nějakou knihovnu třetí strany, je to <em>absolutně první věc, na kterou se dívám</em>. Nechtějte po mně, abych tuto životně důležitou informaci musel někde hledat. Pokud se váš software nedodává pod více licencemi, neuvádějte víc než jeden licenční klasifikátor. (A pokud k tomu nejste nějak nuceni, nevydávejte svůj software pod více licencemi. A nenuťte k tomu ostatní lidi. Licencování stačí k bolení hlavy už i tak. Nedělejte to ještě horší.)
<li><b>Operating System</b> (operační systém). Pokud váš software běží pouze pod Windows (nebo jen pod Mac OS X nebo jen pod Linuxem), rád bych se to dozvěděl raději dřív než později. Pokud váš software běží kdekoliv, aniž by potřeboval nějaký platformově závislý kód, použijte klasifikátor <code>"Operating System :: OS Independent"</code>. Použití více klasifikátorů <code>Operating System</code> je nezbytné pouze v případě, kdy váš software vyžaduje pro každou platformu specifickou podporu. (Běžně tomu tak nebývá.)
</ul>

<p>Doporučuji, abyste uvedli i následující klasifikátory:

<ul>
<li><b>Development Status</b> (stav vývoje). Lze kvalitu vašeho softwaru ohodnotit přívlastkem beta? Alfa? Nebo se nachází ještě v ranějším stadiu (pre-alpha)? Jednu z možností uveďte. Buďte upřímní.
<li><b>Intended Audience</b> (zamýšlená skupina uživatelů). Kdo by mohl chtít stahovat váš software? Nejpoužívanější volby jsou <code>Developers</code> (vývojáři), <code>End Users/Desktop</code> (koncoví uživatelé), <code>Science/Research</code> (věda a výzkum), and <code>System Administrators</code> (správci systémů).
<li><b>Framework</b> (rámec). Pokud lze váš software považovat za zásuvný modul (plugin) pro větší pythonovské rámce, jako jsou například <a href="http://www.djangoproject.com/">Django</a> nebo <a href="http://www.zope.org/">Zope</a>, uveďte příslušný klasifikátor <code>Framework</code>. Pokud tomu tak není, neuvádějte jej.
<li><b>Topic</b> (tematická oblast). Zde naleznete <a href="http://pypi.python.org/pypi?:action=list_classifiers">velké množství oblastí, ze kterých si můžete vybrat</a>. Uveďte všechny, které vašemu softwaru odpovídají.
</ul>

<h3 id=packaging-trove-examples>Příklady dobrých klasifikátorů balíčků</h3>

<p>Jako příklad uveďme klasifikátory pro <a href="http://pypi.python.org/pypi/Django/">Django</a>, což je multiplatformní aplikační rámec (framework), který můžete spouštět na svém webovém serveru. Dodává se pod licencí <abbr>BSD</abbr> a je využitelný pro ostrý provoz (production-ready). (Django zatím není kompatibilní s Pythonem 3, takže není uveden klasifikátor <code>Programming Language :: Python :: 3</code>.)

<pre><code>Programming Language :: Python
License :: OSI Approved :: BSD License
Operating System :: OS Independent
Development Status :: 5 - Production/Stable
Environment :: Web Environment
Framework :: Django
Intended Audience :: Developers
Topic :: Internet :: WWW/HTTP
Topic :: Internet :: WWW/HTTP :: Dynamic Content
Topic :: Internet :: WWW/HTTP :: WSGI
Topic :: Software Development :: Libraries :: Python Modules</code></pre>

<p>Tady jsou klasifikátory pro <a href="http://pypi.python.org/pypi/chardet"><code>chardet</code></a>, což je knihovna pro detekci znakového kódování, kterou jsme se zabývali v <a href=#chapter-case-study-porting-chardet-to-python-3>Případové studii: Přepis <code>chardet</code> pro Python 3</a>. <code>chardet</code> je ve stadiu beta, je multiplatformní, kompatibilní s Pythonem 3, pod licencí <abbr>LGPL</abbr> a je určena pro vývojáře, kteří ji mohou začlenit do svých vlastních produktů.

<pre><code>Programming Language :: Python
Programming Language :: Python :: 3
License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)
Operating System :: OS Independent
Development Status :: 4 - Beta
Environment :: Other Environment
Intended Audience :: Developers
Topic :: Text Processing :: Linguistic
Topic :: Software Development :: Libraries :: Python Modules</code></pre>

<p>A tady jsou klasifikátory pro <a href="http://pypi.python.org/pypi/httplib2"><code>httplib2</code></a>, což je knihovna, o které jsme se bavili v kapitole <a href=#chapter-http-web-services>Webové služby nad <abbr>HTTP</abbr></a>. <code>httplib2</code> je ve stadiu beta, multiplatformní, pod licencí <abbr>MIT</abbr> a je učena pro pythonovské vývojáře.

<pre><code>Programming Language :: Python
Programming Language :: Python :: 3
License :: OSI Approved :: MIT License
Operating System :: OS Independent
Development Status :: 4 - Beta
Environment :: Web Environment
Intended Audience :: Developers
Topic :: Internet :: WWW/HTTP
Topic :: Software Development :: Libraries :: Python Modules</code></pre>

<h2 id=packaging-manifest>Určení dalších souborů prostřednictvím manifestu</h2>

<p>Pokud neurčíme jinak, zahrnou Distutils do vašeho instalačního balíčku následující soubory:

<ul>
<li><code>README.txt</code>
<li><code>setup.py</code>
<li>Soubory s příponou <code>.py</code>, které se používají ve vícesouborových modulech uvedených v seznamu parametru <code>packages</code>.
<li>Jednotlivé soubory s příponou <code>.py</code>, které jsou uvedeny v seznamu parametru <code>py_modules</code>.
</ul>

<p>Tímto způsobem lze pokrýt <a href=#packaging-structure>všechny soubory projektu <code>httplib2</code></a>. Ale u projektu <code>chardet</code> potřebujeme zařadit i licenční soubor <code>COPYING.txt</code> a celý adresář <code>docs/</code>, který obsahuje obrázky a <abbr>HTML</abbr> soubory. Pokud chceme Distutils říci, aby byly při tvorbě instalačního balíčku <code>chardet</code> zařazeny i tyto dodatečné soubory a adresáře, musíme použít <i>soubor s manifestem</i> (manifest file).

<p>Soubor s manifestem je textový soubor s názvem <code>MANIFEST.in</code>. Umístíme jej do kořenového adresáře projektu, vedle souborů <code>README.txt</code> a <code>setup.py</code>. Soubory s manifestem <em>nejsou</em> pythonovské skripty. Jsou to textové soubory, které obsahují posloupnosti „příkazů“ ve formátu pro Distutils. Příkazy manifestu nám umožňují zahrnovat nebo vyřazovat konkrétní soubory a adresáře.

<p>Následuje celý obsah souboru manifestu pro projekt <code>chardet</code>:

<pre class=nd><code><a>include COPYING.txt                                <span class=u>&#x2460;</span></a>
<a>recursive-include docs *.html *.css *.png *.gif    <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>První řádek je samovysvětlující: vložit soubor <code>COPYING.txt</code> z kořenového adresáře projektu.
<li>Druhý řádek je trochu složitější. Příkaz <code>recursive-include</code> přebírá jméno adresáře a jedno nebo víc jmen souborů. Jména souborů nemusí být uvedena explicitně. Mohou být vyjádřena zástupnými znaky (wildcards). Tento řádek znamená: „Vidíš adresář <code>docs/</code> v kořenovém adresáři projektu? Najdi v něm (rekurzivně) soubory s příponami <code>.html</code>, <code>.css</code>, <code>.png</code> a <code>.gif</code>. Chci, aby byly všechny zařazeny do instalačního balíčku.“
</ol>

<p>Všechny příkazy manifestu zachovávají strukturu adresářů, která je vytvořena v kořenovém adresáři projektu. Uvedený příkaz <code>recursive-include</code> nenacpe všechny <code>.html</code> a <code>.png</code> soubory do kořenového adresáře instalačního balíčku. Dodrží existující strukturu adresáře <code>docs/</code>, ale zařadí do ní jen ty soubory, které odpovídají zadaným maskám se zástupnými znaky. (Dříve jsem se o tom nezmiňoval, ale dokumentace <code>chardet</code> je ve skutečnosti napsaná v <abbr>XML</abbr> a do <abbr>HTML</abbr> je převedena samostatným skriptem. Do instalačního balíčku nechci zařazovat zdrojové <abbr>XML</abbr> soubory, ale jen výsledné <abbr>HTML</abbr> soubory a obrázky.)

<blockquote class=note>
<p><span class="u">&#x261E;</span>Soubory s manifestem mají svůj specifický formát. Detaily hledejte v dokumentech <a href="http://docs.python.org/3.1/distutils/sourcedist.html#manifest">Specifying the files to distribute</a> a <a href="http://docs.python.org/3.1/distutils/commandref.html#sdist-cmd">The manifest template commands</a>.
</blockquote>

<p>Zopakujme si to: soubor s manifestem musíme vytvářet jen v případě, kdy chceme zahrnout i soubory, které nástroj Distutils nevkládá automaticky. Pokud potřebujeme použít soubor s manifestem, měl by obsahovat jen jména souborů, která by jinak nástroj Distutils nenašel sám.

<h2 id=packaging-check>Kontrola chyb v našem instalačním skriptu</h2>

<p>Musíme myslet na spoustu věcí. Distutils mají zabudovaný validační příkaz, který kontroluje, že náš instalační skript obsahuje všechna povinná metadata. Pokud například zapomeneme uvést parametr <code>version</code>, Distutils nám to připomenou.

<pre class=screen>
<samp class=p>c:\Users\pilgrim\chardet> </samp><kbd>c:\python31\python.exe setup.py check</kbd>
<samp>running check
warning: check: missing required meta-data: version</samp></pre>

<p>Jakmile parametr <code>version</code> uvedeme (a všechny ostatní povinné části metadat), příkaz <code>check</code> dopadne takto:

<pre class=screen>
<samp class=p>c:\Users\pilgrim\chardet> </samp><kbd>c:\python31\python.exe setup.py check</kbd>
<samp>running check</samp></pre>

<p class=a>&#x2042;

<h2 id=packaging-sdist>Vytvoření distribuce obsahující zdrojové texty</h2>

<p>Distutils podporují tvorbu mnoha typů distribučních balíčků. Přinejmenším bychom měli vytvořit „distribuci zdrojů“ (source distribution), která obsahuje naše zdrojové texty s kódem, instalační skript pro Distutils, soubor „read me“ a jakékoliv <a href=#packaging-manifest>další soubory, které chceme do distribuce zahrnout</a>. Distribuci zdrojů vytvoříme tím, že instalačnímu skriptu Distutils zadáme příkaz <code>sdist</code>.

<pre class=screen>
<samp class=p>c:\Users\pilgrim\chardet> </samp><kbd><mark>c:\python31\python.exe setup.py sdist</mark></kbd>
<samp>running sdist
running check
reading manifest template 'MANIFEST.in'
writing manifest file 'MANIFEST'
creating chardet-1.0.2
creating chardet-1.0.2\chardet
creating chardet-1.0.2\docs
creating chardet-1.0.2\docs\images
copying files to chardet-1.0.2...
copying COPYING -> chardet-1.0.2
copying README.txt -> chardet-1.0.2
copying setup.py -> chardet-1.0.2
copying chardet\__init__.py -> chardet-1.0.2\chardet
copying chardet\big5freq.py -> chardet-1.0.2\chardet
...
copying chardet\universaldetector.py -> chardet-1.0.2\chardet
copying chardet\utf8prober.py -> chardet-1.0.2\chardet
copying docs\faq.html -> chardet-1.0.2\docs
copying docs\history.html -> chardet-1.0.2\docs
copying docs\how-it-works.html -> chardet-1.0.2\docs
copying docs\index.html -> chardet-1.0.2\docs
copying docs\license.html -> chardet-1.0.2\docs
copying docs\supported-encodings.html -> chardet-1.0.2\docs
copying docs\usage.html -> chardet-1.0.2\docs
copying docs\images\caution.png -> chardet-1.0.2\docs\images
copying docs\images\important.png -> chardet-1.0.2\docs\images
copying docs\images\note.png -> chardet-1.0.2\docs\images
copying docs\images\permalink.gif -> chardet-1.0.2\docs\images
copying docs\images\tip.png -> chardet-1.0.2\docs\images
copying docs\images\warning.png -> chardet-1.0.2\docs\images
creating dist
creating 'dist\chardet-1.0.2.zip' and adding 'chardet-1.0.2' to it
adding 'chardet-1.0.2\COPYING'
adding 'chardet-1.0.2\PKG-INFO'
adding 'chardet-1.0.2\README.txt'
adding 'chardet-1.0.2\setup.py'
adding 'chardet-1.0.2\chardet\big5freq.py'
adding 'chardet-1.0.2\chardet\big5prober.py'
...
adding 'chardet-1.0.2\chardet\universaldetector.py'
adding 'chardet-1.0.2\chardet\utf8prober.py'
adding 'chardet-1.0.2\chardet\__init__.py'
adding 'chardet-1.0.2\docs\faq.html'
adding 'chardet-1.0.2\docs\history.html'
adding 'chardet-1.0.2\docs\how-it-works.html'
adding 'chardet-1.0.2\docs\index.html'
adding 'chardet-1.0.2\docs\license.html'
adding 'chardet-1.0.2\docs\supported-encodings.html'
adding 'chardet-1.0.2\docs\usage.html'
adding 'chardet-1.0.2\docs\images\caution.png'
adding 'chardet-1.0.2\docs\images\important.png'
adding 'chardet-1.0.2\docs\images\note.png'
adding 'chardet-1.0.2\docs\images\permalink.gif'
adding 'chardet-1.0.2\docs\images\tip.png'
adding 'chardet-1.0.2\docs\images\warning.png'
removing 'chardet-1.0.2' (and everything under it)</samp></pre>

<p>Tady bychom se měli zmínit o několika věcech:

<ul>
<li>Distutils si všimly souboru s manifestem (<code>MANIFEST.in</code>).
<li>Distutils soubor s manifestem úspěšně zpracovaly a přidaly předepsané soubory&nbsp;&mdash;&nbsp;<code>COPYING.txt</code> a <abbr>HTML</abbr> soubory a soubory s obrázky v adresáři <code>docs/</code>.
<li>Pokud se podíváme do adresáře projektu, uvidíme, že Distutils vytvořily adresář <code>dist/</code>. V adresáři <code>dist/</code> se nachází soubor s příponou <code>.zip</code>, který můžeme distribuovat.
</ul>

<pre class=screen>
<samp class=p>c:\Users\pilgrim\chardet> </samp><kbd><mark>dir dist</mark></kbd>
<samp> Volume in drive C has no label.
 Volume Serial Number is DED5-B4F8

 Directory of c:\Users\pilgrim\chardet\dist

07/30/2009  06:29 PM    &lt;DIR>          .
07/30/2009  06:29 PM    &lt;DIR>          ..
07/30/2009  06:29 PM           206,440 <mark>chardet-1.0.2.zip</mark>
               1 File(s)        206,440 bytes
               2 Dir(s)  61,424,635,904 bytes free</samp></pre>

<p class=a>&#x2042;

<h2 id=packaging-bdist>Vytvoření grafického instalačního programu</h2>

<p>Podle mého názoru si každá pythonovská knihovna zaslouží, aby byl pro uživatele Windows k dispozici grafický instalační program. Dá se udělat snadno (i když sami Windows nepoužíváte) a uživatelé Windows to ocení.

<p>Distutils dovedou <a href="http://docs.python.org/3.1/distutils/builtdist.html#creating-windows-installers">vytvořit grafický instalační program pro Windows za nás</a>. Stačí, když instalačnímu skriptu pro Distutils zadáme příkaz <code>bdist_wininst</code>.

<pre class=screen>
<samp class=p>c:\Users\pilgrim\chardet> </samp><kbd><mark>c:\python31\python.exe setup.py bdist_wininst</mark></kbd>
<samp>running bdist_wininst
running build
running build_py
creating build
creating build\lib
creating build\lib\chardet
copying chardet\big5freq.py -> build\lib\chardet
copying chardet\big5prober.py -> build\lib\chardet
...
copying chardet\universaldetector.py -> build\lib\chardet
copying chardet\utf8prober.py -> build\lib\chardet
copying chardet\__init__.py -> build\lib\chardet
installing to build\bdist.win32\wininst
running install_lib
creating build\bdist.win32
creating build\bdist.win32\wininst
creating build\bdist.win32\wininst\PURELIB
creating build\bdist.win32\wininst\PURELIB\chardet
copying build\lib\chardet\big5freq.py -> build\bdist.win32\wininst\PURELIB\chardet
copying build\lib\chardet\big5prober.py -> build\bdist.win32\wininst\PURELIB\chardet
...
copying build\lib\chardet\universaldetector.py -> build\bdist.win32\wininst\PURELIB\chardet
copying build\lib\chardet\utf8prober.py -> build\bdist.win32\wininst\PURELIB\chardet
copying build\lib\chardet\__init__.py -> build\bdist.win32\wininst\PURELIB\chardet
running install_egg_info
Writing build\bdist.win32\wininst\PURELIB\chardet-1.0.2-py3.1.egg-info
creating 'c:\users\pilgrim\appdata\local\temp\tmp2f4h7e.zip' and adding '.' to it
adding 'PURELIB\chardet-1.0.2-py3.1.egg-info'
adding 'PURELIB\chardet\big5freq.py'
adding 'PURELIB\chardet\big5prober.py'
...
adding 'PURELIB\chardet\universaldetector.py'
adding 'PURELIB\chardet\utf8prober.py'
adding 'PURELIB\chardet\__init__.py'
removing 'build\bdist.win32\wininst' (and everything under it)</samp>
<samp class=p>c:\Users\pilgrim\chardet> </samp><kbd><mark>dir dist</mark></kbd>
<samp>c:\Users\pilgrim\chardet>dir dist
 Volume in drive C has no label.
 Volume Serial Number is AADE-E29F

 Directory of c:\Users\pilgrim\chardet\dist

07/30/2009  10:14 PM    &lt;DIR>          .
07/30/2009  10:14 PM    &lt;DIR>          ..
07/30/2009  10:14 PM           371,236 <mark>chardet-1.0.2.win32.exe</mark>
07/30/2009  06:29 PM           206,440 chardet-1.0.2.zip
               2 File(s)        577,676 bytes
               2 Dir(s)  61,424,070,656 bytes free</samp></pre>

<h3 id=packaging-linux>Tvorba instalačních balíčků pro jiné operační systémy</h3>

<p>Distutils nám mohou pomoci <a href="http://docs.python.org/3.1/distutils/builtdist.html#creating-rpm-packages">vytvořit instalační balíčky pro uživatele Linuxu</a>. Ale podle mého názoru to nestojí za tu námahu. Pokud chcete svůj software distribuovat v Linuxu, měli byste svůj čas raději věnovat spolupráci se skupinou lidí, kteří se specializují na vytváření softwarových balíčků pro hlavní distribuce Linuxu.

<p>Například moji knihovnu <code>chardet</code> najdete <a href="http://packages.debian.org/python-chardet">v archivech pro Debian GNU/Linux</a> (a tím pádem i <a href="http://packages.ubuntu.com/python-chardet">v archivech pro Ubuntu</a>). Nemusel jsem se o to vůbec starat. Balíčky se tam jednoho dne prostě objevily. Komunita kolem distribuce Debian má <a href="http://www.debian.org/doc/packaging-manuals/python-policy/">svá vlastní pravidla pro balení pythonovských knihoven</a> a balíček <code>python-chardet</code> pro Debian je navržen tak, aby tyto konvence splňoval. A protože jsou balíčky umístěny v archivech Debianu, získávají uživatelé Debianu bezpečnostní aktualizace a/nebo nové verze podle toho, jaká systémová nastavení si pro údržbu svých počítačů zvolili.

<p>Linuxovské balíčky vytvářené nástrojem Distutils žádnou z těchto výhod nenabízejí. Bude lepší, když svůj čas strávíte jiným způsobem.

<p class=a>&#x2042;

<h2 id=packaging-pypi>Přidání našeho softwaru do Python Package Index</h2>

<p>Nahrání našeho softwaru do Python Package Index představuje proces o třech krocích.

<ol>
<li>Zaregistrujeme se.
<li>Zaregistrujeme svůj software.
<li>Uložíme (upload) balíčky, které jsme vytvořili příkazy <code>setup.py sdist</code> a <code>setup.py bdist_*</code>.
</ol>

<p>Registraci své osoby provedeme prostřednictvím <a href="http://pypi.python.org/pypi?:action=register_form">registrační stránky pro uživatele PyPI</a>. Vložíme své uživatelské jméno a heslo, poskytneme platnou e-mailovou adresu a klikneme na tlačítko <code>Register</code>. (Pokud máte klíč <abbr>PGP</abbr> nebo <abbr>GPG</abbr>, můžete jej uvést také. Pokud jej nemáte nebo nevíte, co to znamená, nedělejte si s tím starosti.) Zkontrolujeme svůj e-mail. Během několika minut bychom měli obdržet zprávu od PyPI s potvrzovacím odkazem. Registrační proces dokončíme tím, že na odkaz klikneme.

<p>Teď zaregistrujeme u PyPI náš software a nahrajeme jej (upload). To vše můžeme provést v jediném kroku.

<pre class=screen>
<a><samp class=p>c:\Users\pilgrim\chardet> </samp><kbd>c:\python31\python.exe setup.py register sdist bdist_wininst upload</kbd>  <span class=u>&#x2460;</span></a>
<samp>running register
We need to know who you are, so please choose either:
 1. use your existing login,
 2. register as a new user,
 3. have the server generate a new password for you (and email it to you), or
 4. quit</samp>
<a><samp class=p>Your selection [default 1]:  </samp><kbd>1</kbd>                                                                 <span class=u>&#x2461;</span></a>
<a><samp class=p>Username: </samp><kbd>MarkPilgrim</kbd>                                                                          <span class=u>&#x2462;</span></a>
<samp class=p>Password:</samp>
<a><samp>Registering chardet to http://pypi.python.org/pypi</samp>                                             <span class=u>&#x2463;</span></a>
<samp>Server response (200): OK</samp>
<a><samp>running sdist</samp>                                                                                  <span class=u>&#x2464;</span></a>
<samp>... output trimmed for brevity ...</samp>
<a><samp>running bdist_wininst</samp>                                                                          <span class=u>&#x2465;</span></a>
<samp>... output trimmed for brevity ...</samp>
<a><samp>running upload</samp>                                                                                 <span class=u>&#x2466;</span></a>
<samp>Submitting dist\chardet-1.0.2.zip to http://pypi.python.org/pypi
Server response (200): OK
Submitting dist\chardet-1.0.2.win32.exe to http://pypi.python.org/pypi
Server response (200): OK
I can store your PyPI login so future submissions will be faster.
(the login will be stored in c:\home\.pypirc)</samp>
<a><samp class=p>Save your login (y/N)?</samp><kbd class=pp>n</kbd>                                                                        <span class=u>&#x2467;</span></a></pre>
<ol>
<li>Když svůj projekt zveřejníme poprvé, přidají Distutils náš software do Python Package Index a přidělí mu jeho vlastní <abbr>URL</abbr>. Při dalších přístupech jednoduše aktualizují metadata projektu podle změn, které uvedeme v parametrech našeho <code>setup.py</code>. Poté se vytvoří distribuce zdrojů (source distribution; <code>sdist</code>) a instalátor pro Windows (<code>bdist_wininst</code>) a nahrají se do PyPI (<code>upload</code>).
<li>Vybereme „use your existing login“ (použij svůj existující účet) napsáním <kbd>1</kbd>, nebo prostě stiskneme <kbd>ENTER</kbd>.
<li>Napíšeme uživatelské jméno a heslo, která jsme si zvolili na <a href="http://pypi.python.org/pypi?:action=register_form">registrační stránce PyPI</a>. Distutils neopisují zadávané heslo. Místo zadávaných znaků nevypisují ani hvězdičky. Prostě napíšeme heslo a stiskneme <kbd>ENTER</kbd>.
<li>Distutils zaregistrují náš balíček v archivu Python Package Index&hellip;
<li>&hellip;vytvoří distribuci našich zdrojů (source distribution)&hellip;
<li>&hellip;vytvoří instalátor pro Windows&hellip;
<li>&hellip;a nahrají (upload) oba do Python Package Index.
<li>Pokud chceme proces zveřejňování nových verzí zautomatizovat, musíme uložit osobní údaje pro PyPI do lokálního souboru. Je to zcela proti zásadám bezpečnosti a zcela nepovinné.
</ol>

<p>Gratuluji. Teď už máte svoji vlastní stránku na Python Package Index! Její adresa je <code>http://pypi.python.org/pypi/<i>JMENO</i></code>, kde <i>JMENO</i> je řetězec, který jste předali parametrem <var>name</var> ve svém souboru <code>setup.py</code>.

<p>Pokud chceme zveřejnit novou verzi, upravíme ve svém souboru <code>setup.py</code> číslo verze a spustíme proces nahrávání (upload) znovu:

<pre class='nd screen'>
<samp class=p>c:\Users\pilgrim\chardet> </samp><kbd>c:\python31\python.exe setup.py register sdist bdist_wininst upload</kbd>
</pre>

<p class=a>&#x2042;

<h2 id=packaging-future>Více možných budoucností balení pythonovských produktů</h2>

<p>Distutils nejsou jediným nástrojem pro vytváření pythonovských balíčků, ale v době psaní tohoto textu (srpen 2009) to byl jediný rámec pro vytváření instalačních balíčků, který fungoval v Pythonu 3. Pro Python 2 existuje řada dalších rámců. Některé se soustředí na instalaci, jiné na testování a distribuci (deployment). Některé z nich možná budou přepsány pro Python 3.

<p>Následující rámce (frameworks) jsou zaměřeny na instalaci:

<ul>
<li><a href="http://pypi.python.org/pypi/setuptools">Setuptools</a>
<li><a href="http://pypi.python.org/pypi/pip">Pip</a>
<li><a href="http://bitbucket.org/tarek/distribute/">Distribute</a>
</ul>

<p>Následující se zaměřují na testování a distribuci:

<ul>
<li><a href="http://pypi.python.org/pypi/virtualenv"><code>virtualenv</code></a>
<li><a href="http://pypi.python.org/pypi/zc.buildout"><code>zc.buildout</code></a>
<li><a href="http://www.blueskyonmars.com/projects/paver/">Paver</a>
<li><a href="http://fabfile.org/">Fabric</a>
<li><a href="http://www.py2exe.org/"><code>py2exe</code></a>
</ul>

<p class=a>&#x2042;

<h2 id=packaging-furtherreading>Přečtěte si</h2>

<p>O Distutils:

<ul>
<li><a href="http://docs.python.org/3.1/distutils/">Distributing Python Modules with Distutils</a>
<li><a href="http://docs.python.org/3.1/distutils/apiref.html#module-distutils.core">Core Distutils functionality</a> uvádí všechny možné argumenty funkce <code>setup()</code>
<li><a href="http://wiki.python.org/moin/Distutils/Cookbook">Distutils Cookbook</a>
<li><a href="http://www.python.org/dev/peps/pep-0370/"><abbr>PEP</abbr> 370: Per user <code>site-packages</code> directory</a>
<li><a href="http://jessenoller.com/2009/07/19/pep-370-per-user-site-packages-and-environment-stew/"><abbr>PEP</abbr> 370 and “environment stew”</a>
</ul>

<p>O ostatních rámcích pro vytváření balíčků:

<ul>
<li><a href="http://groups.google.com/group/django-developers/msg/5407cdb400157259">The Python packaging ecosystem</a>
<li><a href="http://www.b-list.org/weblog/2008/dec/14/packaging/">On packaging</a>
<li><a href="http://blog.ianbicking.org/2008/12/14/a-few-corrections-to-on-packaging/">A few corrections to “On packaging”</a>
<li><a href="http://www.b-list.org/weblog/2008/dec/15/pip/">Why I like Pip</a>
<li><a href="http://cournape.wordpress.com/2009/04/01/python-packaging-a-few-observations-cabal-for-a-solution/">Python packaging: a few observations</a>
<li><a href="http://jacobian.org/writing/nobody-expects-python-packaging/">Nobody expects Python packaging!</a>
</ul>

</div>
<div id=chapter-porting-code-to-python-3-with-2to3>
<div id=appa>
<h1>Přepis kódu do Pythonu 3 s využitím <code>2to3</code></h1>

<blockquote class=q>
<p><span class="u">&#x275D;</span> Life is pleasant. Death is peaceful. It’s the transition that’s troublesome. <span class="u">&#x275E;</span><br>(Život je zábavný. Smrt je klidná. Nepříjemný je ten přechod.)<br>&mdash; Isaac Asimov (připsáno)
</blockquote>

<p>&nbsp;

<h2 id=porting-code-to-python-3-with-2to3-divingin>Ponořme se</h2>

<p class=f>Mezi Pythonem 2 a Pythonem 3 se toho změnilo tolik, že najdete jen mizivé procento programů, které bez úprav běží v obou verzích. Ale nepropadejte zoufalství! K usnadnění přechodu se Python 3 dodává s pomocným skriptem nazvaným <code>2to3</code>. Když mu předáte svůj zdrojový soubor napsaný pro Python 2 jako vstup, převede automaticky do podoby pro Python 3 vše, co dovede. <a href=#case-study-porting-chardet-to-python-3-running2to3>Případová studie: Přepis <code>chardet</code> pro Python 3</a> popisuje, jak se skript <code>2to3</code> spouští. Ukazuje také věci, které se automaticky neopraví. V této příloze najdete dokumentaci toho, co <em>dovede</em> opravit automaticky.

<h2 id=porting-code-to-python-3-with-2to3-print>Příkaz <code>print</code></h2>

<p>V Pythonu 2 byl <code><dfn>print</dfn></code> příkazem. Pokud jsme cokoliv chtěli vytisknout, jednoduše jsme to připsali za klíčové slovo <code>print</code>. V Pythonu 3 je <a href=#your-first-python-program-divingin><code>print()</code> funkcí</a>. Pokud chceme cokoliv vytisknout, předáme to funkci <code>print()</code> stejně jako každé jiné funkci.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>print</code>
<td><code class=pp>print()</code>
<tr><th>&#x2461;
<td><code class=pp>print 1</code>
<td><code class=pp>print(1)</code>
<tr><th>&#x2462;
<td><code class=pp>print 1, 2</code>
<td><code class=pp>print(1, 2)</code>
<tr><th>&#x2463;
<td><code class=pp>print 1, 2,</code>
<td><code class=pp>print(1, 2, end=' ')</code>
<tr><th>&#x2464;
<td><code class=pp>print >>sys.stderr, 1, 2, 3</code>
<td><code class=pp>print(1, 2, 3, file=sys.stderr)</code>
</table>

<ol>
<li>Prázdný řádek vytiskneme voláním <code>print()</code> bez zadání argumentů.
<li>Jednu hodnotu vytiskneme voláním <code>print()</code> s jedním argumentem.
<li>Dvě hodnoty oddělené mezerou vytiskneme voláním <code>print()</code> s dvěma argumenty.
<li>V tomhle je malá finta. Pokud jsme v Pythonu 2 ukončili příkaz <code>print</code> čárkou, vytiskly se hodnoty oddělené mezerou, pak se vytiskla ještě jedna koncová mezera a tisk skončil bez generování přechodu na nový řádek. (Z technického hlediska je to o něco komplikovanější. Příkaz <code>print</code> v Pythonu 2 používal nyní již nežádoucí (deprecated) atribut zvaný <var>softspace</var>. Místo skutečného tisku mezery nastavil Python 2 <code>sys.stdout.softspace</code> na 1. Znak mezery ve skutečnosti nebyl vytištěn, dokud se nemělo na stejný řádek tisknout něco dalšího. Pokud další příkaz <code>print</code> tiskl přechod na nový řádek, byl atribut <code>sys.stdout.softspace</code> nastaven na 0 a mezera se nikdy nevytiskla. Tohoto rozdílu byste si pravděpodobně nikdy nevšimli, pokud by vaše aplikace nebyla citlivá na přítomnost nebo nepřítomnost koncových bílých znaků ve výstupu, který byl vygenerován příkazem <code>print</code>.) V Pythonu 3 dosáhneme stejného efektu tím, že funkci <code>print()</code> předáme pojmenovaný argument s hodnotou <code>end=' '</code>. Výchozí hodnotou argumentu <code>end</code> je <code>'\n'</code> (přechod na nový řádek), takže po vytisknutí ostatních argumentů jeho přepsáním potlačíme přechod na nový řádek.
<li>V Pythonu 2 jsme mohli výstup přesměrovat do roury (pipe)&nbsp;&mdash;&nbsp;například na <code>sys.stderr</code>&nbsp;&mdash;&nbsp;uvedením zápisu <code>>>jméno_roury</code>. V Pythonu 3 dosáhneme stejného efektu předáním odkazu na rouru pojmenovaným argumentem <code>file</code>. Výchozí hodnotou argumentu <code>file</code> je <code>sys.stdout</code> (standardní výstup), takže přepsáním této hodnoty dosáhneme přesměrování do jiné roury.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-unicodeliteral>Literály Unicode-řetězců</h2>

<p>Python 2 pracoval s dvěma typy řetězců: s <dfn>Unicode</dfn> řetězci a s ne-Unicode řetězci. Python 3 podporuje jediný řetězcový typ: <a href=#strings-divingin>Unicode řetězce</a>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>u'PapayaWhip'</code>
<td><code class=pp>'PapayaWhip'</code>
<tr><th>&#x2461;
<td><code class=pp>ur'PapayaWhip\foo'</code>
<td><code class=pp>r'PapayaWhip\foo'</code>
</table>

<ol>
<li>Řetězcové literály s prefixem Unicode jsou jednoduše převedeny na obyčejné řetězcové literály, které v Pythonu 3 vždy vyjadřují Unicode řetězce.
<li>Surové Unicode řetězce (raw; ve kterých Python neprovádí interpretaci zpětného lomítka jako zahájení escape posloupnosti) jsou převedeny na surové řetězce. V Pythonu 3 jsou surové řetězce vždy v Unicode.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-unicode>Globální funkce <code>unicode()</code></h2>

<p>V Pythonu 2 se pro převod objektů na řetězec používaly dvě globální funkce: <code>unicode()</code> pro převod na Unicode řetězce a <code>str()</code> pro převod na ne-Unicode řetězce. Python 3 má jediný řetězcový typ, <a href=#strings-divingin>Unicode řetězce</a>, takže vše, co potřebujeme, je funkce <code>str()</code>. (Funkce <code>unicode()</code> už neexistuje.)

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>unicode(cokoliv)</code>
<td><code class=pp>str(cokoliv)</code>
</table>

<h2 id=porting-code-to-python-3-with-2to3-long>Datový typ <code>long</code></h2>

<p>Python 2 používal pro celá čísla dva datové typy: <code>int</code> a <code><dfn>long</dfn></code>. Hodnota typu <code>int</code> nemohla být větší než konstanta <a href=#porting-code-to-python-3-with-2to3-renames><code>sys.maxint</code></a>, která byla závislá na platformě. „Dlouhá“ čísla byla definována přidáním <code>L</code> na konec čísla a mohla nabývat větších hodnot než čísla typu <code>int</code>. V Pythonu 3 <a href=#native-datatypes-numbers>je jen jeden celočíselný typ</a>, který se jmenuje <code>int</code> a většinou se chová jako typ <code>long</code> v Pythonu 2. Protože už neexistují dva typy, nemusí se používat speciální syntaxe pro jejich rozlišení.
<p>Přečtěte si: <a href="http://www.python.org/dev/peps/pep-0237/"><abbr>PEP</abbr> 237: Unifying Long Integers and Integers</a>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>x = 1000000000000L</code>
<td><code class=pp>x = 1000000000000</code>
<tr><th>&#x2461;
<td><code class=pp>x = 0xFFFFFFFFFFFFL</code>
<td><code class=pp>x = 0xFFFFFFFFFFFF</code>
<tr><th>&#x2462;
<td><code class=pp>long(x)</code>
<td><code class=pp>int(x)</code>
<tr><th>&#x2463;
<td><code class=pp>type(x) is long</code>
<td><code class=pp>type(x) is int</code>
<tr><th>&#x2464;
<td><code class=pp>isinstance(x, long)</code>
<td><code class=pp>isinstance(x, int)</code>
</table>

<ol>
<li>Z desítkových číselných literálů pro „dlouhý“ integer (long) se staly desítkové literály pro typ integer.
<li>Z šestnáctkových číselných literálů pro „dlouhý“ integer (long) se staly šestnáctkové literály pro typ integer.
<li>V Pythonu 3 přestala existovat původní funkce <code>long()</code>, protože přestal existovat typ long (dlouhý integer). K převodu proměnné na celé číslo použijeme funkci <code>int()</code>.
<li>Pokud chceme zkontrolovat, zda je proměnná typu integer, zjistíme její typ a porovnáváme ho s <code>int</code> (nikoliv s <code>long</code>).
<li>Ke kontrole datového typu můžeme použít i funkci <code>isinstance()</code>. Při zjišťování, zda jde o celočíselný typ, se opět odkážeme na <code>int</code> a ne na <code>long</code>.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-ne>Porovnání &lt;></h2>

<p>Python 2 podporoval operátor <code>&lt;></code> jako synonymum pro <code>!=</code> (porovnání na různost). Python 3 podporuje pouze operátor <code>!=</code> a přestal podporovat <code>&lt;></code>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>if x &lt;> y:</code>
<td><code class=pp>if x != y:</code>
<tr><th>&#x2461;
<td><code class=pp>if x &lt;> y &lt;> z:</code>
<td><code class=pp>if x != y != z:</code>
</table>

<ol>
<li>Jednoduché porovnání.
<li>Složitější porovnání mezi třemi hodnotami.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-has_key>Slovníková metoda <code>has_key()</code></h2>

<p>V Pythonu 2 používaly slovníky metodu <code><dfn>has_key</dfn>()</code> (doslova „má klíč“) pro testování, zda se ve slovníku nachází zadaný klíč. V Pythonu 3 tato metoda přestala existovat. Místo ní musíme používat <a href=#native-datatypes-mixed-value-dictionaries>operátor <code>in</code></a>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>a_dictionary.has_key('PapayaWhip')</code>
<td><code class=pp>'PapayaWhip' in a_dictionary</code>
<tr><th>&#x2461;</th>
<td><code class=pp>a_dictionary.has_key(x) or a_dictionary.has_key(y)</code>
<td><code class=pp>x in a_dictionary or y in a_dictionary</code>
<tr><th>&#x2462;
<td><code class=pp>a_dictionary.has_key(x or y)</code>
<td><code class=pp>(x or y) in a_dictionary</code>
<tr><th>&#x2463;
<td><code class=pp>a_dictionary.has_key(x + y)</code>
<td><code class=pp>(x + y) in a_dictionary</code>
<tr><th>&#x2464;
<td><code class=pp>x + a_dictionary.has_key(y)</code>
<td><code class=pp>x + (y in a_dictionary)</code>
</table>

<ol>
<li>Nejjednodušší forma.
<li>Operátor <code>in</code> má vyšší prioritu než operátor <code>or</code>, takže podvýrazy <code>x in a_dictionary</code> a <code>y in a_dictionary</code> nemusíme uzavírat do závorek.
<li>Ale na druhou stranu zde ze stejného důvodu <em>musíme</em> uzavřít do závorek <code>x or y</code>&nbsp;&mdash;&nbsp;<code>in</code> má vyšší prioritu než <code>or</code>. (Poznámka: Tento kód se od předchozího řádku zcela liší. Python interpretuje nejdříve <code>x or y</code>. Výsledkem je buď <var>x</var> (pokud se <var>x</var> interpretuje <a href=#native-datatypes-booleans>v booleovském kontextu jako true</a>), nebo <var>y</var>. Potom pro výslednou hodnotu kontroluje, zda se ve slovníku <var>a_dictionary</var> vyskytuje jako klíč.)
<li>Operátor <code>+</code> má vyšší prioritu než operátor <code>in</code>. Z technického hlediska by tento zápis nemusel používat závorky kolem <code>x + y</code>, ale <code>2to3</code> je stejně přidává.
<li>U tohoto zápisu musí být kolem <code>y in a_dictionary</code> závorky určitě uvedeny, protože operátor <code>+</code> má vyšší prioritu než operátor <code>in</code>.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-dict>Slovníkové metody, které vracejí seznamy</h2>

<p>V Pythonu 2 mnohé slovníkové metody vracely seznamy. Mezi nejpoužívanější metody patřily <code><dfn>keys</dfn>()</code>, <code><dfn>items</dfn>()</code> a <code><dfn>values</dfn>()</code>. V Pythonu 3 všechny tyto metody vracejí dynamické <dfn>pohledy</dfn> (view). V některých situacích to nečiní žádný problém. Pokud je návratová hodnota těchto metod ihned předána jiné funkci, která iteruje přes celou posloupnost, bude jedno, zda je skutečným typem seznam nebo pohled (view). V jiném kontextu to ale může mít velký vliv. Pokud očekáváme kompletní seznam s jednotlivě adresovatelnými prvky, náš kód se zakucká, protože pohledy nepodporují indexování (tj. zpřístupňování prvku přes index).

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>a_dictionary.keys()</code>
<td><code class=pp>list(a_dictionary.keys())</code>
<tr><th>&#x2461;
<td><code class=pp>a_dictionary.items()</code>
<td><code class=pp>list(a_dictionary.items())</code>
<tr><th>&#x2462;
<td><code class=pp>a_dictionary.iterkeys()</code>
<td><code class=pp>iter(a_dictionary.keys())</code>
<tr><th>&#x2463;
<td><code class=pp>[i for i in a_dictionary.iterkeys()]</code>
<td><code class=pp>[i for i in a_dictionary.keys()]</code>
<tr><th>&#x2464;
<td><code class=pp>min(a_dictionary.keys())</code>
<td><i>žádná změna</i>
</table>

<ol>
<li>Skript <code>2to3</code> se přiklání k bezpečnému řešení. Voláním funkce <code>list()</code> převádí hodnotu vracenou metodou <code>keys()</code> na statický seznam. Bude to fungovat vždycky, ale někdy to bude méně efektivní než použití pohledu (view). Převedený kód byste si měli prohlédnout a zvážit, zda je statický seznam nezbytně nutný, nebo zda by nestačil pohled.
<li>Další konverze pohledu na seznam &mdash; tentokrát u metody <code>items()</code>. Stejnou věc provede <code>2to3</code> s metodou <code>values()</code>.
<li>Python 3 už nepodporuje metodu <code>iterkeys()</code>. Použijte <code>keys()</code>, a pokud je to nezbytné, udělejte z pohledu iterátor voláním funkce <code>iter()</code>.
<li><code>2to3</code> pozná, když je metoda <code>iterkeys()</code> použita uvnitř generátorové notace seznamu. Převede ji na metodu <code>keys()</code> (neobaluje ji ještě jedním voláním <code>iter()</code>). Funguje to, protože přes pohledy (view) lze iterovat.
<li><code>2to3</code> pozná případ, kdy je metoda <code>keys()</code> předána funkci, která iteruje celou posloupností. V takovém případě se návratová hodnota nemusí konvertovat na seznam. Funkce <code>min()</code> bude vesele iterovat i přes pohled. Týká se to funkcí <code>min()</code>, <code>max()</code>, <code>sum()</code>, <code>list()</code>, <code>tuple()</code>, <code>set()</code>, <code>sorted()</code>, <code>any()</code> a <code>all()</code>.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-imports>Moduly, které byly přejmenovány nebo reorganizovány</h2>

<p>Několik modulů standardní pythonovské knihovny bylo přejmenováno. Několik vzájemně souvisejících modulů bylo spojeno dohromady nebo bylo reorganizováno tak, aby byly jejich vztahy logičtější.

<h3 id=porting-code-to-python-3-with-2to3-http><code>http</code></h3>

<p>V Pythonu 3 bylo několik modulů souvisejících s <abbr>HTTP</abbr> spojeno do jednoho balíku nazvaného <code>http</code>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>import <dfn>httplib</dfn></code>
<td><code class=pp>import http.client</code>
<tr><th>&#x2461;
<td><code class=pp>import <dfn>Cookie</dfn></code>
<td><code class=pp>import http.cookies</code>
<tr><th>&#x2462;
<td><code class=pp>import <dfn>cookielib</dfn></code>
<td><code class=pp>import http.cookiejar</code>
<tr><th>&#x2463;
<td><pre class=pp><code>import <dfn>BaseHTTPServer</dfn>
import <dfn>SimpleHTTPServer</dfn>
import <dfn>CGIHttpServer</dfn></code></pre>
<td><code class=pp>import http.server</code>
</table>

<ol>
<li>Modul <code>http.client</code> implementuje nízkoúrovňovou knihovnu, která vytváří požadavky na <abbr>HTTP</abbr> zdroje a interpretuje související <abbr>HTTP</abbr> odpovědi.
<li>Modul <code>http.cookies</code> poskytuje pythonovské rozhraní pro cookies prohlížeče, které se posílají v <abbr>HTTP</abbr> hlavičce <abbr>HTTP</abbr> hlavička.
<li>Modul <code>http.cookiejar</code> manipuluje se soubory na disku, které oblíbené webové prohlížeče používají k ukládání cookies.
<li>Modul <code>http.server</code> implementuje jednoduchý <abbr>HTTP</abbr> server.
</ol>

<h3 id=porting-code-to-python-3-with-2to3-urllib><code>urllib</code></h3>

<p>Python 2 obsahoval změť překrývajících se modulů pro rozklad (parse) a kódování <abbr>URL</abbr> a pro získávání příslušného obsahu. V Pythonu 3 byly moduly refaktorizovány a sloučeny do jednoho balíku <code>urllib</code>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>import <dfn>urllib</dfn></code>
<td><code class=pp>import urllib.request, urllib.parse, urllib.error</code>
<tr><th>&#x2461;
<td><code class=pp>import <dfn>urllib2</dfn></code>
<td><code class=pp>import urllib.request, urllib.error</code>
<tr><th>&#x2462;
<td><code class=pp>import <dfn>urlparse</dfn></code>
<td><code class=pp>import urllib.parse</code>
<tr><th>&#x2463;
<td><code class=pp>import <dfn>robotparser</dfn></code>
<td><code class=pp>import urllib.robotparser</code>
<tr><th>&#x2464;
<td><pre class=pp><code>from urllib import <dfn>FancyURLopener</dfn>
from urllib import urlencode</code></pre>
<td><pre class=pp><code>from urllib.request import FancyURLopener
from urllib.parse import urlencode</code></pre>
<tr><th>&#x2465;
<td><pre class=pp><code>from urllib2 import <dfn>Request</dfn>
from urllib2 import <dfn>HTTPError</dfn></code></pre>
<td><pre class=pp><code>from urllib.request import Request
from urllib.error import HTTPError</code></pre>
</table>

<ol>
<li>Starý modul <code>urllib</code> v Pythonu 2 obsahoval řadu funkcí včetně <code>urlopen()</code> pro načítání dat a <code>splittype()</code>, <code>splithost()</code> a <code>splituser()</code> pro rozklad <abbr>URL</abbr> na podstatné části. Uvnitř nového balíku <code>urllib</code> byly tyto funkce logičtěji přeorganizovány. Skript <code>2to3</code> také změní všechna volání těchto funkcí, aby zohlednil nové schéma pojmenování.
<li>Původní modul <code>urllib2</code> z Pythonu 2 byl v Pythonu 3 vložen do balíčku <code>urllib</code>. Všechny oblíbené věci z <code>urllib2</code>&nbsp;&mdash;&nbsp;metoda <code>build_opener()</code>, třídy <code>Request</code> a <code>HTTPBasicAuthHandler</code> a související věci&nbsp;&mdash;&nbsp;jsou stále k dispozici.
<li>Modul <code>urllib.parse</code> z Pythonu 3 obsahuje všechny funkce z původního modulu <code>urlparse</code> z Pythonu 2.
<li>Modul <code>urllib.robotparser</code> zpracovává <a href="http://www.robotstxt.org/">soubory <code>robots.txt</code></a>.
<li>Třída <code>FancyURLopener</code>, která obsluhuje <abbr>HTTP</abbr> přesměrování a další stavové kódy, je v novém modulu <code>urllib.request</code> stále k dispozici. Funkce <code>urlencode()</code> se přesunula do <code>urllib.parse</code>.
<li>Třída <code>Request</code> je v <code>urllib.request</code> stále k dispozici, ale konstanty jako <code>HTTPError</code> byly přesunuty do <code>urllib.error</code>.
</ol>

<p>Zmínil jsem se o tom, že <code>2to3</code> přepíše také volání vašich funkcí? Pokud například v kódu pro Python 2 importujete modul <code>urllib</code> a získáváte data voláním <code>urllib.urlopen()</code>, skript <code>2to3</code> opraví jak příkaz import, tak volání funkce.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><pre class=pp><code>import urllib
print urllib.urlopen('http://diveintopython3.org/').read()</code></pre>
<td><pre class=pp><code>import urllib.request, urllib.parse, urllib.error
print(urllib.request.urlopen('http://diveintopython3.org/').read())</code></pre>
</table>

<h3 id=porting-code-to-python-3-with-2to3-dbm><code>dbm</code></h3>

<p>Všechny klony <abbr>DBM</abbr> se nyní nacházejí jediném balíku <code>dbm</code>. Pokud potřebujeme použít nějakou specifickou variantu, jako například <abbr>GNU</abbr> <abbr>DBM</abbr>, můžeme importovat příslušný modul z balíku <code>dbm</code>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>import <dfn>dbm</dfn></code>
<td><code class=pp>import dbm.ndbm</code>
<tr><th>
<td><code class=pp>import <dfn>gdbm</dfn></code>
<td><code class=pp>import dbm.gnu</code>
<tr><th>
<td><code class=pp>import <dfn>dbhash</dfn></code>
<td><code class=pp>import dbm.bsd</code>
<tr><th>
<td><code class=pp>import <dfn>dumbdbm</dfn></code>
<td><code class=pp>import dbm.dumb</code>
<tr><th>
<td><pre class=pp><code>import <dfn>anydbm</dfn>
import whichdb</code></pre>
<td><code class=pp>import dbm</code>
</table>

<h3 id=porting-code-to-python-3-with-2to3-xmlrpc><code>xmlrpc</code></h3>

<p><abbr>XML-RPC</abbr> je odlehčená (lightweight) metoda pro provádění <abbr>RPC</abbr> (vzdálené volání procedur) přes <abbr>HTTP</abbr>. Klientská knihovna pro <abbr>XML-RPC</abbr> a několik implementací <abbr>XML-RPC</abbr> serveru jsou nyní zkombinovány do jednoho balíčku <code>xmlrpc</code>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>import <dfn>xmlrpclib</dfn></code>
<td><code class=pp>import xmlrpc.client</code>
<tr><th>
<td><pre class=pp><code>import <dfn>DocXMLRPCServer</dfn>
import <dfn>SimpleXMLRPCServer</dfn></code></pre>
<td><code class=pp>import xmlrpc.server</code>
</table>

<h3 id=porting-code-to-python-3-with-2to3-othermodules>Ostatní moduly</h3>

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><pre class=pp><code>try:
    import <dfn>cStringIO</dfn> as <dfn>StringIO</dfn>
except ImportError:
    import StringIO</code></pre>
<td><code class=pp>import io</code>
<tr><th>&#x2461;
<td><pre class=pp><code>try:
    import cPickle as pickle
except ImportError:
    import pickle</code></pre>
<td><code class=pp>import pickle</code>
<tr><th>&#x2462;
<td><code class=pp>import <dfn>__builtin__</dfn></code>
<td><code class=pp>import builtins</code>
<tr><th>&#x2463;
<td><code class=pp>import <dfn>copy_reg</dfn></code>
<td><code class=pp>import copyreg</code>
<tr><th>&#x2464;
<td><code class=pp>import <dfn>Queue</dfn></code>
<td><code class=pp>import queue</code>
<tr><th>&#x2465;
<td><code class=pp>import <dfn>SocketServer</dfn></code>
<td><code class=pp>import socketserver</code>
<tr><th>&#x2466;
<td><code class=pp>import <dfn>ConfigParser</dfn></code>
<td><code class=pp>import configparser</code>
<tr><th>&#x2467;
<td><code class=pp>import repr</code>
<td><code class=pp>import reprlib</code>
<tr><th>&#x2468;
<td><code class=pp>import <dfn>commands</dfn></code>
<td><code class=pp>import subprocess</code>
</table>

<ol>
<li>Mezi běžné obraty v Pythonu 2 patřil pokus o <code>import cStringIO as StringIO</code>. Pokud operace selhala, provedl se místo toho příkaz <code>import StringIO</code>. V Pythonu 3 už to nedělejte. Modul <code>io</code> to udělá za vás. Nalezne nejrychlejší dostupnou implementaci a použije ji automaticky.
<li>Podobný obrat se používal pro importování nejrychlejší implementace pickle. V Pythonu 3 už to nedělejte. Modul <code>pickle</code> to udělá za vás.
<li>Modul <code>builtins</code> obsahuje globální funkce, třídy a konstanty, které se používají napříč celým jazykem Python. Redefinicí funkce v modulu <code>builtins</code> provedete redefinici globální funkce úplně všude. Je to přesně tak mocné a děsivé, jak to zní.
<li>Modul <code>copyreg</code> přidává podporu „piklení“ pro uživatelské typy definované v C.
<li>Modul <code>queue</code> implementuje frontu pro více producentů a více konzumentů.
<li>Modul <code>socketserver</code> poskytuje obecné (generické) bázové třídy pro implementaci různých druhů soketových serverů.
<li>Modul <code>configparser</code> zpracovává konfigurační soubory ve stylu <abbr>INI</abbr>.
<li>Modul <code>reprlib</code> reimplementuje zabudovanou funkci <code>repr()</code> s přidaným ovládáním. Lze předepsat, jak dlouhé mohou reprezentace být, než dojde k jejich ořezání.
<li>Modul <code>subprocess</code> umožňuje vytvářet procesy, připojovat se k jejich rourám (pipe) a získávat jejich návratové kódy.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-import>Relativní importy uvnitř balíčku</h2>

<p>Balíček je skupina souvisejících modulů, které se používají jako celek. Pokud se v Pythonu 2 moduly uvnitř balíčku potřebovaly odkazovat jeden na druhý, používali jsme příkaz <code>import foo</code> nebo <code>from foo import Bar</code>. V Pythonu 2 interpret hledal <code>foo.py</code> nejdříve uvnitř aktuálního balíčku a teprve potom prohledával ostatní adresáře z pythonovské vyhledávací cesty (<code>sys.path</code>). Python 3 funguje trošku jinak. Místo prohledávání aktuálního balíčku začne přímo pythonovskou vyhledávací cestou. Pokud chceme, aby jeden modul uvnitř balíčku importoval jiný modul ze stejného balíčku, musíme explicitně zadat relativní cestu mezi uvedenými moduly.
<p>Dejme tomu, že bychom měli následující balíček s více soubory ve stejném adresáři:
<pre>chardet/
|
+--__init__.py
|
+--constants.py
|
+--mbcharsetprober.py
|
+--universaldetector.py</pre>
<p>Teď předpokládejme, že <code>universaldetector.py</code> potřebuje importovat celý soubor <code>constants.py</code> a jednu třídu z <code>mbcharsetprober.py</code>. Jak to vlastně uděláme?

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>import constants</code>
<td><code class=pp>from . import constants</code>
<tr><th>&#x2461;
<td><code class=pp>from mbcharsetprober import MultiByteCharSetProber</code>
<td><code class=pp>from .mbcharsetprober import MultiByteCharsetProber</code>
</table>

<ol>
<li>Pokud potřebujeme importovat celý modul odněkud z našeho balíčku, použijeme novou syntaxi <code>from . import</code>. Tečka ve skutečnosti označuje relativní cestu od tohoto souboru (<code>universaldetector.py</code>) k souboru, který chceme importovat (<code>constants.py</code>). V tomto případě se nacházejí ve stejném adresáři, takže použijeme jednu tečku. Importovat můžeme i z rodičovského adresáře (<code>from .. import jinymodul</code>) nebo z podadresáře.
<li>Pokud chceme importovat určitou třídu nebo funkci z jiného modulu přímo do prostoru jmen našeho modulu, přidáme k cílovému modulu jako prefix relativní cestu bez koncového lomítka. V tomto případě se <code>mbcharsetprober.py</code> nachází ve stejném adresáři jako <code>universaldetector.py</code>, takže cestu vyjádříme jednou tečkou. Importovat můžeme i z rodičovského adresáře (<code>from ..jinymodul import JinaTrida</code>) nebo z podadresáře.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-next>Metoda iterátoru <code>next()</code></h2>

<p>V Pythonu 2 měly iterátory metodu <code><dfn>next</dfn>()</code>, která vracela další položku z posloupnosti. V Pythonu 3 to stále platí, ale máme k dispozici také <a href=#generators-generators>globální funkci <code>next()</code></a>, která přebírá iterátor jako argument.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>anIterator.next()</code>
<td><code class=pp>next(anIterator)</code>
<tr><th>&#x2461;
<td><code class=pp>funkce_ktera_vraci_iterator().next()</code>
<td><code class=pp>next(funkce_ktera_vraci_iterator())</code>
<tr><th>&#x2462;
<td><pre class=pp><code>class A:
    def next(self):
        pass</code></pre>
<td><pre class=pp><code>class A:
    def __next__(self):
        pass</code></pre>
<tr><th>&#x2463;
<td><pre class=pp><code>class A:
    def next(self, x, y):
        pass</code></pre>
<td><i>žádná změna</i>
<tr><th>&#x2464;
<td><pre class=pp><code>next = 42
for an_iterator in a_sequence_of_iterators:
    an_iterator.next()</code></pre>
<td><pre class=pp><code>next = 42
for an_iterator in a_sequence_of_iterators:
    an_iterator.__next__()</code></pre>
</table>

<ol>
<li>V nejjednodušším případě nyní místo volání metody iterátoru <code>next()</code> předáváme iterátor globální funkci <code>next()</code>.
<li>Pokud máme funkci, která vrací iterátor, zavoláme ji a výsledek předáme funkci <code>next()</code>. (Skript <code>2to3</code> je dost chytrý na to, aby to převedl správně.)
<li>Pokud definujeme svou vlastní třídu a míníme ji použít jako iterátor, definujeme speciální metodu <code>__next__()</code>.
<li>Pokud definujeme svou vlastní třídu a ta shodou okolností obsahuje metodu pojmenovanou <code>next()</code>, která přebírá jeden nebo víc argumentů, nechá ji skript <code>2to3</code> beze změny. Tato třída nemůže být použita jako iterátor, protože její metoda <code>next()</code> vyžaduje argumenty.
<li>Tohle je trošku ošemetné. Pokud máme lokální proměnnou pojmenovanou <var>next</var>, pak bude mít přednost před novou globální funkcí <code>next()</code>. V takovém případě budeme muset pro získání dalšího prvku posloupnosti volat speciální metodu iterátoru <code>__next__()</code>. (Alternativně bychom mohli refaktorizovat kód tak, že by lokální proměnná nebyla pojmenována <var>next</var>, ale to za nás <code>2to3</code> automaticky neudělá.)
</ol>

<h2 id=porting-code-to-python-3-with-2to3-filter>Globální funkce <code>filter()</code></h2>

<p>V Pythonu 2 vracela funkce <code><dfn>filter</dfn>()</code> seznam, který byl výsledkem filtrování posloupnosti přes funkci, která pro každý prvek posloupnosti vracela hodnotu <code>True</code> nebo <code>False</code>. V Pythonu 3 funkce <code>filter()</code> nevrací seznam, ale iterátor.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>filter(a_function, a_sequence)</code>
<td><code class=pp>list(filter(a_function, a_sequence))</code>
<tr><th>&#x2461;
<td><code class=pp>list(filter(a_function, a_sequence))</code>
<td><i>žádná změna</i>
<tr><th>&#x2462;
<td><code class=pp>filter(None, a_sequence)</code>
<td><code class=pp>[i for i in a_sequence if i]</code>
<tr><th>&#x2463;
<td><code class=pp>for i in filter(None, a_sequence):</code>
<td><i>žádná změna</i>
<tr><th>&#x2464;
<td><code class=pp>[i for i in filter(a_function, a_sequence)]</code>
<td><i>žádná změna</i>
</table>

<ol>
<li>V nejzákladnějším případě obalí skript <code>2to3</code> volání funkce <code>filter()</code> voláním funkce <code>list()</code>. Tím se provede průchod přes všechny hodnoty a vrátí se skutečný seznam.
<li>Pokud je ale volání funkce <code>filter()</code> <em>už obaleno</em> v <code>list()</code>, nebude <code>2to3</code> dělat nic, protože skutečnost, že <code>filter()</code> vrací iterátor v takovém případě není důležitá.
<li>Speciální syntaxi <code>filter(None, ...)</code> skript <code>2to3</code> nahradí použitím sémanticky shodné generátorové notace seznamu.
<li>V kontextu podobajícímu se cyklům <code>for</code>, kdy stejně dochází k průchodu celou posloupností, není nutné provádět žádné změny.
<li>Ani zde se nemusí dělat žádné změny, protože generátorová notace seznamu bude iterovat přes všechny prvky posloupnosti, a to může udělat, ať už <code>filter()</code> vrací iterátor nebo seznam.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-map>Globální funkce <code>map()</code></h2>

<p>Funkce <code><dfn>map</dfn>()</code> nyní vrací iterátor. Jde o stejný případ jako u funkce <a href=#porting-code-to-python-3-with-2to3-filter><code>filter()</code></a>. (V Pythonu 2 se vracel seznam.)

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>map(a_function, 'PapayaWhip')</code>
<td><code class=pp>list(map(a_function, 'PapayaWhip'))</code>
<tr><th>&#x2461;
<td><code class=pp>map(None, 'PapayaWhip')</code>
<td><code class=pp>list('PapayaWhip')</code>
<tr><th>&#x2462;
<td><code class=pp>map(lambda x: x+1, range(42))</code>
<td><code class=pp>[x+1 for x in range(42)]</code>
<tr><th>&#x2463;
<td><code class=pp>for i in map(a_function, a_sequence):</code>
<td><i>žádná změna</i>
<tr><th>&#x2464;
<td><code class=pp>[i for i in map(a_function, a_sequence)]</code>
<td><i>žádná změna</i>
</table>

<ol>
<li>Stejně jako u <code>filter()</code> v nejzákladnějším případě obalí skript <code>2to3</code> volání funkce <code>map()</code> voláním <code>list()</code>.
<li>Speciální syntaxi <code>map(None, ...)</code>, vyjadřující funkci identity, převede skript <code>2to3</code> na ekvivalentní volání <code>list()</code>.
<li>Pokud je prvním argumentem <code>map()</code> lambda funkce, převede <code>2to3</code> zápis s využitím odpovídající generátorové notace seznamu.
<li>V kontextu jako u cyklů <code>for</code>, které stejně procházejí celou posloupností, není nutné provádět žádné změny.
<li>Ani zde se nemusí dělat žádné změny, protože generátorová notace seznamu předepisuje průchod přes všechny prvky posloupnosti, a to může udělat, ať už <code>map()</code> vrací iterátor nebo seznam.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-reduce>Globální funkce <code>reduce()</code></h2>

<p>V Pythonu 3 byla funkce <code><dfn>reduce</dfn>()</code> vyňata z globálního prostoru jmen a umístěna do modulu <code>functools</code>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>reduce(a, b, c)</code>
<td><pre class=pp><code>from functools import reduce
reduce(a, b, c)</code></pre>
</table>

<h2 id=porting-code-to-python-3-with-2to3-apply>Globální funkce <code>apply()</code></h2>

<p>V Pythonu 2 existovala globální funkce <code><dfn>apply</dfn>()</code>, která přebírala funkci <var>f</var> a seznam <code>[a, b, c]</code> a vrátila <code>f(a, b, c)</code>. Stejné věci můžeme dosáhnout tím, že funkci zavoláme přímo a před předávaný seznam argumentů připíšeme hvězdičku. V Pythonu 3 již funkce <code>apply()</code> neexistuje. Musíme použít zápis s hvězdičkou.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>apply(a_function, a_list_of_args)</code>
<td><code class=pp>a_function(*a_list_of_args)</code>
<tr><th>&#x2461;
<td><code class=pp>apply(a_function, a_list_of_args, a_dictionary_of_named_args)</code>
<td><code class=pp>a_function(*a_list_of_args, **a_dictionary_of_named_args)</code>
<tr><th>&#x2462;
<td><code class=pp>apply(a_function, a_list_of_args + z)</code>
<td><code class=pp>a_function(*a_list_of_args + z)</code>
<tr><th>&#x2463;
<td><code class=pp>apply(aModule.a_function, a_list_of_args)</code>
<td><code class=pp>aModule.a_function(*a_list_of_args)</code>
</table>

<ol>
<li>V nejjednodušším případě můžeme funkci při volání předat seznam argumentů (skutečný seznam, jako například <code>[a, b, c]</code>) přidáním hvězdičky před seznam (<code>*</code>). Jde o přesný ekvivalent staré funkce <code>apply()</code> z Pythonu 2.
<li>V Pythonu 2 může funkce <code>apply()</code> ve skutečnosti přebírat tři parametry: funkci, seznam argumentů a slovník s pojmenovanými argumenty. V Pythonu 3 můžeme téhož dosáhnout přidáním hvězdičky před seznam argumentů (<code>*</code>) a přidáním dvou hvězdiček před slovník pojmenovaných argumentů (<code>**</code>).
<li>Zde se operátor + používá pro zřetězení seznamů. Operátor <code>+</code> má vyšší prioritu než operátor <code>*</code>, takže kolem <code>a_list_of_args + z</code> nemusíme přidávat závorky.
<li>Skript <code>2to3</code> je dost chytrý na to, aby převedl i složitá volání <code>apply()</code>, včetně volání funkcí z importovaných modulů.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-intern>Globální funkce <code>intern()</code></h2>

<p>V Pythonu 2 bylo možné „internovat“ řetězec voláním funkce <code><dfn>intern</dfn>()</code>, čímž došlo k optimalizaci výkonu při práci s tímto řetězcem. V Pythonu 3 byla funkce <code>intern()</code> přesunuta do modulu <code>sys</code>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>intern(aString)</code>
<td><code class=pp>sys.intern(aString)</code>
</table>

<h2 id=porting-code-to-python-3-with-2to3-exec>Příkaz <code>exec</code></h2>

<p>Příkaz <code><dfn>exec</dfn></code> se v Pythonu 3 změnil na funkci stejně, jako se na funkci změnil <a href=#porting-code-to-python-3-with-2to3-print>příkaz <code>print</code></a>. Funkce <code>exec()</code> přebírá řetězec, který obsahuje libovolný pythonovský kód, a provede jej, jako kdyby to byl nějaký příkaz nebo výraz. Funkce <code>exec()</code> se podobá <a href=#advanced-iterators-eval><code>eval()</code></a>, ale je ještě mocnější a zlověstnější. Funkce <code>eval()</code> může vyhodnocovat jediný výraz, ale funkce <code>exec()</code> může provést více příkazů, importů, deklarací funkcí&nbsp;&mdash;&nbsp;v podstatě celý pythonovský program, předaný jako řetězec.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>exec codeString</code>
<td><code class=pp>exec(codeString)</code>
<tr><th>&#x2461;
<td><code class=pp>exec codeString in a_global_namespace</code>
<td><code class=pp>exec(codeString, a_global_namespace)</code>
<tr><th>&#x2462;
<td><code class=pp>exec codeString in a_global_namespace, a_local_namespace</code>
<td><code class=pp>exec(codeString, a_global_namespace, a_local_namespace)</code>
</table>

<ol>
<li>V nejjednodušším případě skript <code>2to3</code> prostě uzavře kód v podobě řetězce do závorek, protože <code>exec()</code> je teď funkce a ne příkaz.
<li>Původní příkaz <code>exec</code> mohl přebírat prostor jmen v podobě soukromého prostředí s globálními jmény, ve kterém se měl kód v podobě řetězce provádět. V Pythonu 3 lze dělat totéž. Prostor jmen se funkci <code>exec()</code> jednoduše předá jako druhý parametr.
<li>Původní příkaz <code>exec</code> umožňoval dokonce přebírat lokální prostor jmen (podobající se prostoru proměnných definovaných uvnitř nějaké funkce). V Pythonu 3 to funkce <code>exec()</code> dokáže také.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-execfile>Příkaz <code>execfile</code></h2>

<p>Původní příkaz <code>execfile</code>, podobně jako původní <a href=#porting-code-to-python-3-with-2to3-exec>příkaz <code>exec</code></a>, spouštěl řetězce, ve kterých byl uložen pythonovský kód. Tam, kde <code>exec</code> přebíral řetězec, <code>execfile</code> přebíral jméno souboru. Z Pythonu 3 byl příkaz <code>execfile</code> vyřazen. Pokud opravdu chcete použít soubor s pythonovským kódem a spustit jej (ale nechcete jej přitom jednoduše importovat), můžete stejné funkčnosti dosáhnout otevřením souboru, načtením jeho obsahu, zavoláním globální funkce <code>compile()</code> (aby byl pythonovský interpret donucen kód přeložit) a nakonec zavoláním nové funkce <code>exec()</code>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp><dfn>execfile</dfn>('a_filename')</code>
<td><code class=pp>exec(compile(open('a_filename').read(), 'a_filename', 'exec'))</code>
</table>

<h2 id=porting-code-to-python-3-with-2to3-repr><code>repr</code>-literály (zpětné apostrofy)</h2>

<p>V Pythonu 2 bylo možné získat reprezentaci objektu použitím speciální syntaxe, kdy se libovolný objekt obalil <dfn>zpětnými apostrofy</dfn> (backticks; jako například <code>`x`</code>). V Pythonu 3 tato schopnost stále existuje, ale už ji nemůžeme vyvolat použitím zpětných apostrofů. Místo nich musíme použít globální funkci <code>repr()</code>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>`x`</code>
<td><code class=pp>repr(x)</code>
<tr><th>&#x2461;
<td><code class=pp>`'PapayaWhip' + `2``</code>
<td><code class=pp>repr('PapayaWhip' + repr(2))</code>
</table>

<ol>
<li>Připomeňme si, že <var>x</var> může být cokoliv&nbsp;&mdash;&nbsp;třída, funkce, modul, primitivní datový typ atd. Funkce <code>repr()</code> funguje na všechno.
<li>V Pythonu 2 mohly být zpětné apostrofy zanořeny, což vedlo k tomuto druhu matoucích (ale platných) výrazů. Skript <code>2to3</code> je dost chytrý na to, aby zápis převedl na zanořené volání <code>repr()</code>.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-except>Příkaz <code>try...except</code></h2>

<p>Syntaxe pro <a href=#your-first-python-program-exceptions>odchytávání <dfn>výjimek</dfn></a> se mezi verzemi Python 2 a Python 3 mírně změnila.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><pre class=pp><code>try:
    import mymodule
<dfn>except</dfn> ImportError, e
    pass</code></pre>
<td><pre class=pp><code>try:
    import mymodule
except ImportError as e:
    pass</code></pre>
<tr><th>&#x2461;
<td><pre class=pp><code>try:
    import mymodule
except (RuntimeError, ImportError), e
    pass</code></pre>
<td><pre class=pp><code>try:
    import mymodule
except (RuntimeError, ImportError) as e:
    pass</code></pre>
<tr><th>&#x2462;
<td><pre class=pp><code>try:
    import mymodule
except ImportError:
    pass</code></pre>
<td><i>žádná změna</i>
<tr><th>&#x2463;
<td><pre class=pp><code>try:
    import mymodule
except:
    pass</code></pre>
<td><i>žádná změna</i>
</table>

<ol>
<li>Místo čárky se za typem výjimky v Pythonu 3 používá nové klíčové slovo <code>as</code>.
<li>Klíčové slovo <code>as</code> funguje i pro odchytávání více typů výjimek najednou.
<li>Pokud výjimku jen odchytíme, ale ve skutečnosti nás nezajímá možnost přistupování k samotnému <dfn>objektu</dfn> výjimky, pak se syntaxe používaná v Pythonu 2 shoduje se syntaxí v Pythonu 3.
<li>Podobně, pokud používáme záchranu v podobě odchytávání <em>všech</em> výjimek, je syntaxe identická.
</ol>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Nouzové odchytávání <em>všech</em> výjimek byste nikdy neměli používat při importování modulů (ani ve většině ostatních případů). Tímto způsobem odchytíte i věci jako <code>KeyboardInterrupt</code> (pokud se uživatel pokoušel o přerušení činnosti programu stiskem <kbd>Ctrl-C</kbd>) a ztížíte si tím ladění.
</blockquote>

<h2 id=porting-code-to-python-3-with-2to3-raise>Příkaz <code>raise</code></h2>

<p>Syntaxe pro <a href=#your-first-python-program-exceptions>vyvolávání našich vlastních výjimek</a> se mezi verzemi Python 2 a Python 3 mírně změnila.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp><dfn>raise</dfn> MyException</code>
<td><i>žádná změna</i>
<tr><th>&#x2461;
<td><code class=pp>raise MyException, 'error message'</code>
<td><code class=pp>raise MyException('error message')</code>
<tr><th>&#x2462;
<td><code class=pp>raise MyException, 'error message', a_traceback</code>
<td><code class=pp>raise MyException('error message').with_traceback(a_traceback)</code>
<tr><th>&#x2463;
<td><code class=pp>raise 'error message'</code>
<td><i>nepodporováno</i>
</table>

<ol>
<li>Při použití nejjednodušší formy, vyvolání výjimky bez uživatelské chybové zprávy, se syntaxe nezměnila.
<li>Změny si povšimneme, když chceme vyvolat výjimku s uživatelským chybovým hlášením. Python 2 odděloval třídu výjimky a uživatelskou zprávu čárkou. Python 3 předává chybovou zprávu jako parametr.
<li>Python 2 podporoval při složitější syntaxi vyvolání výjimky s uživatelským zpětným trasováním (stack trace). V Pythonu 3 toho můžeme dosáhnout také, ale syntaxe se docela liší.
<li>V Pythonu 2 jsme mohli vyvolat výjimku, aniž jsme zadávali třídu výjimky. Stačilo zadat chybovou zprávu. V Pythonu 3 to již není možné. Skript <code>2to3</code> vás bude varovat, že nebyl schopen tuto situaci opravit automaticky.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-throw>Metoda generátorů <code>throw</code></h2>

<p>V Pythonu 2 definovaly generátory metodu <code><dfn>throw</dfn>()</code>. Volání <code>a_generator.throw()</code> vyvolá výjimku v místě, kde se generátor zastavil. Potom se vrací další hodnota, která je vyprodukována (yield) generátorovou funkcí. V Pythonu 3 je uvedená funkčnost stále k dispozici, ale syntaxe se trochu změnila.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>a_generator.throw(MyException)</code>
<td><i>žádná změna</i>
<tr><th>&#x2461;
<td><code class=pp>a_generator.throw(MyException, 'error message')</code>
<td><code class=pp>a_generator.throw(MyException('error message'))</code>
<tr><th>&#x2462;
<td><code class=pp>a_generator.throw('error message')</code>
<td><i>nepodporováno</i>
</table>

<ol>
<li>V nejjednodušším případě generátor vyvolává výjimku bez uživatelské chybové zprávy. V tomto případě se syntaxe v Pythonu 3 vůči Pythonu 2 nezměnila.
<li>Pokud generátor vyvolává výjimku <em>s uživatelskou chybovou zprávou</em>, musíme řetězec se zprávou předat vytvářenému objektu výjimky.
<li>Python 2 podporoval vyvolání výjimky, která byla tvořena <em>pouze</em> uživatelským chybovým hlášením. Python 3 toto chování nepodporuje a skript <code>2to3</code> zobrazí varování, které říká, že to budete muset opravit ručně.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-xrange>Globální funkce <code>xrange()</code></h2>

<p>V Pythonu 2 existovaly dva způsoby získávání hodnot intervalu čísel: funkce <code><dfn>range</dfn>()</code> vracela seznam a funkce <code><dfn>xrange</dfn>()</code>, vracela iterátor. V Pythonu 3 funkce <code>range()</code> vrací iterátor a funkce <code>xrange()</code> už neexistuje.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>xrange(10)</code>
<td><code class=pp>range(10)</code>
<tr><th>&#x2461;
<td><code class=pp>a_list = range(10)</code>
<td><code class=pp>a_list = list(range(10))</code>
<tr><th>&#x2462;
<td><code class=pp>[i for i in xrange(10)]</code>
<td><code class=pp>[i for i in range(10)]</code>
<tr><th>&#x2463;
<td><code class=pp>for i in range(10):</code>
<td><i>žádná změna</i>
<tr><th>&#x2464;
<td><code class=pp>sum(range(10))</code>
<td><i>žádná změna</i>
</table>

<ol>
<li>V nejjednodušším případě skript <code>2to3</code> jednoduše změní <code>xrange()</code> na <code>range()</code>.
<li>Pokud kód pro Python 2 používal <code>range()</code>, pak skript <code>2to3</code> neví, zda jsme skutečně potřebovali seznam, nebo zda by vyhověl iterátor. V rámci opatrnosti se vracená hodnota převádí na seznam voláním funkce <code>list()</code>.
<li>Pokud by byla funkce <code>xrange()</code> použita uvnitř generátorového zápisu seznamu, pak je skript <code>2to3</code> dost chytrý na to, aby funkci <code>range()</code> <em>neobalil</em> voláním <code>list()</code>. Generátorový zápis seznamu bude bez problémů fungovat s iterátorem, který je funkcí <code>range()</code> vrácen.
<li>Bez problémů bude s iterátorem fungovat i cyklus <code>for</code>, takže ani zde není nutné nic měnit.
<li>Funkce <code>sum()</code> pracuje s iterátorem také, takže <code>2to3</code> nemusí nic měnit ani zde. Uvedený přístup se, stejně jako v případě <a href=#porting-code-to-python-3-with-2to3-dict>metod slovníku, které vracejí pohledy (view) místo seznamů</a>, aplikuje i u funkcí <code>min()</code>, <code>max()</code>, <code>sum()</code>, <code>list()</code>, <code>tuple()</code>, <code>set()</code>, <code>sorted()</code>, <code>any()</code> a <code>all()</code>.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-raw_input>Globální funkce <code>raw_input()</code> a <code>input()</code></h2>

<p>Python 2 poskytoval pro vyžádání si uživatelského vstupu z příkazové řádky dvě globální funkce. První z nich, zvaná <code>input()</code>, očekávala, že uživatel vloží pythonovský výraz (vrací se jeho výsledek). Druhá z nich, zvaná <code><dfn>raw_input</dfn>()</code>, vracela to, co uživatel napsal. Začátečníky to velmi mátlo a považovalo se to za „bradavici“ (wart) na jazyce. Python 3 tuto nepěknost řeší přejmenováním <code>raw_input()</code> na <code>input()</code>, takže to funguje způsobem, který většina naivně očekává.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>raw_input()</code>
<td><code class=pp>input()</code>
<tr><th>&#x2461;
<td><code class=pp>raw_input('prompt')</code>
<td><code class=pp>input('prompt')</code>
<tr><th>&#x2462;
<td><code class=pp>input()</code>
<td><code class=pp>eval(input())</code>
</table>

<ol>
<li>V nejjednodušším případě se <code>raw_input()</code> mění na <code>input()</code>.
<li>V Pythonu 2 mohla funkce <code>raw_input()</code> přebírat vyzývací řetězec jako parametr. Tato možnost je zachována i v Pythonu 3.
<li>Pokud chcete, aby se opravdu vyhodnocoval pythonovský výraz zadaný uživatelem, použijte funkci <code>input()</code> a předejte její výsledek funkci <code>eval()</code>.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-funcattrs>Atributy funkcí <code>func_*</code></h2>

<p>V Pythonu 2 může kód uvnitř funkce přistupovat ke speciálním atributům, které se týkají funkce samotné. V Pythonu 3 byly tyto speciální atributy funkcí přejmenovány, aby se dostaly do souladu s ostatními atributy.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>a_function.<dfn>func_name</dfn></code>
<td><code class=pp>a_function.__name__</code>
<tr><th>&#x2461;
<td><code class=pp>a_function.<dfn>func_doc</dfn></code>
<td><code class=pp>a_function.__doc__</code>
<tr><th>&#x2462;
<td><code class=pp>a_function.<dfn>func_defaults</dfn></code>
<td><code class=pp>a_function.__defaults__</code>
<tr><th>&#x2463;
<td><code class=pp>a_function.<dfn>func_dict</dfn></code>
<td><code class=pp>a_function.__dict__</code>
<tr><th>&#x2464;
<td><code class=pp>a_function.<dfn>func_closure</dfn></code>
<td><code class=pp>a_function.__closure__</code>
<tr><th>&#x2465;
<td><code class=pp>a_function.<dfn>func_globals</dfn></code>
<td><code class=pp>a_function.__globals__</code>
<tr><th>&#x2466;
<td><code class=pp>a_function.<dfn>func_code</dfn></code>
<td><code class=pp>a_function.__code__</code>
</table>

<ol>
<li>Atribut <code>__name__</code> (dříve <code>func_name</code>) obsahuje jméno funkce.
<li>Atribut <code>__doc__</code> (dříve <code>func_doc</code>) obsahuje <i>dokumentační řetězec</i>, který byl definován ve zdrojovém textu funkce.
<li>Atribut <code>__defaults__</code> (dříve <code>func_defaults</code>) je n-tice obsahující výchozí hodnoty argumentů pro ty z argumentů, pro které byly výchozí hodnoty definovány.
<li>Atribut <code>__dict__</code> (dříve <code>func_dict</code>) je prostor jmen uchovávající libovolné atributy funkce.
<li>Atribut <code>__closure__</code> (dříve <code>func_closure</code>) je n-tice buněk, které obsahují vazby (bindings) na volné proměnné, které se ve funkci používají.
<li>Atribut <code>__globals__</code> (dříve <code>func_globals</code>) je odkaz na globální prostor jmen modulu, ve kterém byla funkce definována.
<li>Atribut <code>__code__</code> (dříve <code>func_code</code>) je objekt kódu (code object), reprezentující přeložené tělo funkce.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-xreadlines>Metoda <code>xreadlines()</code> V/V objektů</h2>

<p>V Pythonu 2 měly souborové objekty metodu <code><dfn>xreadlines</dfn>()</code>, která vracela iterátor procházející souborem po řádcích. Kromě jiného se to hodilo pro cykly <code>for</code>. Ve skutečnosti to byla tak užitečná metoda, že pozdější verze Pythonu 2 přidaly schopnost iterovat samotným souborovým objektům.

<p>V Pythonu 3 přestala metoda <code>xreadlines()</code> existovat. Skript <code>2to3</code> je schopen převést jednoduché případy, ale v hraničních situacích po vás bude vyžadovat ruční zásah.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>for line in a_file.xreadlines():</code>
<td><code class=pp>for line in a_file:</code>
<tr><th>&#x2461;
<td><code class=pp>for line in a_file.xreadlines(5):</code>
<td><i>žádná změna (vede k nefunkčnímu kódu)</i>
</table>

<ol>
<li>Pokud jste byli zvyklí volat <code>xreadlines()</code> bez argumentů, převede toto volání skript <code>2to3</code> jen na souborový objekt. V Pythonu 3 zajistí tento zápis stejnou funkčnost: čte se ze souboru řádek po řádku a provádí se tělo cyklu <code>for</code>.
<li>Pokud jste byli zvyklí volat <code>xreadlines()</code> s argumentem (počet řádků, které se mají načíst najednou), pak to skript <code>2to3</code> neopraví a váš kód selže s vysvětlením <code>AttributeError: '_io.TextIOWrapper' object has no attribute 'xreadlines'</code>. Opravu pro Python 3 můžete ručně provést změnou <code>xreadlines()</code> na <code>readlines()</code>. (Metoda <code>readlines()</code> teď vrací iterátor, takže je to stejně efektivní, jako bylo <code>xreadlines()</code> v Pythonu 2.)
</ol>

<p class=c><span style='font-size:56px;line-height:0.88'>&#x2603;</span>

<h2 id=porting-code-to-python-3-with-2to3-tuple_params><code>lambda</code> funkce, které akceptují n-tici místo více parametrů</h2>

<p>V Pythonu 2 jsme mohli definovat anonymní <code><dfn>lambda</dfn></code> funkci, která přebírá více parametrů, tím, že jsme ji definovali jako funkci, která přebírá n-tici s určeným počtem položek. V důsledku toho Python 2 „rozbalil“ n-tici do pojmenovaných argumentů, na které jsme se pak mohli uvnitř <code>lambda</code> funkce odkazovat jménem. V Pythonu 3 můžeme <code>lambda</code> funkci také předávat n-tici, ale pythonovský interpret ji nerozbalí do pojmenovaných argumentů. Místo toho se budeme muset na jednotlivé argumenty odkazovat pozičním indexem.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>lambda (x,): x + f(x)</code>
<td><code class=pp>lambda x1: x1[0] + f(x1[0])</code>
<tr><th>&#x2461;
<td><code class=pp>lambda (x, y): x + f(y)</code>
<td><code class=pp>lambda x_y: x_y[0] + f(x_y[1])</code>
<tr><th>&#x2462;
<td><code class=pp>lambda (x, (y, z)): x + y + z</code>
<td><code class=pp>lambda x_y_z: x_y_z[0] + x_y_z[1][0] + x_y_z[1][1]</code>
<tr><th>&#x2463;
<td><code class=pp>lambda x, y, z: x + y + z</code>
<td><i>žádná změna</i>
</table>

<ol>
<li>Pokud jsme definovali <code>lambda</code> funkci, která přebírá n-tici s jedním prvkem, stane se z ní v Pythonu 3 <code>lambda</code> funkce, která se odkazuje na <var>x1[0]</var>. Jméno <var>x1</var> je generováno skriptem <code>2to3</code> automaticky, na základě pojmenovaných argumentů původní n-tice.
<li><code>lambda</code> funkce s dvouprvkovou n-ticí <var>(x, y)</var> bude převedena na <var>x_y</var> s pozičními argumenty <var>x_y[0]</var> a <var>x_y[1]</var>.
<li>Skript <code>2to3</code> zvládne dokonce <code>lambda</code> funkce s vnořenými n-ticemi pojmenovaných argumentů. Výsledný kód v Pythonu 3 je poněkud nečitelný, ale funguje stejným způsobem, jakým fungoval původní kód v Pythonu 2.
<li>Můžeme definovat <code>lambda</code> funkce, které přebírají víc argumentů. Pokud kolem argumentů neuvedeme závorky, chová se Python 2 k zápisu jako k <code>lambda</code> funkci s více argumenty. Uvnitř <code>lambda</code> funkce se na pojmenované argumenty odkazujeme jménem jako v každé jiné funkci. V Pythonu 3 tato syntaxe pořád funguje.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-methodattrs>Atributy speciálních metod</h2>

<p>V Pythonu 2 se mohly metody tříd odkazovat na objekt třídy, ve které jsou definovány, a také na samotný objekt metody. Reference <code>im_self</code> odkazovala na objekt instance třídy, <code>im_func</code> na objekt funkce a <code>im_class</code> se odkazuje na třídu objektu <code>im_self</code>. V Pythonu 3 byly tyto speciální atributy metod přejmenovány, aby se dostaly do souladu s pojmenováním ostatních atributů.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>aClassInstance.aClassMethod.<dfn>im_func</dfn></code>
<td><code class=pp>aClassInstance.aClassMethod.__func__</code>
<tr><th>
<td><code class=pp>aClassInstance.aClassMethod.<dfn>im_self</dfn></code>
<td><code class=pp>aClassInstance.aClassMethod.__self__</code>
<tr><th>
<td><code class=pp>aClassInstance.aClassMethod.<dfn>im_class</dfn></code>
<td><code class=pp>aClassInstance.aClassMethod.__self__.__class__</code>
</table>

<h2 id=porting-code-to-python-3-with-2to3-nonzero>Speciální metoda <code>__nonzero__</code></h2>

<p>V Pythonu 2 jsme mohli vytvářet své vlastní třídy, které se daly používat v booleovském kontextu. Mohli jsme například vytvořit instanci takové třídy a pak ji použít v příkazu <code>if</code>. Dělalo se to tak, že jsme definovali speciální metodu <code>__nonzero__()</code>, která vracela <code>True</code> nebo <code>False</code>. Ta se volala, kdykoliv byla instance použita v booleovském kontextu. V Pythonu 3 lze dělat totéž, ale jméno metody bylo změněno na <code>__bool__()</code>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><pre class=pp><code>class A:
    def <dfn>__nonzero__</dfn>(self):
        pass</code></pre>
<td><pre class=pp><code>class A:
    def <dfn>__bool__</dfn>(self):
        pass</code></pre>
<tr><th>&#x2461;
<td><pre class=pp><code>class A:
    def __nonzero__(self, x, y):
        pass</code></pre>
<td><i>žádná změna</i>
</table>

<ol>
<li>Při vyhodnocování instance v booleovském kontextu se v Pythonu 3 místo <code>__nonzero__()</code> volá metoda <code>__bool__()</code>.
<li>Pokud ale máme definovánu metodu <code>__nonzero__()</code>, která vyžaduje nějaké argumenty, bude nástroj <code>2to3</code> předpokládat, že jsme ji používali pro nějaký jiný účel, a neprovede žádné změny.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-numliterals>Oktalové literály</h2>

<p>Syntaxe pro zápis čísel v osmičkové soustavě (tj. <dfn>oktalových</dfn>) se mezi Pythonem 2 a Pythonem 3 mírně změnila.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>x = 0755</code>
<td><code class=pp>x = 0o755</code>
</table>

<h2 id=porting-code-to-python-3-with-2to3-renames><code>sys.maxint</code></h2>

<p>V souvislosti <a href=#porting-code-to-python-3-with-2to3-long>se sloučením typů <code>long</code> a <code>int</code></a> pozbyla konstanta <code>sys.maxint</code> vypovídací přesnost. Tato hodnota může být stále užitečná při zjišťování schopností závislých na platformě. Proto byla v Pythonu ponechána, ale byla přejmenována na <code>sys.maxsize</code>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>from sys import <dfn>maxint</dfn></code>
<td><code class=pp>from sys import <dfn>maxsize</dfn></code>
<tr><th>&#x2461;
<td><code class=pp>a_function(<dfn>sys.maxint</dfn>)</code>
<td><code class=pp>a_function(<dfn>sys.maxsize</dfn>)</code>
</table>

<ol>
<li>Z <code>maxint</code> se stává <code>maxsize</code>.
<li>Jakékoliv použití <code>sys.maxint</code> se mění na <code>sys.maxsize</code>.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-callable>Globální funkce <code>callable()</code></h2>

<p>V Pythonu 2 jsme mohli voláním globální funkce <code><dfn>callable</dfn>()</code> zkontrolovat, zda se dá objekt volat (jako funkce). Z Pythonu 3 byla tato globální funkce vyřazena. Pokud chceme zjistit, zda se dá objekt volat, musíme zkontrolovat, zda má speciální metodu <code>__call__()</code>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>callable(anything)</code>
<td><code class=pp>hasattr(anything, '__call__')</code>
</table>

<h2 id=porting-code-to-python-3-with-2to3-zip>Globální funkce <code>zip()</code></h2>

<p>V Pythonu 2 přebírala globální funkce <code><dfn>zip</dfn>()</code> libovolný počet posloupností a vracela seznam n-tic. První n-tice obsahovala první položky ze všech posloupností, druhá n-tice obsahovala druhé položky ze všech posloupností a tak dále. V Pythonu 3 vrací funkce <code>zip()</code> místo seznamu iterátor.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>zip(a, b, c)</code>
<td><code class=pp>list(zip(a, b, c))</code>
<tr><th>&#x2461;
<td><code class=pp>d.join(zip(a, b, c))</code>
<td><i>žádná změna</i>
</table>

<ol>
<li>Nejjednodušší způsob dosažení původního chování funkce <code>zip()</code> spočívá v obalení návratové hodnoty voláním <code>list()</code>. Tím dojde k průchodu všemi hodnotami iterátoru vraceného funkcí <code>zip()</code> a vytvoří se skutečný seznam výsledků.
<li>V kontextu, kde se již využívá iterace přes všechny položky posloupnosti (jako například při volání této metody <code>join()</code>), funguje iterátor vracený funkcí <code>zip()</code> bez problémů. Skript <code>2to3</code> je dost chytrý na to, aby takové případy detekoval a neprováděl ve vašem kódu žádné změny.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-standarderror>Výjimka <code>StandardError</code></h2>

<p>V Pythonu 2 byla <code><dfn>StandardError</dfn></code> bázovou třídou všech zabudovaných výjimek &mdash; až na <code>StopIteration</code>, <code>GeneratorExit</code>, <code>KeyboardInterrupt</code> a <code>SystemExit</code>. V Pythonu 3 byla třída <code>StandardError</code> zrušena. Místo ní se používá třída <code>Exception</code>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>x = StandardError()</code>
<td><code class=pp>x = Exception()</code>
<tr><th>
<td><code class=pp>x = StandardError(a, b, c)</code>
<td><code class=pp>x = Exception(a, b, c)</code>
</table>

<h2 id=porting-code-to-python-3-with-2to3-types>Konstanty modulu <code>types</code></h2>

<p>Modul <code>types</code> obsahuje širokou paletu konstant, které nám pomáhají určovat typ objektu. V Pythonu 2 obsahoval konstanty pro všechny primitivní typy, jako jsou <code>dict</code> a <code>int</code>. Z Pythonu 3 byly tyto konstanty odstraněny. Místo nich se používá jméno primitivního typu.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>types.<dfn>UnicodeType</dfn></code>
<td><code class=pp>str</code>
<tr><th>
<td><code class=pp>types.<dfn>StringType</dfn></code>
<td><code class=pp>bytes</code>
<tr><th>
<td><code class=pp>types.<dfn>DictType</dfn></code>
<td><code class=pp>dict</code>
<tr><th>
<td><code class=pp>types.<dfn>IntType</dfn></code>
<td><code class=pp>int</code>
<tr><th>
<td><code class=pp>types.<dfn>LongType</dfn></code>
<td><code class=pp>int</code>
<tr><th>
<td><code class=pp>types.<dfn>ListType</dfn></code>
<td><code class=pp>list</code>
<tr><th>
<td><code class=pp>types.<dfn>NoneType</dfn></code>
<td><code class=pp>type(None)</code>
<tr><th>
<td><code class=pp>types.<dfn>BooleanType</dfn></code>
<td><code class=pp>bool</code>
<tr><th>
<td><code class=pp>types.<dfn>BufferType</dfn></code>
<td><code class=pp>memoryview</code>
<tr><th>
<td><code class=pp>types.<dfn>ClassType</dfn></code>
<td><code class=pp>type</code>
<tr><th>
<td><code class=pp>types.<dfn>ComplexType</dfn></code>
<td><code class=pp>complex</code>
<tr><th>
<td><code class=pp>types.<dfn>EllipsisType</dfn></code>
<td><code class=pp>type(Ellipsis)</code>
<tr><th>
<td><code class=pp>types.<dfn>FloatType</dfn></code>
<td><code class=pp>float</code>
<tr><th>
<td><code class=pp>types.<dfn>ObjectType</dfn></code>
<td><code class=pp>object</code>
<tr><th>
<td><code class=pp>types.<dfn>NotImplementedType</dfn></code>
<td><code class=pp>type(NotImplemented)</code>
<tr><th>
<td><code class=pp>types.<dfn>SliceType</dfn></code>
<td><code class=pp>slice</code>
<tr><th>
<td><code class=pp>types.<dfn>TupleType</dfn></code>
<td><code class=pp>tuple</code>
<tr><th>
<td><code class=pp>types.<dfn>TypeType</dfn></code>
<td><code class=pp>type</code>
<tr><th>
<td><code class=pp>types.<dfn>XRangeType</dfn></code>
<td><code class=pp>range</code>
</table>

<blockquote class=note>
<p><span class="u">&#x261E;</span><code>types.StringType</code> se převádí na <code>bytes</code> a ne na <code>str</code>, protože „řetězec“ v Pythonu 2 (ne Unicode řetězec, ale obyčejný řetězec) je ve skutečnosti jen posloupností bajtů odpovídajících určitému znakovému kódování.
</blockquote>

<h2 id=porting-code-to-python-3-with-2to3-isinstance>Globální funkce <code>isinstance()</code></h2>

<p>Funkce <code>isinstance()</code> kontroluje, zda je objekt instancí určité třídy nebo typu. V Pythonu 2 jsme mohli předat n-tici typů a <code>isinstance()</code> vrátila <code>True</code>, pokud byl objekt jedním z uvedených typů. V Pythonu 3 lze dělat totéž, ale předávání stejného typu dvakrát se považuje za nežádoucí (deprecated).

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>isinstance(x, (int, float, int))</code>
<td><code class=pp>isinstance(x, (int, float))</code>
</table>

<h2 id=porting-code-to-python-3-with-2to3-basestring>Datový typ <code>basestring</code></h2>

<p>Python 2 pracoval s dvěma typy řetězců: Unicode a ne-Unicode. Ale existoval v něm ještě jeden typ, <code><dfn>basestring</dfn></code>. Jednalo se o abstraktní typ, nadtřídu jak pro typ <code>str</code>, tak pro typ <code>unicode</code>. Nebylo možné ji volat nebo z ní vytvářet instanci přímo, ale mohli jste ji předat globální funkci <code>isinstance()</code>, když jste chtěli zkontrolovat, zda je objekt buď Unicode, nebo ne-Unicode řetězcem. V Pythonu 3 existuje jediný řetězcový typ, takže důvod k existenci typu <code>basestring</code> pominul.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>isinstance(x, basestring)</code>
<td><code class=pp>isinstance(x, str)</code>
</table>

<h2 id=porting-code-to-python-3-with-2to3-itertools><code>itertools</code> module</h2>

<p>Python 2.3 zavedl modul <code>itertools</code>, který definoval varianty globálních funkcí <code>zip()</code>, <code>map()</code> a <code>filter()</code>, které místo seznamu vracely iterátory. V Pythonu 3 tyto globální funkce vracejí iterátory, takže uvedené funkce byly z modulu <code>itertools</code> odstraněny. (<a href=#advanced-iterators-more-itertools>V modulu <code>itertools</code> je stále mnoho užitečných funkcí</a>, nejen ty právě zmíněné.)

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><code class=pp>itertools.<dfn>izip</dfn>(a, b)</code>
<td><code class=pp>zip(a, b)</code>
<tr><th>&#x2461;
<td><code class=pp>itertools.<dfn>imap</dfn>(a, b)</code>
<td><code class=pp>map(a, b)</code>
<tr><th>&#x2462;
<td><code class=pp>itertools.<dfn>ifilter</dfn>(a, b)</code>
<td><code class=pp>filter(a, b)</code>
<tr><th>&#x2463;
<td><code class=pp>from itertools import imap, izip, foo</code>
<td><code class=pp>from itertools import foo</code>
</table>

<ol>
<li>Místo <code>itertools.izip()</code> použijte jednoduše globální funkci <code>zip()</code>.
<li>Místo <code>itertools.imap()</code> použijte jednoduše <code>map()</code>.
<li>Z <code>itertools.ifilter()</code> se stává <code>filter()</code>.
<li>Modul <code>itertools</code> v Pythonu 3 pořád existuje. Jen v něm chybí funkce, které byly přesunuty do globálního prostoru jmen. Skript <code>2to3</code> je dost chytrý na to, aby odstranil importy, které neexistují, a ponechal ostatní importy nedotčené.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-sys_exc><code>sys.exc_type</code>, <code>sys.exc_value</code>, <code>sys.exc_traceback</code></h2>

<p>U Pythonu 2 se v modulu <code>sys</code> nacházely tři proměnné, které jsme mohli používat během obsluhy výjimky: <code>sys.exc_type</code>, <code>sys.exc_value</code>, <code>sys.exc_traceback</code>. (Ve skutečnosti mají původ už v Pythonu 1.) Už od Pythonu 1.5 bylo používání těchto proměnných považováno za nežádoucí (deprecated) ve prospěch <code>sys.exc_info()</code>, což je funkce vracející n-tici se všemi třemi hodnotami. V Pythonu 3 byly tyto tři individuální proměnné nakonec odstraněny. Musíme používat funkci <code>sys.exc_info()</code>.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp><dfn>sys.exc_type</dfn></code>
<td><code class=pp>sys.exc_info()[0]</code>
<tr><th>
<td><code class=pp><dfn>sys.exc_value</dfn></code>
<td><code class=pp>sys.exc_info()[1]</code>
<tr><th>
<td><code class=pp><dfn>sys.exc_traceback</dfn></code>
<td><code class=pp>sys.exc_info()[2]</code>
</table>

<h2 id=porting-code-to-python-3-with-2to3-paren>Generátory seznamů nad n-ticemi</h2>

<p>Pokud jsme v Pythonu 2 chtěli použít generátorovou notaci seznamu, která předepisovala iteraci přes n-tici, nemuseli jsme hodnoty n-tice uzavírat do kulatých závorek. V Pythonu 3 se explicitní závorky vyžadují.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp>[i for i in 1, 2]</code>
<td><code class=pp>[i for i in (1, 2)]</code>
</table>

<h2 id=porting-code-to-python-3-with-2to3-getcwdu>Funkce <code>os.getcwdu()</code></h2>

<p>V Pythonu 2 byla k dispozici funkce pojmenovaná <code>os.getcwd()</code>, která vracela aktuální pracovní adresář jako (ne-Unicode) řetězec. Protože moderní souborové systémy umí pracovat se jmény adresářů v libovolném znakovém kódování, zavedl Python 2.3 funkci <code>os.getcwdu()</code>. Funkce <code>os.getcwdu()</code> vracela aktuální pracovní adresář jako Unicode řetězec. V Pythonu 3 existuje <a href=#strings-divingin>jediný řetězcový typ (Unicode)</a>, takže <code>os.getcwd()</code> je vším, co potřebujeme.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>
<td><code class=pp><dfn>os.getcwdu</dfn>()</code>
<td><code class=pp>os.getcwd()</code>
</table>

<h2 id=porting-code-to-python-3-with-2to3-metaclass>Metatřídy</h2>

<p>V Pythonu 2 jsme mohli metatřídy vytvářet buď definicí argumentu <code>metaclass</code> v deklaraci třídy, nebo definicí speciálního atributu <code><dfn>__metaclass__</dfn></code> na úrovni třídy. V Pythonu 3 byl tento atribut třídy odstraněn.

<table>
<tr><th>Poznámky
<th>Python 2
<th>Python 3
<tr><th>&#x2460;
<td><pre class=pp><code>class C(metaclass=PapayaMeta):
    pass</code></pre>
<td><i>žádná změna</i>
<tr><th>&#x2461;
<td><pre class=pp><code>class Whip:
    __metaclass__ = PapayaMeta</code></pre>
<td><pre class=pp><code>class Whip(metaclass=PapayaMeta):
    pass</code></pre>
<tr><th>&#x2462;
<td><pre class=pp><code>class C(Whipper, Beater):
    __metaclass__ = PapayaMeta</code></pre>
<td><pre class=pp><code>class C(Whipper, Beater, metaclass=PapayaMeta):
    pass</code></pre>
</table>

<ol>
<li>Deklarace metatřídy v místě deklarace třídy fungovala v Pythonu 2 a funguje stejně i v Pythonu 3.
<li>Deklarace metatřídy pomocí atributu třídy fungovala v Pythonu 2, ale v Pythonu 3 již ne.
<li>Skript <code>2to3</code> je dost chytrý na to, aby zkonstruoval platnou deklaraci třídy dokonce i v případech, kdy třída dědí z jedné nebo více bázových tříd.
</ol>

<h2 id=porting-code-to-python-3-with-2to3-nitpick>Věci týkající se stylu</h2>

<p>Zbytek zde popsaných „oprav“ ve skutečnosti nejsou opravy jako takové. Tyto úpravy nemění podstatu, ale styl. Jde o věci, které fungují jak v Pythonu 2, tak v Pythonu 3. Vývojáři Pythonu ale mají zájem na tom, aby byl pythonovský kód tak jednotný, jak je to jen možné. Z tohoto pohledu existuje oficiální <a href="http://www.python.org/dev/peps/pep-0008/">Python style guide</a> (Průvodce stylem jazyka Python), který popisuje&nbsp;&mdash;&nbsp;až do nesnesitelnosti&nbsp;&mdash;&nbsp;všechny možné detaily, které vás téměř určitě nezajímají. A když už <code>2to3</code> vytváří tak mohutnou infrastrukturu pro konverzi pythonovského kódu z jedné podoby do druhé, vzali si autoři za své přidat pár nepovinných rysů, které by zlepšily čitelnost vašich pythonovských programů.

<h3 id=porting-code-to-python-3-with-2to3-set_literal>Množinové literály (<code>set()</code>; explicitně)</h3>

<p>V Pythonu 2 bylo jediným možným vyjádřením definice množinového literálu volání <code>set(posloupnost)</code>. V Pythonu 3 tato možnost stále funguje, ale čistší způsob spočívá v použití nového zápisu množinového literálu: složené závorky. Funguje to pro všechny množiny s výjimkou prázdné množiny. Je to tím, že slovníky používají složené závorky také a zápis <a href=#native-datatypes-emptyset><code>{}</code> byl již vyhrazen pro prázdný slovník a ne pro prázdnou množinu</a>.

<blockquote class=note>
<p><span class="u">&#x261E;</span>Skript <code>2to3</code> standardně množinové literály zapsané pomocí <code>set()</code> neupravuje. Pokud chceme tuto úpravu povolit, uvedeme při volání <code>2to3</code> na příkazovém řádku <kbd>-f set_literal</kbd> (f jako fix).
</blockquote>

<table>
<tr><th>Poznámky
<th>Před
<th>Po

<tr><th>
<td><code class=pp>set([1, 2, 3])</code>
<td><code class=pp>{1, 2, 3}</code>
<tr><th>
<td><code class=pp>set((1, 2, 3))</code>
<td><code class=pp>{1, 2, 3}</code>
<tr><th>
<td><code class=pp>set([i for i in a_sequence])</code>
<td><code class=pp>{i for i in a_sequence}</code>
</table>

<h3 id=porting-code-to-python-3-with-2to3-buffer>Globální funkce <code>buffer()</code> (explicitně)</h3>

<p>Pythonovské objekty implementované v jazyce C exportují takzvané „rozhraní bloku paměti“ (buffer interface), které umožňuje ostatnímu pythonovskému kódu přímo číst blok paměti a zapisovat do něj. (Je to přesně tak mocné a děsivé, jak to zní.) V Pythonu 3 byla funkce <code>buffer()</code> přejmenována na <code>memoryview()</code>. (Ve skutečnosti je to sice o něco komplikovanější, ale rozdíly můžete téměř určitě ignorovat.)

<blockquote class=note>
<p><span class="u">&#x261E;</span>Skript <code>2to3</code> standardně funkci <code>buffer()</code> neopravuje. Pokud chceme tuto úpravu povolit, uvedeme při volání <code>2to3</code> na příkazovém řádku <kbd>-f buffer</kbd>.
</blockquote>

<table>
<tr><th>Poznámky
<th>Před
<th>Po

<tr><th>
<td><code class=pp>x = <dfn>buffer</dfn>(y)</code>
<td><code class=pp>x = <dfn>memoryview</dfn>(y)</code>
</table>

<h3 id=porting-code-to-python-3-with-2to3-wscomma>Bílé znaky kolem čárek (explicitně)</h3>

<p>Navzdory drakonickým pravidlům pro používání bílých znaků (whitespace) při odsazování a předsazování se Python chová docela volně k používání bílých znaků v jiných oblastech. Uvnitř seznamů, n-tic, množin a slovníků se mohou bílé znaky objevit před a za čárkami bez škodlivých účinků. Jenže Průvodce stylem jazyka Python říká, že před čárkami se nemá psát žádná mezera a za čárkou se má psát jedna. Ačkoliv se zde jedná o čistě estetickou záležitost (kód funguje tak jako tak, v Pythonu 2 i v Pythonu 3), skript <code>2to3</code> tuto věc může volitelně opravit.

<blockquote class=note>
<p><span class="u">&#x261E;</span>Skript <code>2to3</code> standardně psaní bílých znaků kolem čárek neupravuje. Pokud chceme tuto úpravu povolit, uvedeme při volání <code>2to3</code> na příkazovém řádku <kbd>-f wscomma</kbd>.
</blockquote>

<table>
<tr><th>Poznámky
<th>Před
<th>Po

<tr><th>
<td><code class=pp>a ,b</code>
<td><code class=pp>a, b</code>
<tr><th>
<td><code class=pp>{a :b}</code>
<td><code class=pp>{a: b}</code>
</table>

<h3 id=porting-code-to-python-3-with-2to3-idioms>Běžné obraty (explicitně)</h3>

<p>V pythonovské komunitě postupně vznikla celá řada používaných obratů. Některé se datují až k Pythonu 1, jako například cyklus <code>while 1:</code>. (Až do verze 2.3 neměl Python opravdový booleovský typ, takže vývojáři místo pravdivostních hodnot používali <code>1</code> a <code>0</code>.) Moderní pythonovští programátoři by své mozky měli natrénovat na modernější podobu takových obratů.

<blockquote class=note>
<p><span class="u">&#x261E;</span>Skript <code>2to3</code> standardně opravu běžných obratů neprovádí. Pokud chceme tuto úpravu povolit, uvedeme při volání <code>2to3</code> na příkazovém řádku <kbd>-f idioms</kbd>.
</blockquote>

<table>
<tr><th>Poznámky
<th>Před
<th>Po

<tr><th>
<td><pre class=pp><code>while 1:
    do_stuff()</code></pre>
<td><pre class=pp><code>while True:
    do_stuff()</code></pre>
<tr><th>
<td><code class=pp>type(x) == T</code>
<td><code class=pp>isinstance(x, T)</code>
<tr><th>
<td><code class=pp>type(x) is T</code>
<td><code class=pp>isinstance(x, T)</code>
<tr><th>
<td><pre class=pp><code>a_list = list(a_sequence)
a_list.sort()
do_stuff(a_list)</code></pre>
<td><pre class=pp><code>a_list = sorted(a_sequence)
do_stuff(a_list)</code></pre>
</table>

</div>
<div id=chapter-special-method-names>
<div id=appb>
<h1>Jména speciálních metod</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> My specialty is being right when other people are wrong. <span class="u">&#x275E;</span><br>(Mou specialitou je mít pravdu, když se ostatní lidé mýlí.)<br>&mdash; <a href="http://en.wikiquote.org/wiki/George_Bernard_Shaw">George Bernard Shaw</a>
</blockquote>
<p>&nbsp;
<h2 id=special-method-names-divingin>Ponořme se</h2>
<p class=f>V celé knize jsme se setkávali s příklady „speciálních metod“&nbsp;&mdash;&nbsp;v jistém smyslu „magických“ metod, které Python vyvolává, když použijeme určitou syntaxi. Pokud vaše třídy použijí speciální metody, mohou se chovat jako množiny, jako slovníky, jako funkce, jako iterátory nebo dokonce jako čísla. Tato příloha slouží jako referenční příručka ke speciálním metodám, se kterými jsme se už setkali, a jako stručný úvod k některým esoteričtějším speciálním metodám.

<h2 id=special-method-names-basics>Základy</h2>

<p>Pokud jste už četli <a href=#iterators-divingin>úvod k třídám</a>, už jste se setkali s nejběžnější speciální metodou, s metodou <code>__init__()</code>. Většina tříd, které píšeme, nakonec potřebuje nějakou inicializaci. Existuje několik dalších základních speciálních metod, které jsou zvlášť užitečné při ladění našich uživatelsky definovaných tříd.

<table>
<tr><th>Poznámky
<th>To, co chceme&hellip;
<th>Takže napíšeme&hellip;
<th>A Python zavolá&hellip;
<tr><th>&#x2460;
<td>inicializace instance
<td><code class="pp">x = MyClass()</code>
<td><a href="http://docs.python.org/3.1/reference/datamodel.html#object.__init__"><code>x.<dfn>__init__</dfn>()</code></a>
<tr><th>&#x2461;
<td>„oficiální“ řetězcová reprezentace
<td><code class="pp"><dfn>repr</dfn>(x)</code>
<td><a href="http://docs.python.org/3.1/reference/datamodel.html#object.__repr__"><code>x.<dfn>__repr__</dfn>()</code></a>
<tr><th>&#x2462;
<td>„neformální“ řetězcová podoba
<td><a href="http://docs.python.org/3.1/reference/datamodel.html#object.__str__"><code><dfn>str</dfn>(x)</code></a>
<td><code class="pp">x.<dfn>__str__</dfn>()</code>
<tr><th>&#x2463;
<td>„neformální“ podoba v poli bajtů
<td><code class="pp"><dfn>bytes</dfn>(x)</code>
<td><code class="pp">x.<dfn>__bytes__</dfn>()</code>
<tr><th>&#x2464;
<td>hodnota jako naformátovaný řetězec
<td><code class="pp">format(x, <var>format_spec</var>)</code>
<td><a href="http://docs.python.org/3.1/reference/datamodel.html#object.__format__"><code>x.<dfn>__format__</dfn>(<var>format_spec</var>)</code></a>
</table>
<ol>
<li>Metoda <code>__init__()</code> se volá <em>až poté</em>, co byla instance vytvořena. Pokud chceme ovládat proces skutečného vytváření instance, musíme použít <a href=#special-method-names-esoterica>metodu <code>__new__()</code></a>.
<li>Metoda <code>__repr__()</code> by podle konvence měla vracet řetězec, který je platným pythonovským výrazem.
<li>Metoda <code>__str__()</code> se volá také v případě, kdy použijeme <code>print(x)</code>.
<li><em>Novinka v Pythonu 3</em>, která souvisí se zavedením typu <code>bytes</code>.
<li>Podle konvence by měl být <var>format_spec</var> v souladu s <a href="http://www.python.org/doc/3.1/library/string.html#formatspec">minijazykem pro specifikaci formátu</a>. Modul <code>decimal.py</code> z pythonovské standardní knihovny má svou vlastní metodu <code>__format__()</code>.
</ol>

<h2 id=special-method-names-acts-like-iterator>Třídy, které se chovají jako iterátory</h2>

<p><a href=#chapter-iterators>V kapitole o iterátorech</a> jsme si ukázali, jak můžeme vytvořit iterátor od základů s využitím metod <code>__iter__()</code> a <code>__next__()</code>.

<table>
<tr><th>Poznámky
<th>To, co chceme&hellip;
<th>Takže napíšeme&hellip;
<th>A Python zavolá&hellip;
<tr><th>&#x2460;
<td>iterování přes posloupnost
<td><code class="pp"><dfn>iter</dfn>(seq)</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__iter__"><code>seq.<dfn>__iter__</dfn>()</code></a>
<tr><th>&#x2461;
<td>získání další hodnoty iterátoru
<td><code class="pp"><dfn>next</dfn>(seq)</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__next__"><code>seq.<dfn>__next__</dfn>()</code></a>
<tr><th>&#x2462;
<td>vytvoření iterátoru procházejícího v opačném pořadí
<td><code class="pp"><dfn>reversed</dfn>(seq)</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__reversed__"><code>seq.<dfn>__reversed__</dfn>()</code></a>
</table>
<ol>
<li>Metoda <code>__iter__()</code> se volá, kdykoliv vytváříme nový iterátor. Je to dobré místo pro nastavení počátečních hodnot iterátoru.
<li>Metoda <code>__next__()</code> se volá, kdykoliv se snažíme o získání nové hodnoty iterátoru.
<li>Metoda <code>__reversed__()</code> se běžně nepoužívá. Vezme existující posloupnost a vrací iterátor, který produkuje prvky posloupnosti v opačném pořadí, tj. od posledního k prvnímu.
</ol>

<p>Jak jsme si ukázali <a href=#iterators-a-fibonacci-iterator>v kapitole o iterátorech</a>, cyklus <code>for</code> se může chovat jako iterátor. V následujícím cyklu:

<pre class='nd pp'><code>for x in seq:
    print(x)</code></pre>

<p>Python 3 vytvoří iterátor voláním <code>seq.__iter__()</code> a potom bude získávat hodnoty <var>x</var> voláním jeho metody <code>__next__()</code>. Jakmile metoda <code>__next__()</code> vyvolá výjimku <code>StopIteration</code>, cyklus <code>for</code> spořádaně skončí.

<h2 id=special-method-names-computed-attributes>Vypočítávané atributy</h2>

<table>
<tr><th>Poznámky
<th>To, co chceme&hellip;
<th>Takže napíšeme&hellip;
<th>A Python zavolá&hellip;
<tr><th>&#x2460;
<td>získat vypočítaný atribut (nepodmíněně)
<td><code class="pp">x.my_property</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__getattribute__"><code>x.<dfn>__getattribute__</dfn>(<var>'my_property'</var>)</code></a>
<tr><th>&#x2461;
<td>získat vypočítaný atribut (fallback)
<td><code class="pp">x.my_property</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__getattr__"><code>x.<dfn>__getattr__</dfn>(<var>'my_property'</var>)</code></a>
<tr><th>&#x2462;
<td>nastavit hodnotu atributu
<td><code class="pp">x.my_property = value</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__setattr__"><code>x.<dfn>__setattr__</dfn>(<var>'my_property'</var>, <var>value</var>)</code></a>
<tr><th>&#x2463;
<td>zrušit atribut
<td><code class="pp">del x.my_property</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__delattr__"><code>x.<dfn>__delattr__</dfn>(<var>'my_property'</var>)</code></a>
<tr><th>&#x2464;
<td>vypsat seznam atributů a metod
<td><code class="pp">dir(x)</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__dir__"><code>x.<dfn>__dir__</dfn>()</code></a>
</table>
<ol>
<li>Pokud třída definuje metodu <code>__getattribute__()</code>, zavolá ji Python <em>při každém odkazu na libovolný atribut nebo jméno metody</em> (s výjimkou jmen speciálních metod, protože by tím vznikl nepříjemný nekonečný cyklus).
<li>Pokud třída definuje metodu <code>__getattr__()</code>, bude ji Python volat až poté, co atribut nenajde na některém z běžných míst. Pokud instance <var>x</var> definuje atribut <var>color</var>, <em>nepovede</em> použití <code>x.color</code> k volání <code>x.__getattr__('color')</code>. Jednoduše se vrátí již definovaná hodnota <var>x.color</var>.
<li>Metoda <code>__setattr__()</code> se volá, kdykoliv chceme atributu přiřadit nějakou hodnotu.
<li>Metoda <code>__delattr__()</code> se volá, kdykoliv chceme atribut zrušit.
<li>Metoda <code>__dir__()</code> je užitečná v případech, kdy definujeme metodu <code>__getattr__()</code> nebo metodu <code>__getattribute__()</code>. Normálně bychom voláním funkce <code>dir(x)</code> získali jen seznam běžných atributů a metod. Pokud například metoda <code>__getattr__()</code> vytváří atribut <var>color</var> dynamicky, nevypisoval by se <var>color</var> v seznamu vraceném funkcí <code>dir(x)</code> jako jeden z dostupných atributů. Předefinování metody <code>__dir__()</code> nám umožní vypsat <var>color</var> jako dostupný atribut. Může to být užitečné pro jiné programátory, kteří si přejí používat naši třídu, aniž by museli zkoumat její vnitřní možnosti.
</ol>

<p>Rozdíl mezi metodami <code>__getattr__()</code> a <code>__getattribute__()</code> je jemný, ale důležitý. Vysvětlíme si ho na dvou příkladech:

<pre class=screen>
<code>class Dynamo:
    def __getattr__(self, key):
<a>        if key == 'color':         <span class=u>&#x2460;</span></a>
            return 'PapayaWhip'
        else:
<a>            raise AttributeError   <span class=u>&#x2461;</span></a></code>

<samp class=p>>>> </samp><kbd class=pp>dyn = Dynamo()</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>dyn.color</kbd>                      <span class=u>&#x2462;</span></a>
<samp class=pp>'PapayaWhip'</samp>
<samp class=p>>>> </samp><kbd class=pp>dyn.color = 'LemonChiffon'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>dyn.color</kbd>                      <span class=u>&#x2463;</span></a>
<samp class=pp>'LemonChiffon'</samp></pre>
<ol>
<li>Jméno atributu se předá metodě <code>__getattr__()</code> jako řetězec. Pokud je jméno rovno <code>'color'</code>, vrátí metoda hodnotu. (V tomto případě se jedná o pevně zadaný řetězec, ale normálně bychom zde provedli nějaký výpočet a vrátili bychom řetězec.)
<li>Pokud jméno atributu neznáme, musí metoda <code>__getattr__()</code> vyvolat výjimku <code>AttributeError</code>. V opačném případě by náš kód při přístupu k nedefinovanému atributu potichu selhal. (Pokud metoda nevyvolá výjimku nebo explicitně nevrátí nějakou hodnotu, pak &mdash; z technického hlediska &mdash; vrací <code>None</code>, což je pythonovská hodnota null. To znamená, že by <em>všechny</em> atributy, které by nebyly explicitně definovány, nabývaly hodnoty <code>None</code>. To téměř určitě nechceme.)
<li>Instance <var>dyn</var> nemá atribut jménem <var>color</var>, takže se zavolá metoda <code>__getattr__()</code>, která vrátí vypočítanou hodnotu.
<li>Jakmile explicitně nastavíme <var>dyn.color</var>, přestane se metoda <code>__getattr__()</code> pro získání hodnoty <var>dyn.color</var> volat, protože atribut <var>dyn.color</var> už je v instanci definován.
</ol>

<p>Ve srovnání s tím je metoda <code>__getattribute__()</code> absolutní a nepodmíněná.

<pre class=screen>
<code>class SuperDynamo:
    def __getattribute__(self, key):
        if key == 'color':
            return 'PapayaWhip'
        else:
            raise AttributeError</code>

<samp class=p>>>> </samp><kbd class=pp>dyn = SuperDynamo()</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>dyn.color</kbd>                      <span class=u>&#x2460;</span></a>
<samp class=pp>'PapayaWhip'</samp>
<samp class=p>>>> </samp><kbd class=pp>dyn.color = 'LemonChiffon'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>dyn.color</kbd>                      <span class=u>&#x2461;</span></a>
<samp class=pp>'PapayaWhip'</samp></pre>
<ol>
<li>Pro získání hodnoty <var>dyn.color</var> se volá metoda <code>__getattribute__()</code>.
<li>Dokonce i když explicitně nastavíme <var>dyn.color</var>, bude se pro získávání hodnoty <var>dyn.color</var> <em>stále volat</em> metoda <code>__getattribute__()</code>. Pokud je metoda <code>__getattribute__()</code> definována, <em>volá se nepodmíněně</em> při hledání každého atributu nebo metody. Platí to i pro atributy, které jsme po vytvoření instance explicitně nastavili (a tím vytvořili).
</ol>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Pokud vaše třída definuje metodu <code>__getattribute__()</code>, pak pravděpodobně chcete definovat také metodu <code>__setattr__()</code>. Pro udržení přehledu o hodnotách atributů musíte mezi těmito metodami zajistit spolupráci. V opačném případě by se atributy nastavené po vytvoření instance ztrácely v černé díře.
</blockquote>

<p>U metody <code>__getattribute__()</code> musíme být velmi pečliví, protože ji Python používá i při hledání jmen metod třídy.

<pre class=screen>
<code>class Rastan:
    def __getattribute__(self, key):
<a>        raise AttributeError           <span class=u>&#x2460;</span></a>
    def swim(self):
        pass</code>

<samp class=p>>>> </samp><kbd class=pp>hero = Rastan()</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>hero.swim()</kbd>                        <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;stdin>", line 3, in __getattribute__
AttributeError</samp></pre>
<ol>
<li>Tato třída definuje metodu <code>__getattribute__()</code>, která vždy vyvolá výjimku <code>AttributeError</code>. Hledání každého atributu nebo metody skončí neúspěšně.
<li>Pokud zavoláme <code>hero.swim()</code>, začne Python v třídě <code>Rastan</code> hledat metodu <code>swim()</code>. Hledání prochází metodou <code>__getattribute__()</code>, <em>protože hledání všech atributů a metod prochází metodou <code>__getattribute__()</code></em>. V tomto případě metoda <code>__getattribute__()</code> vyvolá výjimku <code>AttributeError</code>, takže hledání metody selže a tím pádem selže i její volání.
</ol>

<h2 id=special-method-names-acts-like-function>Třídy, které se chovají jako funkce</h2>

<p>Pokud třída definuje metodu <code>__call__()</code>, můžeme instanci třídy volat (callable), jako kdyby to byla funkce.

<table>
<tr><th>Poznámky
<th>To, co chceme&hellip;
<th>Takže napíšeme&hellip;
<th>A Python zavolá&hellip;
<tr><th>
<td>„volat“ instaci jako funkci
<td><code class="pp">my_instance()</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__call__"><code>my_instance.<dfn>__call__</dfn>()</code></a>
</table>

<p><a href="http://docs.python.org/3.1/library/zipfile.html">Modul <code>zipfile</code></a> tento způsob používá pro definici třídy, která umí zadaným heslem <dfn>dešifrovat</dfn> (decrypt) <dfn>zašifrovaný</dfn> (encrypted) <dfn>zip</dfn> soubor. <dfn>Dešifrovací</dfn> algoritmus pro zip vyžaduje, aby se během dešifrování ukládal stav. Pokud dešifrátor (decryptor) definujeme jako třídu, může si stav uchovávat uvnitř instance své třídy. Stav se inicializuje v metodě <code>__init__()</code> a aktualizuje se během <dfn>dešifrování</dfn> souboru. Ale protože je třída definována jako „volatelná“ (jako funkce), můžeme instanci třídy předat jako první argument funkce <code>map()</code> takto:

<pre class=pp><code># excerpt from zipfile.py
class _ZipDecrypter:
.
.
.
    def __init__(self, pwd):
<a>        self.key0 = 305419896               <span class=u>&#x2460;</span></a>
        self.key1 = 591751049
        self.key2 = 878082192
        for p in pwd:
            self._UpdateKeys(p)

<a>    def __call__(self, c):                  <span class=u>&#x2461;</span></a>
        assert isinstance(c, int)
        k = self.key2 | 2
        c = c ^ (((k * (k^1)) >> 8) &amp; 255)
        self._UpdateKeys(c)
        return c
.
.
.
<a>zd = _ZipDecrypter(pwd)                    <span class=u>&#x2462;</span></a>
bytes = zef_file.read(12)
<a>h = list(map(zd, bytes[0:12]))             <span class=u>&#x2463;</span></a></code></pre>
<ol>
<li>Třída <code>_ZipDecryptor</code> udržuje stav v podobě tří rotujících klíčů, které se později aktualizují metodou <code>_UpdateKeys()</code> (zde neukázána).
<li>Třída definuje metodu <code>__call__()</code>, která způsobuje, že instance třídy můžeme volat, jako kdyby to byly funkce. V tomto případě metoda <code>__call__()</code> dešifruje jeden bajt ze zip souboru a potom aktualizuje rotující klíče podle hodnoty dešifrovaného bajtu.
<li><var>zd</var> je instancí třídy <code>_ZipDecryptor</code>. Proměnná <var>pwd</var> (password; heslo) je předána metodě <code>__init__()</code>, která její obsah uloží a použije jej pro první aktualizaci rotujících klíčů.
<li>Máme prvních 12 bajtů zip souboru. Dešifrujeme je zobrazením bajtů přes <var>zd</var>. To znamená, že se 12krát „volá“ <var>zd</var>, což znamená, že se 12krát volá metoda <code>__call__()</code>, která aktualizuje vnitřní stav instance a 12krát vrací výsledný bajt.
</ol>

<h2 id=special-method-names-acts-like-set>Třídy, které se chovají jako množiny</h2>

<p>Pokud se naše třída chová jako kontejner pro množinu hodnot&nbsp;&mdash;&nbsp;tj. pokud má smysl ptát se, zda naše třída „obsahuje“ hodnotu&nbsp;&mdash;&nbsp;, pak by pravděpodobně měla definovat následující speciální metody, které způsobí, že se bude chovat jako množina.

<table>
<tr><th>Poznámky
<th>To, co chceme&hellip;
<th>Takže napíšeme&hellip;
<th>A Python zavolá&hellip;
<tr><th>
<td>počet položek
<td><code class="pp"><dfn>len</dfn>(s)</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__len__"><code>s.<dfn>__len__</dfn>()</code></a>
<tr><th>
<td>test, zda posloupnost obsahuje určitou hodnotu
<td><code class="pp">x in s</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__contains__"><code>s.<dfn>__contains__</dfn>(<var>x</var>)</code></a>
</table>

<p id=special-method-names-acts-like-set-example><a href="http://docs.python.org/3.1/library/cgi.html">Modul <code>cgi</code></a> tyto metody používá ve své třídě <code>FieldStorage</code>, která reprezentuje všechna pole formuláře nebo parametry dotazu, které byly zaslány na dynamickou webovou stránku.

<pre class=pp><code># A script which responds to http://example.com/search?q=cgi
import cgi
fs = cgi.FieldStorage()
<a>if 'q' in fs:                                               <span class=u>&#x2460;</span></a>
  do_search()

# An excerpt from cgi.py that explains how that works
class FieldStorage:
.
.
.
<a>    def __contains__(self, key):                            <span class=u>&#x2461;</span></a>
        if self.list is None:
            raise TypeError('not indexable')
<a>        return any(item.name == key for item in self.list)  <span class=u>&#x2462;</span></a>

<a>    def __len__(self):                                      <span class=u>&#x2463;</span></a>
<a>        return len(self.keys())                             <span class=u>&#x2464;</span></a></code></pre>
<ol>
<li>Jakmile vytvoříme instanci třídy <code>cgi.FieldStorage</code>, můžeme použít operátor „<code>in</code>“ pro ověření, zda se v řetězci s dotazem nachází určitý parametr.
<li>Kouzlem, které to umožní, je metoda <code>__contains__()</code>. Pokud napíšeme <code>if 'q' in fs</code>, hledá Python metodu <code>__contains__()</code> objektu <var>fs</var>, který je definován v <code>cgi.py</code>. Hodnota <code>'q'</code> je předána metodě<code>__contains__()</code> jako argument <var>key</var>.
<li>Funkce <code>any()</code> přebírá <a href=#advanced-iterators-generator-expressions>generátorový výraz</a>. Pokud generátor vyplivne nějaké položky, vrací hodnotu <code>True</code>. Funkce <code>any()</code> je dost chytrá na to, aby zastavila, jakmile je nalezena první shoda.
<li>Stejná třída <code>FieldStorage</code> podporuje také vracení své délky, takže můžeme napsat <code>len(<var>fs</var>)</code> a zavolá se metoda <code>__len__()</code> třídy <code>FieldStorage</code>, která vrátí počet rozpoznaných parametrů dotazu.
<li>Metoda <code>self.keys()</code> kontroluje, zda <code>self.list is None</code> (zda seznam vůbec existuje), takže metoda <code>__len__</code> nemusí uvedenou kontrolu chyb dublovat.
</ol>

<h2 id=special-method-names-acts-like-dict>Třídy, které se chovají jako slovníky</h2>

<p>Když předchozí možnosti trošku rozšíříme, můžeme definovat třídy, které nejenže reagují na operátor „<code>in</code>“ a na funkci <code>len()</code>, ale které se mohou chovat jako plnohodnotné slovníky vracející hodnoty vázané na klíče.

<table>
<tr><th>Poznámky
<th>To, co chceme&hellip;
<th>Takže napíšeme&hellip;
<th>A Python zavolá&hellip;
<tr><th>
<td>získat hodnotu podle klíče
<td><code class="pp">x[key]</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__getitem__"><code>x.<dfn>__getitem__</dfn>(<var>key</var>)</code></a>
<tr><th>
<td>nastavit hodnotu vázanou na klíč
<td><code class="pp">x[key] = value</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__setitem__"><code>x.<dfn>__setitem__</dfn>(<var>key</var>, <var>value</var>)</code></a>
<tr><th>
<td>zrušit dvojici klíč-hodnota
<td><code class="pp">del x[key]</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__delitem__"><code>x.<dfn>__delitem__</dfn>(<var>key</var>)</code></a>
<tr><th>
<td>vrátit výchozí hodnotu pro chybějící klíče
<td><code class="pp">x[nonexistent_key]</code>
<td><a href="http://docs.python.org/3.1/library/collections.html#collections.defaultdict.__missing__"><code>x.<dfn>__missing__</dfn>(<var>nonexistent_key</var>)</code></a>
</table>

<p><a href=#special-method-names-acts-like-set-example>Třída <code>FieldStorage</code></a> z <a href="http://docs.python.org/3.1/library/cgi.html">modulu <code>cgi</code></a> definuje rovněž tyto speciální metody, což znamená, že můžeme dělat například následující věci:

<pre class=pp><code># A script which responds to http://example.com/search?q=cgi
import cgi
fs = cgi.FieldStorage()
if 'q' in fs:
<a>  do_search(fs['q'])                              <span class=u>&#x2460;</span></a>

# An excerpt from cgi.py that shows how it works
class FieldStorage:
.
.
.
<a>    def __getitem__(self, key):                   <span class=u>&#x2461;</span></a>
        if self.list is None:
            raise TypeError('not indexable')
        found = []
        for item in self.list:
            if item.name == key: found.append(item)
        if not found:
            raise KeyError(key)
        if len(found) == 1:
            return found[0]
        else:
            return found</code></pre>
<ol>
<li>Objekt <var>fs</var> je instancí <code>cgi.FieldStorage</code>, ale přesto můžeme používat výrazy jako <code>fs['q']</code>.
<li><code>fs['q']</code> zavolá metodu <code>__getitem__()</code> s parametrem <var>key</var> nastaveným na <code>'q'</code>. Potom se ve vnitřním seznamu parametrů dotazu (<var>self.list</var>) hledá položka, jejíž atribut <code>.name</code> je roven zadanému klíči.
</ol>

<h2 id=special-method-names-acts-like-number>Třídy, které se chovají jako čísla</h2>

<p>Při použití příslušných speciálních metod můžeme definovat své vlastní třídy, které se chovají jako čísla. To znamená, že je můžeme sčítat, odčítat a provádět s nimi další matematické operace. Tímto způsobem jsou implementovány věci v modulu <dfn>fractions</dfn>&nbsp;&mdash;&nbsp;třída <code><dfn>Fraction</dfn></code> implementuje speciální metody, které nám umožňují provádět takovéto věci:

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>from fractions import Fraction</kbd>
<samp class=p>>>> </samp><kbd class=pp>x = Fraction(1, 3)</kbd>
<samp class=p>>>> </samp><kbd class=pp>x / 3</kbd>
<samp class=pp>Fraction(1, 9)</samp></pre>

<p>Zde je úplný seznam speciálních metod, které musí implementovat třída chovající se jako číslo.

<table>
<tr><th>Poznámky
<th>To, co chceme&hellip;
<th>Takže napíšeme&hellip;
<th>A Python zavolá&hellip;
<tr><th>
<td>sčítání
<td><code class="pp">x + y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__add__"><code>x.<dfn>__add__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>odčítání
<td><code class="pp">x - y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__sub__"><code>x.<dfn>__sub__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>násobení
<td><code class="pp">x * y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__mul__"><code>x.<dfn>__mul__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>dělení
<td><code class="pp">x / y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__truediv__"><code>x.<dfn>__truediv__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>celočíselné dělení (floor division)
<td><code>x // y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__floordiv__"><code>x.<dfn>__floordiv__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>modulo (zbytek)
<td><code class="pp">x % y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__mod__"><code>x.<dfn>__mod__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>celočíselné dělení a zbytek
<td><code class="pp">divmod(x, y)</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__divmod__"><code>x.<dfn>__divmod__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>umocnění na
<td><code class="pp">x ** y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__pow__"><code>x.<dfn>__pow__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>bitový posun doleva
<td><code class="pp">x &lt;&lt; y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__lshift__"><code>x.<dfn>__lshift__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>bitový posun doprava
<td><code class="pp">x &gt;&gt; y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__rshift__"><code>x.<dfn>__rshift__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>logický součin po bitech (<code>and</code>)
<td><code class="pp">x &amp; y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__and__"><code>x.<dfn>__and__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td><code>xor</code> po bitech
<td><code class="pp">x ^ y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__xor__"><code>x.<dfn>__xor__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>logický součet po bitech (<code>or</code>)
<td><code class="pp">x | y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__or__"><code>x.<dfn>__or__</dfn>(<var>y</var>)</code></a>
</table>

<p>Pokud je <var>x</var> instancí třídy, která tyto metody implementuje, bude to fungovat bez problémů. Ale co když třída některou z těchto metod neimplementuje? Nebo ještě hůř &mdash; co když je implementuje, ale neporadí si s některými druhy argumentů? Například:

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>from fractions import Fraction</kbd>
<samp class=p>>>> </samp><kbd class=pp>x = Fraction(1, 3)</kbd>
<samp class=p>>>> </samp><kbd class=pp>1 / x</kbd>
<samp class=pp>Fraction(3, 1)</samp></pre>

<p>Tohle <em>není</em> případ, kdy se vezme <code>Fraction</code> a dělí se celým číslem (jako v předchozím příkladu). Minulý příklad byl přímočarý: <code>x / 3</code> volá <code>x.__truediv__(3)</code> a metoda <code>__truediv__()</code> třídy <code>Fraction</code> provede matematickou operaci. Ale objekty typu celé číslo (int) „neumí“ dělat aritmetické operace se zlomky. Takže jak je možné, že ten příklad funguje?

<p>Existuje druhá sada aritmetických speciálních metod s <i>obrácenými operandy</i> (reflected operands). Pokud matematická operace vyžaduje dva operandy (například <code>x / y</code>), dá se to řešit dvěma způsoby:

<ol>
<li>Řekneme <var>x</var>, aby podělilo samo sebe hodnotou <var>y</var>, nebo
<li>řekneme <var>y</var>, aby se zachovalo jako dělitel hodnoty <var>x</var>.
</ol>

<p>Výše uvedená sada speciálních metod používá první přístup: pokud máme <code>x / y</code>, poskytují metody způsob, jak může <var>x</var> říci: „Já vím, jak vydělit sebe hodnotou <var>y</var>.“ Následující sada speciálních metod se pouští do druhého přístupu &mdash; metody poskytují způsob, jakým může <var>y</var> vyjádřit: „Já vím, jak být dělitelem a podělit sebou hodnotu <var>x</var>.“

<table>
<tr><th>Poznámky
<th>To, co chceme&hellip;
<th>Takže napíšeme&hellip;
<th>A Python zavolá&hellip;
<tr><th>
<td>sčítání
<td><code class="pp">x + y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__radd__"><code>y.<dfn>__radd__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>odčítání
<td><code class="pp">x - y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__rsub__"><code>y.<dfn>__rsub__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>násobení
<td><code class="pp">x * y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__rmul__"><code>y.<dfn>__rmul__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>dělení
<td><code class="pp">x / y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__rtruediv__"><code>y.<dfn>__rtruediv__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>celočíselné dělení (floor division)
<td><code>x // y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__rfloordiv__"><code>y.<dfn>__rfloordiv__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>modulo (zbytek)
<td><code class="pp">x % y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__rmod__"><code>y.<dfn>__rmod__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>celočíselné dělení a zbytek
<td><code class="pp">divmod(x, y)</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__rdivmod__"><code>y.<dfn>__rdivmod__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>umocnění na
<td><code class="pp">x ** y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__rpow__"><code>y.<dfn>__rpow__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>bitový posun doleva
<td><code class="pp">x &lt;&lt; y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__rlshift__"><code>y.<dfn>__rlshift__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>bitový posun doprava
<td><code class="pp">x &gt;&gt; y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__rrshift__"><code>y.<dfn>__rrshift__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>logický součin po bitech (<code>and</code>)
<td><code class="pp">x &amp; y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__rand__"><code>y.<dfn>__rand__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td><code>xor</code> po bitech
<td><code class="pp">x ^ y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__rxor__"><code>y.<dfn>__rxor__</dfn>(<var>x</var>)</code></a>
<tr><th>
<td>logický součet po bitech (<code>or</code>)
<td><code class="pp">x | y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__ror__"><code>y.<dfn>__ror__</dfn>(<var>x</var>)</code></a>
</table>

<p>Ale moment! Ono je toho ještě víc! Pokud provádíme operace „přímo nad proměnnou“ (in-place, in situ, na místě samém), jako například <code>x/=3</code>, můžeme definovat ještě další speciální metody.

<table>
<tr><th>Poznámky
<th>To, co chceme&hellip;
<th>Takže napíšeme&hellip;
<th>A Python zavolá&hellip;
<tr><th>
<td>sčítání nad proměnnou
<td><code class="pp">x += y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__iadd__"><code>x.<dfn>__iadd__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>odčítání nad proměnnou
<td><code class="pp">x -= y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__isub__"><code>x.<dfn>__isub__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>násobení nad proměnnou
<td><code class="pp">x *= y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__imul__"><code>x.<dfn>__imul__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>dělení nad proměnnou
<td><code class="pp">x /= y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__itruediv__"><code>x.<dfn>__itruediv__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>celočíselné dělení nad proměnnou (floor division)
<td><code>x //= y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__ifloordiv__"><code>x.<dfn>__ifloordiv__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>modulo nad proměnnou
<td><code class="pp">x %= y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__imod__"><code>x.<dfn>__imod__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>umocnění nad proměnnou
<td><code class="pp">x **= y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__ipow__"><code>x.<dfn>__ipow__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>bitový posun doleva nad proměnnou
<td><code class="pp">x &lt;&lt;= y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__ilshift__"><code>x.<dfn>__ilshift__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>bitový posun doprava nad proměnnou
<td><code class="pp">x &gt;&gt;= y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__irshift__"><code>x.<dfn>__irshift__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>logický součin po bitech nad proměnnou (<code>and</code>)
<td><code class="pp">x &amp;= y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__iand__"><code>x.<dfn>__iand__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td><code>xor</code> po bitech nad proměnnou
<td><code class="pp">x ^= y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__ixor__"><code>x.<dfn>__ixor__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>logický součet po bitech nad proměnnou (<code>or</code>)
<td><code class="pp">x |= y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__ior__"><code>x.<dfn>__ior__</dfn>(<var>y</var>)</code></a>
</table>

<p>Poznámka: Ve většině případů se implementace „in situ“ metod nevyžaduje. Pokud pro určitou operaci příslušnou „in situ“ metodu (tj. nad proměnnou) nedefinujeme, Python se ji pokusí nahradit. Například při provádění výrazu <code>x /= y</code> Python...

<ol>
<li>Vyzkouší zavolat <code>x.__itruediv__(<var>y</var>)</code>. Pokud je metoda definována a vrátila hodnotu jinou než <code>NotImplemented</code>, je to hotové.
<li>Vyzkouší zavolat <code>x.__truediv__(<var>y</var>)</code>. Pokud je metoda definována a vrátila hodnotu jinou než <code>NotImplemented</code>, je původní hodnota <var>x</var> zahozena a je nahrazena výslednou hodnotou &mdash; jako kdybychom místo toho napsali <code> x = x / y</code>.
<li>Vyzkouší zavolat <code>y.__rtruediv__(<var>x</var>)</code>. Pokud je metoda definována a vrátila hodnotu jinou než <code>NotImplemented</code>, je původní hodnota <var>x</var> zahozena a je nahrazena výslednou hodnotou.
</ol>

<p>Takže „in situ“ metodu jako <code>__itruediv__()</code> definujeme jen v případech, kdy chceme pro in situ operandy provádět nějakou speciální optimalizaci. V opačném případě Python v podstatě přeformuluje požadavek provedení operandu nad proměnnou na běžnou podobu operandu s přiřazením výsledku do proměnné.

<p>Objekty, které se chovají jako číslo, mohou nad sebou provádět také pár „unárních“ matematických operací.

<table>
<tr><th>Poznámky
<th>To, co chceme&hellip;
<th>Takže napíšeme&hellip;
<th>A Python zavolá&hellip;
<tr><th>
<td>unární minus (záporné číslo)
<td><code class="pp">-x</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__neg__"><code>x.<dfn>__neg__</dfn>()</code></a>
<tr><th>
<td>unární plus (kladné číslo)
<td><code class="pp">+x</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__pos__"><code>x.<dfn>__pos__</dfn>()</code></a>
<tr><th>
<td>absolutní hodnota
<td><code class="pp">abs(x)</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__abs__"><code>x.<dfn>__abs__</dfn>()</code></a>
<tr><th>
<td>inverze
<td><code class="pp">~x</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__invert__"><code>x.<dfn>__invert__</dfn>()</code></a>
<tr><th>
<td>převod na komplexní číslo
<td><code class="pp">complex(x)</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__complex__"><code>x.<dfn>__complex__</dfn>()</code></a>
<tr><th>
<td>převod na celé číslo
<td><code class="pp">int(x)</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__int__"><code>x.<dfn>__int__</dfn>()</code></a>
<tr><th>
<td>převod na reálné číslo
<td><code class="pp">float(x)</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__float__"><code>x.<dfn>__float__</dfn>()</code></a>
<tr><th>
<td>převod na nejbližší celé číslo zaokrouhlením
<td><code class="pp">round(x)</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__round__"><code>x.<dfn>__round__</dfn>()</code></a>
<tr><th>
<td>převod na nejbližší číslo zaokrouhlením na <var>n</var> desetinných míst
<td><code class="pp">round(x, n)</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__round__"><code>x.<dfn>__round__</dfn>(n)</code></a>
<tr><th>
<td>nejmenší celé číslo <code>&gt;= x</code>
<td><code class="pp">math.ceil(x)</code>
<td><a href="http://docs.python.org/3.1/library/math.html#math.ceil"><code>x.<dfn>__ceil__</dfn>()</code></a>
<tr><th>
<td>největší celé číslo <code>&lt;= x</code>
<td><code class="pp">math.floor(x)</code>
<td><a href="http://docs.python.org/3.1/library/math.html#math.floor"><code>x.<dfn>__floor__</dfn>()</code></a>
<tr><th>
<td>odseknutí <code>x</code> na nejbližší celé číslo směrem k 0
<td><code class="pp">math.trunc(x)</code>
<td><a href="http://docs.python.org/3.1/library/math.html#math.trunc"><code>x.<dfn>__trunc__</dfn>()</code></a>
<tr><th><span class="inherit"><a href="http://www.python.org/dev/peps/pep-0357/">PEP 357</a></span>
<td>číslo jako index seznamu
<td><code class="pp">a_list[<var>x</var>]</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__index__"><code>a_list[x.<dfn>__index__</dfn>()]</code></a>
</table>

<h2 id=special-method-names-rich-comparisons>Třídy, které se dají porovnávat</h2>

<p>Tuto část jsem od předchozí oddělil, protože porovnání se neomezuje jen na čísla. Porovnávat se dají hodnoty mnoha datových typů&nbsp;&mdash;&nbsp;řetězce, seznamy a dokonce i slovníky. Pokud vytváříme svou vlastní třídu a má smysl uvažovat o porovnávání našeho objektu s jinými objekty, můžeme porovnání implementovat následujícími speciálními metodami.

<table>
<tr><th>Poznámky
<th>To, co chceme&hellip;
<th>Takže napíšeme&hellip;
<th>A Python zavolá&hellip;
<tr><th>
<td>rovnost
<td><code class="pp">x == y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__eq__"><code>x.<dfn>__eq__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>různost (nerovnost)
<td><code class="pp">x != y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__ne__"><code>x.<dfn>__ne__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>menší než
<td><code class="pp">x &lt; y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__lt__"><code>x.<dfn>__lt__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>menší než nebo rovno
<td><code class="pp">x &lt;= y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__le__"><code>x.<dfn>__le__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>větší než
<td><code class="pp">x &gt; y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__gt__"><code>x.<dfn>__gt__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>větší než nebo rovno
<td><code class="pp">x &gt;= y</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__ge__"><code>x.<dfn>__ge__</dfn>(<var>y</var>)</code></a>
<tr><th>
<td>pravdivostní hodnota v booleovském kontextu
<td><code class="pp">if x:</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__bool__"><code>x.<dfn>__bool__</dfn>()</code></a>
</table>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Pokud definujeme metodu <code>__lt__()</code>, ale nedefinujeme metodu <code>__gt__()</code>, použije Python metodu <code>__lt__()</code> s přehozenými operandy. Ale Python neprovádí kombinaci metod. Pokud například definujeme metodu <code>__lt__()</code> a metodu <code>__eq__()</code> a pokusíme se otestovat, zda je <code>x &lt;= y</code>, Python nezavolá postupně <code>__lt__()</code> a <code>__eq__()</code>. Zavolá pouze metodu <code>__le__()</code>.
</blockquote>

<h2 id=special-method-names-pickle>Třídy, které podporují serializaci</h2>
<!--see http://docs.python.org/3.1/library/pickle.html:-->

<p>Python podporuje <a href=#chapter-serializing>serializaci a deserializaci libovolných objektů</a>. (Většina pythonovských příruček tento proces nazývá „pickling“ a „unpickling“.) Může to být užitečné pro uložení stavu objektu do souboru a jeho pozdější obnovení. Všechny <a href=#chapter-native-datatypes>přirozené datové typy</a> již „piklení“ podporují. Pokud vytvoříte uživatelskou třídu a chcete ji umět serializovat, přečtěte si něco o <a href="http://docs.python.org/3.1/library/pickle.html">pickle protokolu</a>, abyste věděli, kdy a jak se volají následující speciální metody.

<table>
<tr><th>Poznámky
<th>To, co chceme&hellip;
<th>Takže napíšeme&hellip;
<th>A Python zavolá&hellip;
<tr><th>
<td>uživatelská kopie objektu
<td><code class="pp">copy.copy(x)</code>
<td><a href="http://docs.python.org/3.1/library/copy.html"><code>x.<dfn>__copy__</dfn>()</code></a>
<tr><th>
<td>uživatelská kopie objektu do hloubky (deep copy)
<td><code class="pp">copy.deepcopy(x)</code>
<td><a href="http://docs.python.org/3.1/library/copy.html"><code>x.<dfn>__deepcopy__</dfn>()</code></a>
<tr><th>*
<td>zjištění stavu objektu před serializací
<td><code class="pp">pickle.dump(x, <var>file</var>)</code>
<td><a href="http://docs.python.org/3.1/library/pickle.html#pickle-state"><code>x.<dfn>__getstate__</dfn>()</code></a>
<tr><th>*
<td>serializace objektu
<td><code class="pp">pickle.dump(x, <var>file</var>)</code>
<td><a href="http://docs.python.org/3.1/library/pickle.html#pickling-class-instances"><code>x.<dfn>__reduce__</dfn>()</code></a>
<tr><th>*
<td>serializace objektu (nový serializační protokol)
<td><code class="pp">pickle.dump(x, <var>file</var>, <var>protocol_version</var>)</code>
<td><a href="http://docs.python.org/3.1/library/pickle.html#pickling-class-instances"><code>x.<dfn>__reduce_ex__</dfn>(<var>protocol_version</var>)</code></a>
<tr><th>*
<td>kontrola nad vytvářením objektu během deserializace (unpickling)
<td><code class="pp">x = pickle.load(<var>file</var>)</code>
<td><a href="http://docs.python.org/3.1/library/pickle.html#pickling-class-instances"><code>x.<dfn>__getnewargs__</dfn>()</code></a>
<tr><th>*
<td>obnovení stavu objektu po deserializaci
<td><code class="pp">x = pickle.load(<var>file</var>)</code>
<td><a href="http://docs.python.org/3.1/library/pickle.html#pickle-state"><code>x.<dfn>__setstate__</dfn>()</code></a>
</table>

<p>* Při znovuvytváření serializovaného objektu musí Python nejdříve vytvořit nový objekt, který vypadá jako ten serializovaný, a potom musí nastavit hodnoty všech jeho atributů. Metoda <code>__getnewargs__()</code> řídí způsob vytváření objektu. Metoda <code>__setstate__()</code> poté řídí obnovení hodnot atributů.

<h2 id=special-method-names-context-managers>Třídy, které mohou být použity v bloku <code>with</code></h2>

<p>Blok <code>with</code> definuje operační kontext (<a href="http://www.python.org/doc/3.1/library/stdtypes.html#typecontextmanager">runtime context</a>). „Vstupujeme“ do něj (enter) v okamžiku provádění příkazu <code>with</code> a „vystupujeme“ z něj (exit) po provedení posledního příkazu v jeho bloku.

<table>
<tr><th>Poznámky
<th>To, co chceme&hellip;
<th>Takže napíšeme&hellip;
<th>A Python zavolá&hellip;
<tr><th>
<td>udělej něco speciálního při vstupu do bloku <code>with</code>
<td><code class="pp">with x:</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__enter__"><code>x.<dfn>__enter__</dfn>()</code></a>
<tr><th>
<td>udělej něco speciálního při opouštění bloku <code>with</code>
<td><code class="pp">with x:</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__exit__"><code>x.<dfn>__exit__</dfn>(<var>exc_type</var>, <var>exc_value</var>, <var>traceback</var>)</code></a>
</table>

<p><a href=#files-with>Obrat <code>with <var>soubor</var></code></a> funguje následovně:

<pre class=pp><code># výňatek z io.py
def _checkClosed(self, msg=None):
    '''Internal: raise an ValueError if file is closed
    '''
    if self.closed:
        raise ValueError('I/O operation on closed file.'
                         if msg is None else msg)

def __enter__(self):
    '''Context management protocol.  Returns self.'''
<a>    self._checkClosed()                                <span class=u>&#x2460;</span></a>
<a>    return self                                        <span class=u>&#x2461;</span></a>

def __exit__(self, *args):
    '''Context management protocol.  Calls close()'''
<a>    self.close()                                       <span class=u>&#x2462;</span></a></code></pre>
<ol>
<li>Objekt souboru definuje jak metodu <code>__enter__()</code>, tak metodu <code>__exit__()</code>. Metoda <code>__enter__()</code> kontroluje, zda je soubor otevřen. Pokud ne, vyvolá metoda <code>_checkClosed()</code> výjimku.
<li>Metoda <code>__enter__()</code> by měla téměř vždy vrátit <var>self</var>, což je objekt, který bude v bloku <code>with</code> použit pro práci s vlastnostmi (properties) a k volání metod.
<li>Po ukončení bloku <code>with</code> se souborový objekt automaticky uzavře. Jak se to udělá? V metodě <code>__exit__()</code> se zavolá <code>self.close()</code>.
</ol>

<blockquote class=note>
<p><span class="u">&#x261E;</span>Metoda <code>__exit__()</code> se zavolá vždy, dokonce i když je uvnitř bloku <code>with</code> vyvolána výjimka. Ve skutečnosti je to tak, že při vyvolání výjimky je informace o výjimce předána metodě <code>__exit__()</code>. Další detaily naleznete ve standardní dokumentaci: <a href="http://www.python.org/doc/3.1/reference/datamodel.html#with-statement-context-managers">With Statement Context Managers</a> (správci kontextu příkazu with).
</blockquote>

<p>O správcích kontextu se dozvíte víc v části <a href=#files-with>Automatické zavírání souborů</a> a <a href=#files-redirect>Přesměrování standardního výstupu</a>.

<h2 id=special-method-names-esoterica>Opravdu esoterické věci</h2>

<p>Pokud víme, co děláme, můžeme získat téměř úplnou kontrolu nad tím, jak jsou třídy porovnávány, jak jsou definovány atributy a jaký druh tříd se považuje za podtřídy naší třídy.

<table>
<tr><th>Poznámky
<th>To, co chceme&hellip;
<th>Takže napíšeme&hellip;
<th>A Python zavolá&hellip;
<tr><th>
<td>konstruktor třídy
<td><code class="pp">x = MyClass()</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__new__"><code>x.<dfn>__new__</dfn>()</code></a>
<tr><th>*
<td>destruktor třídy
<td><code class="pp">del x</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__del__"><code>x.<dfn>__del__</dfn>()</code></a>
<tr><th>
<td>definovat jen určité atributy
<td>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__slots__"><code>x.<dfn>__slots__</dfn>()</code></a>
<tr><th>
<td>uživatelská heš-hodnota
<td><code class="pp">hash(x)</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__hash__"><code>x.<dfn>__hash__</dfn>()</code></a>
<tr><th>
<td>získat hodnotu vlastnosti (property)
<td><code class="pp">x.color</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__get__"><code>type(x).<dfn>__dict__</dfn>['color'].__get__(x, type(x))</code></a>
<tr><th>
<td>nastavit hodnotu vlastnosti
<td><code class="pp">x.color = 'PapayaWhip'</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__set__"><code>type(x).<dfn>__dict__</dfn>['color'].__set__(x, 'PapayaWhip')</code></a>
<tr><th>
<td>zrušit vlastnost
<td><code class="pp">del x.color</code>
<td><a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__delete__"><code>type(x).<dfn>__dict__</dfn>['color'].__del__(x)</code></a>
<tr><th>
<td>zkontrolovat, zda je nějaký objekt instancí naší třídy
<td><code class="pp">isinstance(x, MyClass)</code>
<td><a href="http://www.python.org/dev/peps/pep-3119/#overloading-isinstance-and-issubclass"><code>MyClass.<dfn>__instancecheck__</dfn>(x)</code></a>
<tr><th>
<td>zkontrolovat, zda je nějaká třída podtřídou naší třídy
<td><code class="pp">issubclass(C, MyClass)</code>
<td><a href="http://www.python.org/dev/peps/pep-3119/#overloading-isinstance-and-issubclass"><code>MyClass.<dfn>__subclasscheck__</dfn>(C)</code></a>
<tr><th>
<td>zkontrolovat, zda je nějaká třída podtřídou naší abstraktní bázové třídy
<td><code class="pp">issubclass(C, MyABC)</code>
<td><a href="http://docs.python.org/3.1/library/abc.html#abc.ABCMeta.__subclasshook__"><code>MyABC.<dfn>__subclasshook__</dfn>(C)</code></a>
</table>

<p><sup>*</sup> Okolnosti toho, kdy přesně Python volá speciální metodu <code>__del__()</code>, <a href="http://www.python.org/doc/3.1/reference/datamodel.html#object.__del__">jsou neuvěřitelně komplikované</a>. Abyste tomu porozuměli úplně, musíte vědět, jakým způsobem <a href="http://www.python.org/doc/3.1/reference/datamodel.html#objects-values-and-types">Python sleduje objekty v paměti</a>. Tady najdete dobrý článek o <a href="http://www.electricmonk.nl/log/2008/07/07/python-destructor-and-garbage-collection-notes/">mechanismu automatického uvolňování paměti (garbage collection) a o destruktorech tříd v jazyce Python</a> (anglicky). Měli byste si také přečíst o <a href="http://mindtrove.info/articles/python-weak-references/">slabých referencích</a> (weak references), o <a href="http://docs.python.org/3.1/library/weakref.html">modulu <code>weakref</code></a> a navrch pravděpodobně také o <a href="http://www.python.org/doc/3.1/library/gc.html">modulu <code>gc</code></a>.

<h2 id=special-method-names-furtherreading>Přečtěte si</h2>

<p>Moduly zmíněné v této příloze (standardní dokumentace):

<ul>
<li><a href="http://docs.python.org/3.1/library/zipfile.html">Modul <code>zipfile</code></a>
<li><a href="http://docs.python.org/3.1/library/cgi.html">Modul <code>cgi</code></a>
<li><a href="http://docs.python.org/3.1/library/collections.html">Modul <code>collections</code></a>
<li><a href="http://docs.python.org/3.1/library/math.html">Modul <code>math</code></a>
<li><a href="http://docs.python.org/3.1/library/pickle.html">Modul <code>pickle</code></a>
<li><a href="http://docs.python.org/3.1/library/copy.html">Modul <code>copy</code></a>
<li><a href="http://docs.python.org/3.1/library/abc.html">Modul <code>abc</code></a> („Abstract Base Classes“; abstraktní bázové třídy)
</ul>

<p>Další objasňující čtení (standardní dokumentace):

<ul>
<li><a href="http://www.python.org/doc/3.1/library/string.html#formatspec">Format Specification Mini-Language</a> (minijazyk pro specifikaci formátu)
<li><a href="http://www.python.org/doc/3.1/reference/datamodel.html">Python data model</a> (pythonovský datový model)
<li><a href="http://www.python.org/doc/3.1/library/stdtypes.html">Built-in types</a> (zabudované typy)
<li><a href="http://www.python.org/dev/peps/pep-0357/"><abbr>PEP</abbr> 357: Allowing Any Object to be Used for Slicing</a> (jak umožnit každému objektu být použit pro řezy)
<li><a href="http://www.python.org/dev/peps/pep-3119/"><abbr>PEP</abbr> 3119: Introducing Abstract Base Classes</a> (úvod do abstraktních bázových tříd)
</ul>

</div>
<div id=chapter-where-to-go-from-here>
<div id=appc>
<h1>Čím pokračovat</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> Go forth on your path, as it exists only through your walking. <span class="u">&#x275E;</span><br>(Jdi dál svou cestou, protože ta existuje jen pod tvými kroky.)<br>&mdash; Sv. Augustin z Hippo (připisováno)
</blockquote>
<p>&nbsp;
<h2 id=where-to-go-from-here-things-to-read>Doporučuji k přečtení</h2>
<p class=f>V této knize se bohužel nemůžu zabývat všemi stránkami jazyka Python 3. Naštěstí můžete všude najít mnoho nádherných, volně dostupných učebnic.

<p>Dekorátory:

<ul>
<li><a href="http://programmingbits.pythonblogs.com/27_programmingbits/archive/50_function_decorators.html">Function Decorators</a> &mdash; Ariel Ortiz (dekorátory funkcí)
<li><a href="http://programmingbits.pythonblogs.com/27_programmingbits/archive/51_more_on_function_decorators.html">More on Function Decorators</a> &mdash; Ariel Ortiz (více o dekorátorech funkcí)
<li><a href="http://www.ibm.com/developerworks/linux/library/l-cpdecor.html">Charming Python: Decorators make magic easy</a> &mdash; David Mertz (dekorátory činí kouzlení snadným)
<li><a href="http://docs.python.org/reference/compound_stmts.html#function">Function Definitions</a> (definice funkcí) v oficiální pythonovské dokumentaci
</ul>

<p>Vlastnosti (properties):

<ul>
<li><a href="http://adam.gomaa.us/blog/2008/aug/11/the-python-property-builtin/">The Python <code>property</code> builtin</a> &mdash; Adam Gomaa
<li><a href="http://tomayko.com/writings/getters-setters-fuxors">Getters/Setters/Fuxors</a> &mdash; Ryan Tomayko
<li><a href="http://docs.python.org/library/functions.html#property"><code>property()</code> function</a> v oficiální pythonovské dokumentaci
</ul>

<p>Deskriptory:

<ul>
<li><a href="http://users.rcn.com/python/download/Descriptor.htm">How-To Guide For Descriptors</a> &mdash; Raymond Hettinger
<li><a href="http://www.ibm.com/developerworks/linux/library/l-python-elegance-2.html">Charming Python: Python elegance and warts, Part 2</a> &mdash; David Mertz
<li><a href="http://www.informit.com/articles/printerfriendly.aspx?p=1309289">Python Descriptors</a> &mdash; Mark Summerfield
<li><a href="http://docs.python.org/3.1/reference/datamodel.html#invoking-descriptors">Invoking Descriptors</a> v oficiální pythonovské dokumentaci
</ul>

<p>Vlákna a multiprocesing:</p>

<ul>
<li><a href="http://docs.python.org/3.1/library/threading.html">Modul <code>threading</code></a>
<li><a href="http://www.doughellmann.com/PyMOTW/threading/"><code>threading</code>&nbsp;&mdash;&nbsp;Manage concurrent threads</a>
<li><a href="http://docs.python.org/3.1/library/multiprocessing.html">Modul <code>multiprocessing</code></a>
<li><a href="http://www.doughellmann.com/PyMOTW/multiprocessing/"><code>multiprocessing</code>&nbsp;&mdash;&nbsp;Manage processes like threads</a>
<li><a href="http://jessenoller.com/2009/02/01/python-threads-and-the-global-interpreter-lock/">Python threads and the Global Interpreter Lock</a> &mdash; Jesse Noller
<li><a href="http://blip.tv/file/2232410">Inside the Python <abbr>GIL</abbr> (video)</a> &mdash; David Beazley
</ul>

<p>Metatřídy:

<ul>
<li><a href="http://www.ibm.com/developerworks/linux/library/l-pymeta.html">Metaclass programming in Python</a> &mdash; David Mertz a Michele Simionato
<li><a href="http://www.ibm.com/developerworks/linux/library/l-pymeta2/">Metaclass programming in Python, Part 2</a> &mdash; David Mertz a Michele Simionato
<li><a href="http://www.ibm.com/developerworks/linux/library/l-pymeta3.html">Metaclass programming in Python, Part 3</a> &mdash; David Mertz a Michele Simionato
</ul>

<p>A navíc fantastický průvodce mnoha moduly ze standardní pythonovské knihovny od Douga Hellmana &mdash; <a href="http://www.doughellmann.com/PyMOTW/contents.html">Python Module of the Week</a>.

<h2 id=where-to-go-from-here-code>Kde hledat kód kompatibilní s Pythonem 3</h2>

<p>Python 3 je relativně nový, takže o kompatibilní knihovny je nouze. Tady jsou nějaká místa, kde můžete hledat kód, který funguje s Pythonem 3 (vše anglicky).

<ul>
<li><a href="http://pypi.python.org/pypi?:action=browse&amp;c=533&amp;show=all">Python Package Index: seznam balíčků pro Python 3</a>
<li><a href="http://code.activestate.com/recipes/langs/python/tags/meta:min_python_3/">Python Cookbook: Python Cookbook: seznam receptů pro Python 3</a>
<li><a href="http://code.google.com/hosting/search?q=label:python3">Google Project Hosting: seznam projektů označkovaných „python3“</a>
<li><a href="http://sourceforge.net/search/?words=%22python+3%22">SourceForge: seznam projektů vyhledaných podle „Python 3“</a>
<li><a href="http://github.com/search?type=Repositories&amp;language=python&amp;q=python3">GitHub: seznam projektů vyhledaných podle „python3“</a> (a také <a href="http://github.com/search?type=Repositories&amp;language=python&amp;q=python+3">podle „python 3“</a>)
<li><a href="http://bitbucket.org/repo/all/?name=python3">BitBucket: seznam projektů vyhledaných podle „python3“</a> (a <a href="http://bitbucket.org/repo/all/?name=python+3">podle „python 3“</a>)
</ul>

</div>
<div id=chapter-troubleshooting>
<div id=appd>
<h1>Odstraňování problémů</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> Where’s the <kbd>ANY</kbd> key? <span class="u">&#x275E;</span><br>(Kde je <kbd>LIBOVOLNÁ</kbd> klávesa?)<br>&mdash; <a href="http://www.wherestheanykey.co.uk">připisováno kdekomu</a>
</blockquote>
<p>&nbsp;

<h2 id=troubleshooting-divingin>Ponořme se</h2>
<p class=f>DOPSAT

<h2 id=troubleshooting-getting-to-the-command-line>Jak se dostat k příkazovému řádku</h2>
<p>V celé knize se setkáváme s příklady spouštění Pythonu z příkazového řádku. Ale jak se máte k příkazovému řádku dostat?

<p>V Linuxu se podívejte do menu <b><code>Applications</code></b> a hledejte program zvaný <b><code>Terminal</code></b>. (Může se nacházet v podmenu jako <b><code>Accessories</code></b> nebo <b><code>System</code></b>.)

<p>V Mac OS X naleznete v adresáři <code>/Application/Utilities/</code> aplikaci nazvanou <b><code>Terminal.app</code></b>. Dostanete se tam tak, že kliknete na pracovní plochu, otevřete menu <b><code>Go</code></b>, vyberete <b><code>Go to folder...</code></b> (přejít do adresáře) a napíšete <kbd>/Applications/Utilities/</kbd>. Nakonec poklepete na program <b><code>Terminal</code></b>.

<p>Ve Windows kliknete na <b><code>Start</code></b>, vyberete položku <b><code>Spustit...</code></b>, napíšete <kbd>cmd</kbd> a stisknete <kbd>ENTER</kbd>.

<h2 id=troubleshooting-running-python-on-the-command-line>Spuštění Pythonu z příkazového řádku</h2>

<p>Jakmile se <a href=#troubleshooting-getting-to-the-command-line>dostanete na příkazový řádek</a>, měli byste být schopni spustit pythonovský interaktivní shell. V Linuxu nebo v Mac OS X napište na příkazový řádek <kbd>python3</kbd> a stiskněte <kbd>ENTER</kbd>. Ve Windows napište na příkazový řádek <kbd>c:\python31\python</kbd> a stiskněte <kbd>ENTER</kbd>. Pokud půjde vše dobře, měli byste vidět něco takového:

<pre class='nd screen'>
<samp class=p>you@localhost:~$ </samp><kbd>python3</kbd>
<samp>Python 3.1 (r31:73572, Jul 28 2009, 06:52:23)
[GCC 4.2.4 (Ubuntu 4.2.4-1ubuntu4)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>></samp></pre>

<p>(Až budete chtít pythonovský interaktivní shell opustit a vrátit se na příkazový řádek, napište <kbd>exit()</kbd> a stiskněte <kbd>ENTER</kbd>. Tento obrat funguje na všech platformách.)

<p>Pokud zpozorujete chybu „příkaz nenalezen“ (command not found), znamená to, že pravděpodobně <a href=#chapter-installing-python>nemáte Python 3 nainstalován</a>.

<pre class='nd screen'>
<samp class=p>you@localhost:~$ </samp><kbd>python3</kbd>
<samp>bash: python3: command not found</samp></pre>

<p>Pokud se do pythonovského interaktivního shellu dostanete, ale číslo verze neodpovídá vašemu očekávání, máte možná nainstalovánu více než jednu verzi Pythonu. Stává se to spíš na systémech Linux a Mac OS X, kde může být starší verze Pythonu předinstalována. Poslední verzi můžete nainstalovat, aniž byste museli starší verzi mazat (mohou být bez problémů instalovány vedle sebe), ale při spouštění Pythonu z příkazového řádku se pak musíte vyjádřit přesněji.

<p>Například na svém domácím linuxovém stroji mám nainstalováno několik verzí Pythonu, abych na nich mohl otestovat software, který vytvářím. Když chci spustit určitou verzi, můžu napsat <code>python3.0</code>, <code>python3.1</code> nebo <code>python2.6</code>.

<pre class='nd screen'>
<samp class=p>mark@atlantis:~$ </samp><kbd>python3.0</kbd>
<samp>Python 3.0.1+ (r301:69556, Apr 15 2009, 17:25:52)
[GCC 4.3.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> </samp><kbd class=pp>exit()</kbd>
<samp class=p>mark@atlantis:~$ </samp><kbd>python3.1</kbd>
<samp>Python 3.1 (r31:73572, Jul 28 2009, 06:52:23)
[GCC 4.2.4 (Ubuntu 4.2.4-1ubuntu4)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> </samp><kbd class=pp>exit()</kbd>
<samp class=p>mark@atlantis:~$ </samp><kbd>python2.6</kbd>
<samp>Python 2.6.5 (r265:79063, Apr 16 2010, 13:57:41)
[GCC 4.4.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> </samp><kbd class=pp>exit()</kbd></pre>

</div>
<div id=chapter-changelog>
<div id=appe>
<h1>Seznam oprav a úprav</h1>

<p>Nejnovější záznamy jsou nahoře.


<pre>
2012-03-27  Do indexové stránky doplněny odkazy na alternativní PDF a single.html
2012-03-27  Upravena dávka pack.py (single.html, .pdf)
2012-03-27  Upraveny soubory pro generování ploché verze (single.html)
2012-03-27  Odstraněny nepoužívané skripty (jsou dostupné u anglického originálu)
2012-03-27  Zjednodušeny transformační skripty
2012-03-27  Doplněna poznámka o Pilgrimově informační sebevraždě
2012-03-27  Na úvodní stránce doplněn odkaz na gitové úložiště
2012-03-27  Opraven skript pro generování seznamu změn
2012-03-27  Oprava chyb značkování HTML
2012-03-27  Opravena řada chyb zápisu odkazů &lt;a href... />text&lt;/a>
2012-03-27  Opraven odkaz na chardet pro Python 2 (nyní PyPI -- díky patří zu1234)
2012-02-28  Překlep; oprava URL pro generování PDF
2012-02-28  util/buildchangelog.py generuje changelog.html s unixovými konci řádků
2012-02-28  Upraven readme.txt
2012-02-28  merge s domácími úpravami
2012-02-28  překlep (en=fb52df)
2012-02-28  index.html - link na https://github.com/diveintomark/
2012-02-28  upraven rok v copyright
2012-02-28  překlepy a drobnosti (en=7fea56, 41c3d54)
2012-02-28  special-method-names.html - vysvětlení funkce any() (en=5565d9)
2012-02-28  serializing.html - "převážně blábol" (en=7407a4)
2012-02-28  advanced-iterators.html - doplněn chybějící výsledek příkladu (en=5dd2f3)
2012-02-28  úpravy stylu util/prince.css pro generování PDF (en=2137dc)
2012-02-28  where-to-go-from-here.html - lepší URL pro seznam receptů pro Python 3
2012-02-28  unit-testing.html - seznam-->n-tice (en=b8a1f0)
2012-02-28  index.html - opravy href odkazů na zip soubor ke stáhnutí
2012-02-27  files.html - přidána proměnná pro návratovou hodnotu sys.stdout.write
2012-02-27  regular-expressions.html - odstranění nadbytečných řádků příkladu (en=cbce10)
2012-02-27  refactoring.html - test na neceločíselnost před test rozsahu (en=76a14e)
2012-02-27  iterators.html - vyjasnění (en=dc45dd)
2012-02-27  unit-testing.html - přidán import, aby to bylo jasnější (en=12ec7c2)
2012-02-27  your-first-python-program.html - dokončeno formátování podle originálu
2012-02-27  your-first-python-program.html - zahájeny úpravy formátování; nedokončeno
2012-02-27  xml.html - formátování upraveno podle originálu
2012-02-27  where-to-go-from-here.html - formátování upraveno podle originálu
2012-02-27  whats-new.html - formátování upraveno podle originálu
2012-02-27  unit-testing.html - formátování upraveno podle originálu
2012-02-27  table-of-contents.html - drobná úprava formátování podle originálu
2012-02-27  troubleshooting.html - formátování upraveno podle originálu
2012-02-27  strings.html - formátování opraveno podle originálu
2012-02-27  special-method-names.html - formát upraven podle originálu
2012-02-26  serializing.html - formát upraven podle originálu
2012-02-26  regular-expressions.html - formátování upraveno podle originálu
2012-02-26  refactoring.html - formátování upraveno podle originálu
2012-02-26  porting-code-to-python-3-with-2to3.html - formát upraven podle originálu
2012-02-26  packaging.html - formátování upraveno podle originálu
2012-02-26  native-datatypes.html - formátování upraveno podle originálu
2012-02-25  iterators.html - formátování upraveno podle originálu
2012-02-25  installing-python.html - formátování podle originálu
2012-02-24  changelog.html odkazuje zpět a troubleshooting.html na něj
2012-02-24  where-to-go-from-here.html - oprava překladu názvu publikace
2012-02-24  Oprava case-study-porting-chardet-to-python-3.html
2012-02-24  Doplnění a oprava table-of-contents.html
2012-02-24  changelog.html se nesleduje, vždy se generuje
2012-02-24  .gitignore
2012-02-24  oprava clean.bat
2012-02-24  changelog.txt se přestal sledovat, vždy se generuje
2012-02-24  Upraveny dip3.css -- zohlednění existence přílohy E
2012-02-24  util/buildchangelog.py - kostra pro generování budoucího changelog.html
2012-02-24  Prozatimní generování changelog.txt, balení dávkou ziphtml.bat
2012-02-24  changelog.html - provizorně zařazen natvrdo
2012-02-24  util/flatten2.py - doplněn changelog.html pro generování HTML
2012-02-24  index.html - naformátováno podle originálu + úpravy
2012-02-24  changelog.txt zařazen mezi sledované
2012-02-24  http-web-services.html - formátování upraveno podle originálu
2012-02-24  gitlog.bat přejmenován na changelog.bat
2012-02-24  generators.html - formátování upraveno podle originálu
2012-02-24  Odstraněn podadresář en s originální anglickou verzí
2012-02-23  Ještě jednou afametika -> algebrogram
2012-02-23  files.html - formátování upraveno podle originálu
2012-02-23  Náhrada speciálních znaků sekvencemi
2012-02-23  comprehensions.html - formátování podle originálu
2012-02-23  colophon.html - formátování podle originálu
2012-02-23  Hromadné náhrady speciálních znaků sekvencemi
2012-02-23  about.html a advanced-iterators.html - doladění formátu
2012-02-23  case-study-porting-chardet-to-python-3.html - formát podle originálu
2012-02-23  Hromadné náhrady přímých znaků HTML escape sekvencemi (&amp;nbsp; a další)
2012-02-22  case-study-porting-chardet-to-python-3.html - formátování podle originálu
2012-02-22  Přidána dávka gitlog.bat (stručný seznam změn)
2012-02-22  blank.html - formátování upraveno podle originálu
2012-02-22  advanced-iterators.html - upraveno formátování podle originálu
2012-02-22  Pojem alfametika nebo alfametická hádanka změněn na algebrogram
2012-02-22  about.html naformátováno podle originálu
2012-02-22  Přidána dávka rebuildAll.bat a popis readme.txt
2012-02-22  .gitignore
2012-02-22  Přidána anglická verze r867
2012-02-22  Přidány pomocné dávky a skripty
2012-02-21  Odkazy na originál změněny na nové
2012-02-21  U HTML souborů byl odstraněn BOM (tj. teď je UTF-8 bez BOM)
2011-10-02  První hotová verze (CZ.NIC).</pre>

<p class=a>&#x2042;

</div>
<div id=chapter-about>
<h1>O knize</h1>
<div id=about-belong>
<div>
<p><cite>Ponořme se do Pythonu 3</cite> obsahuje původní textový obsah a grafiku použitou <a href="http://creativecommons.org/licenses/by-sa/3.0/" rel="license" title="Creative Commons Attribution-ShareAlike 3.0 Unported">pod licencí CC-BY-SA-3.0</a>. Ilustrace pocházejí z <a href="http://openclipart.org/">Open Clip Art Library</a> a jsou deklarovány jako public domain.
<p><a href=#chapter-case-study-porting-chardet-to-python-3>Knihovna <code>chardet</code></a> je licencovaná pod <abbr title="GNU Lesser General Public License">LGPL</abbr> 2.1 nebo novější. <a href=#chapter-advanced-iterators>Řešitel algebrogramů</a> je přepisem z <a href="http://code.activestate.com/recipes/576615/">verze Raymonda Hettingera</a>. Jeho kód byl uvolněn pod licencí <abbr>MIT</abbr>. V několika kapitolách naleznete kód z pythonovské standardní knihovny. Ten byl uvolněn pod <abbr title="Python Software Foundation">PSF</abbr> License 2.0. Veškerý další původní kód je licencován MIT licencí.
<p>On-line vydání používá <a href="http://jquery.com">jQuery</a>, uvolněné pod licencemi <abbr>MIT</abbr> a <abbr title="GNU General Public License">GPL</abbr>. <span style="color:red">B</span><span style="color:aqua">a</span><span style="color:plum">r</span><span style="color:gold">e</span><span style="color:blue">v</span><span style="color:red">n</span><span style="color:aqua">é</span> zvýrazňování syntaxe realizuje <a href="http://code.google.com/p/google-code-prettify/">prettify.js</a>. Další kód pro zvýraznění syntaxe je upraven z <a href="http://code.google.com/p/javascript-search-term-highlighter/">highlighter.js</a>. Oba skripty jsou uvolněny pod Apache License 2.0.
<p>Opravy a zpětnou vazbu posílejte na <a href="mailto:mark@diveintomark.org">mark@diveintomark.org</a><br>(netýká se to českého překladu)
</div>
</div>
</div>
<div id=chapter-colophon>
<h1>Tiráž</h1>
<blockquote class=q>
<p><span class="u">&#x275D;</span> <i lang="fr">Je n’ai fait celle-ci plus longue que parce que je n’ai pas eu le loisir de la faire plus courte.</i><br>(I would have written a shorter letter, but I did not have the time.) <span class="u">&#x275E;</span><br>(Napsal bych kratší dopis, ale neměl jsem čas.)<br>&mdash; <a href="http://en.wikiquote.org/wiki/Blaise_Pascal">Blaise Pascal</a>
</blockquote>
<p>&nbsp;
<h2 id=colophon-divingin>Ponořme se</h2>
<p class=f>Tato kniha, jako všechny knihy, je prací z lásky. Ale jistě, dostal jsem za ni rozumně zaplaceno, ale nikdo nepíše technické knihy kvůli penězům. A protože je dostupná na webu a také na papíře, hodně času jsem strávil pipláním se s webovými záležitostmi v době, kdy jsem měl psát.

<p class='ss nm'><img src="i/openclipart.org_media_files_johnny_automatic_5261.png" width="314" height="273" alt="[psací stroj]" />

<p>On-line edice se načítá tak efektivně, jak jen to šlo. Efektivnost se nikdy nepřihodí jen tak. Strávil jsem s tím spoustu hodin. Možná až příliš mnoho hodin. Ano, téměř určitě příliš mnoho hodin. Nikdy nepodceňujte hloubky, do kterých se stále něco odkládající autor noří.

<p>Nebudu vás všemi těmi detaily nudit. Nebo ano, počkejte&nbsp;&mdash;&nbsp;budu vás nudit všemi těmi detaily. Ale předložím vám jen zkrácenou verzi.

<ol>
<li>HTML je minimalizované a servírované <a href="http://httpd.apache.org/docs/trunk/mod/mod_deflate.html">v komprimované podobě</a>.
<li>Skripty a kaskádové styly jsou minimalizované <a href="http://developer.yahoo.com/yui/compressor/">YUI-kompresorem</a> (a rovněž předkládané jako komprimované).
<li>Skripty jsou spojené kvůli redukci HTTP požadavků.
<li>Styly jsou spojené kvůli redukci HTTP požadavků.
<li>Nepoužité CSS selektory a vlastnosti jsou <a href="http://hg.diveintopython3.org/file/default/util/lesscss.py">odstraněny na základě potřeb jednotlivých stránek</a> s trochou pomoci od <a href="http://pyquery.org/">pyquery</a>.
<li>Využívání HTTP mezipaměti a další volby na straně serveru jsou optimalizovány na základě rad od <a href="http://developer.yahoo.com/yslow/">YSlow</a> a <a href="http://code.google.com/speed/page-speed/">Page Speed</a>.
<li>Stránky používají <a href="http://www.alanwood.net/unicode/unicode_samples.html">Unicode znaky</a> místo obrázků, kde to jen bylo možné.
<li>Obrázky jsou optimalizovány nástrojem <a href="http://optipng.sourceforge.net/">OptiPNG</a>.
<li>Celá kniha byla <a href="http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition">napsána s láskou, ručně, v HTML 5</a> ve snaze vyhnout se značkovacímu smetí.
</ol>

<p class=a>&#x2042;

<h2 id=colophon-typography>Typografie</h2>

<p>Vertikální členění, nejlepší možný ampersand (hledejte v originále), oblé uvozovky a apostrofy, další věci z webtypography.net

<p class=a>&#x2042;

<h2 id=colophon-graphics>Grafika</h2>

<p>Unicode, popisky, záležitosti rodin písem na Windows

<p class=a>&#x2042;

<h2 id=colophon-performance>Výkonnost</h2>

<p>"Dive into history, 2009 edition“, minimalizace CSS + JS + HTML, inline CSS, optimalizace obrázků

<p class=a>&#x2042;

<h2 id=colophon-fun>Srandičky</h2>

<p>Citáty, psaní podle vynucených pravidel (constrained writing), PapayaWhip

<p class=a>&#x2042;

<h2 id=colophon-furtherreading>Přečtěte si (vše anglicky)</h2>

<ul>
<li><a href="http://webtypography.net/toc/">The Elements of Typographic Style Applied to the Web</a>
<li><a href="http://www.alistapart.com/articles/settingtypeontheweb">Setting Type on the Web to a Baseline Grid</a>
<li><a href="http://24ways.org/2006/compose-to-a-vertical-rhythm">Compose to a Vertical Rhythm</a>
<li><a href="http://simplebits.com/notebook/2008/08/14/ampersands.html">Use the Best Available Ampersand</a>
<li><a href="http://alanwood.net/unicode/">Unicode Support in HTML, Fonts, and Web Browsers</a>
<li><a href="http://developer.yahoo.com/yslow/">YSlow</a> pro <a href="http://getfirebug.com/">Firebug</a>
<li><a href="http://developer.yahoo.com/performance/rules.html">Best Practices for Speeding Up Your Web Site</a>
<li><a href="http://stevesouders.com/hpws/rules.php">14 Rules for Faster-Loading Web Sites</a>
<li><a href="http://developer.yahoo.com/yui/compressor/">YUI Compressor</a>
<li><a href="http://code.google.com/speed/page-speed/">Google Page Speed</a>
<li><a href="http://code.google.com/speed/page-speed/docs/using.html">Using Google Page Speed</a>
<li><a href="http://optipng.sourceforge.net/">OptiPNG</a>
</ul>

</div>
<p class=c>&copy; 2001&ndash;11 <a href="http://diveintopython3.ep.io/about.html">Mark Pilgrim</a>
</body>
</html>
